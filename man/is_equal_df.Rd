% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pal-GEN.R
\name{is_equal_df}
\alias{is_equal_df}
\title{Determine if two data frames/tibbles are equal}
\usage{
is_equal_df(
  x,
  y,
  ignore_col_order = FALSE,
  ignore_row_order = FALSE,
  ignore_col_types = FALSE,
  tolerance = NULL,
  quiet = TRUE,
  max_diffs = 10L,
  return_waldo_compare = FALSE
)
}
\arguments{
\item{x, y}{Two data frames/tibbles to compare. \code{y} is treated as the reference object, so messages describe how \code{x} is different to \code{y}.}

\item{ignore_col_order}{Whether or not to ignore the order of columns.}

\item{ignore_row_order}{Whether or not to ignore the order of rows.}

\item{ignore_col_types}{Whether or not to distinguish similar column types. Currently, if set to \code{TRUE}, this will convert factor to character and integer to
double before comparison.}

\item{tolerance}{If non-\code{NULL}, used as threshold for ignoring small
floating point difference when comparing numeric vectors. Setting to
any non-\code{NULL} value will cause integer and double vectors to be compared
based on their values, rather than their types.

It uses the same algorithm as \code{\link[=all.equal]{all.equal()}}, i.e., first we generate
\code{x_diff} and \code{y_diff} by subsetting \code{x} and \code{y} to look only locations
with differences. Then we check that
\code{mean(abs(x_diff - y_diff)) / mean(abs(y_diff))} (or just
\code{mean(abs(x_diff - y_diff))} if \code{y_diff} is small) is less than
\code{tolerance}.}

\item{quiet}{Whether or not to output detected differences between \code{x} and \code{y} to the console.}

\item{max_diffs}{The maximum number of differences shown. Only relevant if \code{quiet = FALSE} or \code{return_waldo_compare = TRUE}. Set \code{max_diffs = Inf} to see all
differences.}

\item{return_waldo_compare}{Whether to return a character vector of class \code{\link[waldo:compare]{waldo_compare}} describing the differences between \code{x} and \code{y}
instead of \code{TRUE} or \code{FALSE}.}
}
\value{
If \code{return_waldo_compare = FALSE}, a logical scalar indicating the result of the comparison. Otherwise a character vector of class
\code{\link[waldo:compare]{waldo_compare}} describing the differences between \code{x} and \code{y}.
}
\description{
Compares two \link[base:data.frame]{data frames}/\link[tibble:tbl_df-class]{tibbles} (or two objects coercible to tibbles like \link[base:matrix]{matrices}), optionally
ignoring row and column ordering, and returns \code{TRUE} if both are equal, or \code{FALSE} otherwise. If the latter is the case and \code{quiet = FALSE}, information
about detected differences is printed to the console.
}
\details{
Under the hood, this function relies on \code{\link[waldo:compare]{waldo::compare()}}.
}
\examples{
scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))]

# by default, ordering of rows and columns matters ...
pal::is_equal_df(x = mtcars,
                 y = scramble(mtcars))

# ... but those can be ignored if desired
pal::is_equal_df(x = mtcars,
                 y = scramble(mtcars),
                 ignore_col_order = TRUE)
pal::is_equal_df(x = mtcars,
                 y = scramble(mtcars),
                 ignore_row_order = TRUE)

# by default, `is_equal_df()` is sensitive to column type differences ...
df1 <- data.frame(x = "a",
                  stringsAsFactors = FALSE)
df2 <- data.frame(x = factor("a"))
pal::is_equal_df(df1, df2)

# ... but you can request it to not make a difference between similar types
pal::is_equal_df(df1, df2,
                 ignore_col_types = TRUE)
}
\seealso{
Other data frame / tibble functions:
\code{\link{reduce_df_list}()}
}
\concept{tibble}
