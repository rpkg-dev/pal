% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pal.gen.R
\name{cols_regex}
\alias{cols_regex}
\title{Create \link[readr:readr-package]{readr} column specification using regular expression matching}
\usage{
cols_regex(..., .col_names, .default = readr::col_character())
}
\arguments{
\item{...}{Named arguments where the names are (Perl-compatible) regular expressions and the values are column objects created by \verb{col_*()}, or their
abbreviated character names (as described in the \code{col_types} parameter of \code{\link[readr:read_delim]{readr::read_delim()}}). \link[rlang:dyn-dots]{Dynamic dots} are supported.}

\item{.col_names}{Column names which should be matched by \code{...}.}

\item{.default}{Any named columns not matched by any of the regular expressions in \code{...} will be read with this column type.}
}
\value{
A \link[readr:cols]{column specification}.
}
\description{
Allows to define a regular expression per desired \link[readr:cols]{column specification object} matching the respective column names.
}
\details{
The main limitation of \code{cols_regex()} is that it needs to know the input dataset's full set of \code{.col_names} in advance, for which \code{\link[=dsv_colnames]{dsv_colnames()}} can help.
See the examples for further details.
}
\examples{
library(magrittr)

# for some hypothetical CSV data column names like these...
col_names <- c("VAR1_Text",
               "VAR2_Text",
               "VAR3_Text_Other",
               "VAR1_Code_R1",
               "VAR2_Code_R2",
               "HAS_R1_Lag",
               "HAS_R2_Lag",
               "GARBAGEX67",
               "GARBAGEY09")

# ...a column spec could be created concisely as follows:
col_regex <- list("_Text(_|$)" = "c",
                  "_Code(_|$)" = "i",
                  "^GARBAGE"   = readr::col_skip())

pal::cols_regex(.col_names = col_names,
                !!!col_regex,
                .default = "l")

# we can parse some real data:
url <- "https://salim_b.gitlab.io/misc/Kantonsratswahl_Zuerich_2019_Ergebnisse_Gemeinden.csv"

raw_data <-
  httr2::request(url) |>
  httr2::req_perform() |>
  httr2::resp_body_string()

col_spec <- pal::cols_regex("^(Gemeindenamen|Liste|Wahlkreis)$" = "c",
                            "(?i)anteil" = "d",
                            .default = "i",
                            .col_names = pal::dsv_colnames(raw_data))
print(col_spec)

readr::read_csv(file = raw_data,
                col_types = col_spec)

# we can also do basically the same in a more concise way without having to rely on
# `pal::dsv_colnames()`:
readr::read_csv(file = url,
                col_types = list(.default = "c")) \%>\%
  readr::type_convert(col_types = pal::cols_regex("^(Gemeindenamen|Liste|Wahlkreis)$" = "c",
                                                  "(?i)anteil" = "d",
                                                  .default = "i",
                                                  .col_names = colnames(.)))
}
