% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pal.gen.R
\name{as_flat_list}
\alias{as_flat_list}
\title{Convert to a flat list}
\usage{
as_flat_list(
  x,
  is_node = NULL,
  name_spec = "{outer}.{inner}",
  name_repair = c("minimal", "unique", "check_unique", "universal")
)
}
\arguments{
\item{x}{An \R object.}

\item{is_node}{A predicate function that determines whether an element is
a node (by returning \code{TRUE}) or a leaf (by returning \code{FALSE}). The
default value, \code{NULL}, treats simple lists as nodes and everything else
(including richer objects like data frames and linear models) as leaves,
using \code{\link[vctrs:obj_is_list]{vctrs::obj_is_list()}}. To recurse into all objects built on lists
use \code{\link[=is.list]{is.list()}}.}

\item{name_spec}{If both inner and outer names are present, control
how they are combined. Should be a glue specification that uses
variables \code{inner} and \code{outer}.}

\item{name_repair}{One of \code{"minimal"}, \code{"unique"}, \code{"universal"}, or
\code{"check_unique"}. See \code{\link[vctrs:vec_as_names]{vctrs::vec_as_names()}} for the meaning of these
options.}
}
\value{
A list.
}
\description{
Recursively flattens an \R object. Unlike \code{\link[base:unlist]{base::unlist()}}, it
\itemize{
\item always returns a list, i.e. wraps \code{x} in a list if necessary, and will never remove the last list level. Thus it is
\href{https://en.wikipedia.org/wiki/Type_safety}{type-safe}.
\item won't treat any of the list leafs specially (like \code{unlist()} does with factors). Thus leaf values will never be modified.
}
}
\examples{
library(magrittr)

nested_list <- list(1:3, list("foo", list("bar"))) \%T>\% str()

# unlike `unlist()` which also removes the last list tier in many cases...
unlist("foobar")
unlist(nested_list) |> str()
# ...this function always returns an (unnested) list
pal::as_flat_list("foobar") |> str()
pal::as_flat_list(nested_list) |> str()

nested_list <- list(list(factor("a"), factor("b")), factor("c")) \%T>\% str()

# unlike `unlist()` which combines factors...
unlist(nested_list) |> str()
# ...this function does not modify the list elements
pal::as_flat_list(nested_list) |> str()

nested_list <-
  list(c(list(1L), list(tibble::tibble(a = list(1.1, "2")))),
       list(tibble::as_tibble(mtcars[1:2, ]))) \%T>\%
  str()
nested_list_2 <- list(1:3, xfun::strict_list(list(list("buried deep")))) \%T>\% str()

# by default, classed lists like data frames, tibbles or `xfun_strict_list` are retained, i.e.
# not flattened...
pal::as_flat_list(nested_list) |> str()
pal::as_flat_list(nested_list_2) |> str()
# ...but you can drop them and thereby flatten custom objects if needed...
pal::as_flat_list(nested_list, is_node = is.list) |> str()
pal::as_flat_list(nested_list_2, is_node = is.list) |> str()
}
\concept{list}
