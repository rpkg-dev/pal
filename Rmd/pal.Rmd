---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "Package"))
```

# R Markdown / Knitr

## Build `README.Rmd`

TODO: There's already the superior `devtools::build_readme()`, but it doesn't work with the `pal::gitlab_document` output format because
[it sets the `html_preview`](https://github.com/r-lib/devtools/blob/master/R/build-readme.R#L26-L27) option which is only found in
`rmarkdown::github_document`. -> file a [bug report](https://github.com/r-lib/devtools/issues?q=is%3Aissue+is%3Aopen+build) or even submit a PR to fix this!

```{r}
#' Build `README.Rmd`
#'
#' This function is an preliminary replacement for [devtools::build_readme()] that _works_ with the [`pal::gitlab_document`][pal::gitlab_document()] R Markdown
#' output format.
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#'
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md") {
  
  # knit Rmd to md
  knitr::knit(input = input,
              output = output,
              quiet = TRUE)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    quiet = TRUE)
}
```

## Output formats

These are [custom R Markdown output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html) which can be used in addition to the [default output formats](https://bookdown.org/yihui/rmarkdown/output-formats.html).

### `gitlab_document`

The equivalent in Pandoc command line options would be:

```sh
pandoc --from=markdown \
       --to=markdown-simple_tables-multiline_tables-grid_tables-fenced_code_attributes-inline_code_attributes-raw_attribute-smart \
       --atx-headers \
       --columns=9999
```

As soon as Pandoc [offers native support for GitLab Flavored Markdown](https://github.com/jgm/pandoc/issues/3977), switching to that will be the next step.

```{r}
#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [github_document][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It builds upon [md_document][rmarkdown::md_document()] and all of its parameters
#' can be specified except `variant`, `md_extensions` and `pandoc_args`.
#'
#' This output format basically ensures Pandoc is called with a custom set of options optimized for maximum compatibility with
#' [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' @param parse_emoji_markup Setting this to `TRUE` activates [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param smart_punctuation Setting this to `TRUE` activates [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (â€”), `--` to an en-dash (â€“), and `...` to ellipses (â€¦). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param ... Additional arguments passed to [rmarkdown::md_document()].
#'
#' @return R Markdown output format to pass to [rmarkdown::render()].
#' @export
#'
#' @examples
#' \dontrun{
#' rmarkdown::render("input.Rmd", gitlab_document())
#'
#' rmarkdown::render("input.Rmd", gitlab_document(parse_emoji_markup = TRUE,
#'                                                preserve_yaml = TRUE,
#'                                                extension = ".markdown"))
#' }
gitlab_document <- function(smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            ...) {
  pal::check_dots_named(...,
                        .function = rmarkdown::md_document,
                        .forbidden = c("variant", "md_extensions", "pandoc_args"))
  
  rmarkdown::md_document(variant = "markdown",
                         md_extensions = c("-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)],
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)]),
                         pandoc_args = c("--atx-headers",
                                         "--columns=9999"),
                         ...)
}
```

# R Packages

## Assert a package is installed

There is a similar (but way simpler) function
[`pkgsearch:::needs_packages()`](https://github.com/r-hub/pkgsearch/blob/9c0102e85929f25d23cb4f497ba4f01c3d3c0cd9/R/utils.R#L100-L127) and
[I've asked](https://github.com/r-hub/pkgsearch/issues/102) if there are any plans on standardizing this.

TODO:

- Incorporate code from FA.

- Add additional params `install_source`. Open question: How to best handle multiple pkgs at once if they don't share the install source? Just recycle
  `install_source`?

```{r}
#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together ðŸ¤²."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed!\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    
    invisible(pkg)
  }
}
```

## Test if packages are installed

This function [was originally proposed by Stack Overflow user Artem Klevtsov](https://stackoverflow.com/a/38082613/7196903).

```{r}
#' Test if packages are installed
#'
#' This function returns `TRUE` for each `pkg` that is installed on the current system and `FALSE` otherwise.
#'
#' In contrast to [base::require()], it checks if a package is installed without attaching its namespace if so.
#' 
#' In contrast to [rlang::is_installed()], it is fully vectorized, i.e. returns a (named) logical vector of the same length as `pkg`.
#' 
#' It is
#' [considerably faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the
#' commonly used `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_installed(pkg = "tidyverse")
is_installed <- function(pkg) {
  
  pkg %>%
    magrittr::set_names(., .) %>%
    purrr::map_lgl(~ nzchar(system.file(package = .x)))
}
```

## Test if a directory is an R package

```{r}
#' Test if a directory is an R package
#'
#' This is a simple convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that this function will only
#' return `TRUE` for the root of a package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an R package, `FALSE` otherwise.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  rprojroot::is_r_package$testfun[[1]](path = checkmate::assert_directory(path,
                                                                          access = "r"))
}
```

## List a subset of all installed packages

```{r}
#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case If `FALSE`, `pkg` is case-sensitive.
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#' @family rpkgs
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE) {
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = paste0(dplyr::if_else(ignore_case, "^(?i)", "^"),
                                                       paste0(pkg,
                                                              collapse = "|"),
                                                       "$")))
}
```

# Extending [ellipsis](https://ellipsis.r-lib.org/)

## Check that either dots are empty or all dot parameter names are a valid subset of a function's parameter names.

**Remarks:**

- Code to suggest proper dots params largely borrowed from `rlang::arg_match()`.

- Function has been proposed upstream in [PR #35](https://github.com/r-lib/ellipsis/pull/35).

  The function below offers some advantages (but probably needs more testing):
  
  - The name of the function the `...` will be passed on to is shown in the error message!
  - The error message adapts to the value of `.forbidden` -> should be less confusing for users! 

```{r}
#' Check that all [dot][base::dots()] parameter names are a valid subset of a function's parameter names.
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .forbidden Parameter names within `...` that should be treated as invalid.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of [rlang::abort()], [rlang::warn()], [rlang::inform()] or [rlang::signal()].
#' @export
#'
#' @examples
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' \dontrun{
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#' # `sapply_safe()` will throw an informative error message:
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#' }
check_dots_named <- function(...,
                             .function,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (length(list(...))) {
    
    # determine original function name the `...` will be passed on to
    fun_arg_name <- deparse1(substitute(.function))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fun_arg_name %in% parent_param_names) {
      fun_name <- as.character(parent_call[which(parent_param_names == fun_arg_name) + 1][[1]])
    } else {
      fun_name <- fun_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(checkmate::assert_function(.function))
    
    # check `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = assert_dot,
                values = dots_param_names,
                allowed_values = setdiff(dots_param_names,
                                         checkmate::assert_character(.forbidden,
                                                                     any.missing = FALSE,
                                                                     null.ok = TRUE)),
                fun_name = fun_name,
                action = .action)
    
  } else if (!checkmate::assert_flag(.empty_ok)) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = '`...` must be provided (!= NULL)!')
  }
}

assert_dot <- function(dot,
                       values,
                       allowed_values,
                       fun_name,
                       action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- glue::glue(dplyr::if_else(is_forbidden,
                                     "Forbidden",
                                     "Invalid"), " argument provided in `...`: `{dot}`\n",
                      dplyr::if_else(is_restricted,
                                     "Arguments allowed to pass on to ",
                                     "Valid arguments for "), "`{fun_name}()` include: ", pal::prose_ls(allowed_values, wrap = "`"))
    
    i_partial <- pmatch(dot, allowed_values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values)/nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- pal::prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}
```

# RSelenium

## ...

```{r}
# assert_package("RSelenium")
```

# Spoken language

## List items concatenated in prose-style (..., ... and ...)

```{r}
#' List items concatenated in prose-style (..., ... and ...)
#'
#' This function takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @export
#' @family spoken
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  if (length(x) < 2) {
    paste0(checkmate::assert_string(wrap), x, wrap)
    
  } else {
    paste0(x[-length(x)],
           collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, x[length(x)], wrap)
  }
}
```

# Miscellaneous

## Determine file path of executing script

This function is inspired by an [answer from Stack Overflow user Jerry T](https://stackoverflow.com/a/36777602/7196903).

TODO:

- Compare this function to [`rprojroot::thisfile()`](https://rprojroot.r-lib.org/reference/thisfile.html) and ideally retire it!

```{r}
#' Determine file path of executing script
#'
#' @return The file path to the executing script.
#' @export
script_path <- function() {
  
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  if (length(match) > 0L) {
    # Rscript
    return(normalizePath(sub(needle, "", cmd_args[match])))
    
  } else {
    if (!is.null(sys.frames()[[1L]][["ofile"]])) {
      # `source()`d via R console
      return(normalizePath(sys.frames()[[1L]][["ofile"]]))
      
    } else if (is_installed("rstudioapi")) {
      # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
      return(normalizePath(rstudioapi::getActiveDocumentContext()[["path"]]))

    } else rlang::abort("Couldn't determine script path!'")
  }
}
```

## Get the value from a DESCRIPTION file field, cleaned up and with fallback

```{r}
#' Get the value from a DESCRIPTION file field, cleaned up and with fallback
#'
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' desc_value(key = "Description",
#'            file = fs::path_package("pal"))
desc_value <- function(key,
                       file = ".") {
  
  desc::desc_get_field(key = key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = file) %>%
    stringr::str_squish()
}
```

## Print `x` as newline-separated character vector using `cat()`

```{r}
#' Print `x` as newline-separated character vector using [`cat()`][base::cat()].
#' 
#' This is simply a convenience wrapper around [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param x A vector to print.
#'
#' @inherit base::cat return
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
cat_lines <- function(x) {
  
  cat(as.character(unlist(x)),
      sep = "\n")
}
```

## Set an attribute

```{r}
#' Set an attribute
#'
#' This is simply a [pipeable](https://magrittr.tidyverse.org/articles/magrittr.html) version of [`attr(x, which) <- value`][base::attr()]. Unfortunately,
#' [rlang::set_attrs()], a more powerful attribute setter, has been marked deprecated.
#'
#' @param object The object for which an attribute is to be changed.
#' @param attribute The attribute to be changed. A character scalar.
#' @param value The new value for the attribute.
#'
#' @return The `object` with the updated attribute, invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' list(some = "element") %>%
#'   set_attribute(attribute = "custom_attribute",
#'                 value = "foo") %>%
#'   print()
set_attribute <- function(object,
                          attribute,
                          value) {
  attr(x = object,
       which = attribute) <- value
  
  invisible(object)
}
```
