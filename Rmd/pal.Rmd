---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "Package"))
```

## Functions

### Terminal styling based on ANSI escape sequences

Note that the colors defined here are intended for terminals capable to display [ANSI 24-bit colors](https://en.wikipedia.org/wiki/ANSI_escape_code#24-bit).

```{r}
# grey background (the `bg_grey()` missing from packages cli/crayon)
bg_grey <- cli::make_ansi_style("darkslategrey",
                                bg = TRUE,
                                colors = 2^24)

# dark background colors that are easy on the eyes
bg_red_dark <- cli::make_ansi_style("#330000",
                                    bg = TRUE,
                                    colors = 2^24)

bg_green_dark <- cli::make_ansi_style("#003300",
                                      bg = TRUE,
                                      colors = 2^24)
```

# Dataframes / Tibbles

## Apply `all()` rowwise to a data frame

```{r}
#' Apply `all()` rowwise to a data frame
#'
#' This is a convenience function that helps to combine multiple [`across()`][dplyr::across()] statements in dplyr's [`filter()`](dplyr::filter()) function.
#' See the examples.
#'
#' @param x A data frame or a tibble.
#'
#' @return A logical vector with the result of `all()` for each row of `x`.
#' @export
#'
#' @examples
#' # select all rows where either `vs` and `am` is greater zero *or* `gear` and `carb` is greater two
#' mtcars %>% dplyr::filter(rowwise_all(dplyr::across(one_of("vs", "am"), ~ .x > 0))
#'                          | rowwise_all(dplyr::across(one_of("gear", "carb"), ~ .x > 2)))
rowwise_all <- function(x) {
  purrr::pmap_lgl(x, all)
}
```

## Determine if row sum is greater than `zero`

-   There might be a better dplyr API introduced for this in the future, see [issue \#4770](https://github.com/tidyverse/dplyr/issues/4770).

-   Performance-wise it outperforms other known "any of" workarounds [by far](https://github.com/tidyverse/dplyr/issues/4770#issuecomment-692865538).

```{r}
#' Determine if row sum is greater than zero
#'
#' This is a convenience function intended to be used in combination with dplyr's [`across()`][dplyr::across()] to turn it from its default "all of" into an
#' "any of" behavior. It's identical to the `rowAny()` helper function suggested in dplyr's
#' [`"colwise"` vignette](https://dplyr.tidyverse.org/articles/colwise.html#how-do-you-convert-existing-code).
#'
#' @param x An array of two or more dimensions, containing numeric, complex, integer or logical values, or a numeric data frame. Row sums are always calculated
#'   over the first two dimensions, i.e. always the first two dimensions are regarded as rows.
#'
#' @return A logical vector. The `names` are taken from the original array.
#' @export
#'
#' @examples
#' # Find all rows where *any* numeric variable is exactly 1
#' mtcars %>% dplyr::filter(rowsum_gt_zero(dplyr::across(where(is.numeric), ~ .x == 1L)))
rowsum_gt_zero <- function(x) {
  rowSums(x) > 0L
}
```

# Lists

## Convert to a flat list

```{r}
#' Convert to a flat list
#'
#' @description
#' This function is similar to [unlist()], i.e. it _recursively_ flattens a list. But unlike `unlist()`, it
#'
#' - always returns a list, i.e. wraps `x` in a list if necessary, and will never remove the last list level. Thus it is
#'   [type-safe](https://en.wikipedia.org/wiki/Type_safety).
#'
#' - won't treat any of the list leafs specially (like `unlist()` does with factors). Thus leaf values will never be modified.
#'
#' - removes list names. `unlist()` concatenates nested names (separated by a dot).
#'
#' @param x `r pkgsnip::param_label("r_object")`
#' @param keep_attrs Keep [attributes][base::attr()] (and thereby retain list structure of custom objects). A logical scalar.
#' @param attrs_to_drop Attribute names which should never be kept. Only relevant if `keep_attrs = TRUE`. A character vector.
#'
#' @return A [list][base::list()].
#' @export
#'
#' @examples
#' nested_list <- list(1:3, list("foo", list("bar"))) %T>% str()
#' 
#' # unlike `unlist()` which also removes the last list tier in many cases ...
#' unlist("foobar")
#' unlist(nested_list) %>% str()
#' # ... this function always returns an (unnested) list
#' as_flat_list("foobar") %>% str()
#' as_flat_list(nested_list) %>% str()
#' 
#' nested_list <- list(list(factor("a"), factor("b")), factor("c")) %T>% str()
#' 
#' # unlike `unlist()` which combines factors ...
#' unlist(nested_list) %>% str()
#' # ... this function does not modify the list elements
#' as_flat_list(nested_list) %>% str()
#' 
#' nested_list <-
#'   list(c(list(1L), list(tibble::tibble(a = list(1.1, "2")))),
#'        list(tibble::as_tibble(mtcars[1:2, ]))) %T>%
#'   str()
#' nested_list_2 <- list(1:3, xfun::strict_list(list(list("buried deep")))) %T>% str()
#'
#' # by default, attributes and thus custom objects (except `xfun_strict_list`) are retained, i.e.
#' # not flattened ...
#' as_flat_list(nested_list) %>% str()
#' as_flat_list(nested_list_2) %>% str()
#' # ... but you can drop them and thereby flatten custom objects if needed ...
#' as_flat_list(nested_list, keep_attrs = FALSE) %>% str()
#' # ... or retain `xfun_strict_list`s, too
#' as_flat_list(nested_list_2, attrs_to_drop = NULL) %>% str()
as_flat_list <- function(x,
                         keep_attrs = TRUE,
                         attrs_to_drop = "xfun_strict_list") {
  
  regard_attrs <- checkmate::assert_flag(keep_attrs) & length(setdiff(attributes(x),
                                                                      checkmate::assert_character(attrs_to_drop,
                                                                                                  any.missing = FALSE,
                                                                                                  null.ok = TRUE)))
  depth <- purrr::vec_depth(x)
  
  # wrap `x` in a list if it's not
  if (regard_attrs | depth < 2L) {
    result <- list(x)
    
    # return `x` as-is if it is an unnested list
  } else if (depth < 3L) {
    result <- x
    
    # flatten the two last list levels (keeping attributes if requested)
  } else if (depth < 4L) {
    result <- x %>% purrr::when(keep_attrs ~ rm_list_level(.,
                                                           attrs_to_drop = attrs_to_drop),
                                ~ purrr::flatten(.))
  } else {
    
    # recursively feed the elements of `x` to this function and flatten the two last list levels (keeping attributes if requested)
    result <-
      x %>%
      purrr::map(.f = as_flat_list,
                 keep_attrs = keep_attrs,
                 attrs_to_drop = attrs_to_drop) %>%
      purrr::when(keep_attrs ~ rm_list_level(.,
                                             attrs_to_drop = attrs_to_drop),
                  ~ purrr::flatten(.))
  }
  
  result
}

rm_list_level <- function(x,
                          attrs_to_drop = "xfun_strict_list") {
  
  result <- list()
  
  for (i in seq_along(checkmate::assert_list(x))) {
    
    regard_attrs <- length(setdiff(attributes(x[[i]]), attrs_to_drop))
    
    if (!regard_attrs & purrr::vec_depth(x[[i]]) > 1L) {
      result %<>% c(x[[i]])
    } else {
      result %<>% c(list(x[[i]]))
    }
  }
  
  result
}
```

# Pandoc / Markdown

## Convert dataframe/tibble to Markdown pipe table

```{r}
#' Convert dataframe/tibble to Markdown pipe table
#'
#' This is a convenience wrapper around [`knitr::kable(format = "pipe")`][knitr::kable()] to create a
#' [Markdown pipe table](https://pandoc.org/MANUAL.html#extension-pipe_tables).
#' 
#' # Create tables dynamically in roxygen2 documentation
#' 
#' This function can be useful to create tables inside [roxygen2][roxygen2::roxygen2] documentation programmatically from data using
#' [dynamic R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1).
#' 
#' The inline code
#' 
#' `` `r mtcars %>% head() %>% pipe_table()` ``
#'
#' should produce the following table in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' `r mtcars %>% head() %>% pipe_table()`
#'
#' @inherit knitr::kable details
#'
#' @param x The dataframe/tibble/matrix to be converted to a pipe table.
#' @param incl_rownames Whether to include row names or not. A logical scalar or `NULL`. If `NULL`, row names are included if `rownames(x)` is neither `NULL`
#'   nor identical to `seq_len(nrow(x))`.
#' @param strong_colnames Highlight column names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param strong_rownames Highlight row names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param align Column alignment. Either `NULL` for auto-alignment or a character vector consisting of `'l'` (left), `'c'` (center) and/or `'r'` (right). If
#'   `align = NULL`, numeric columns are right-aligned, and other columns are left-aligned. If `length(align) == 1L`, the string will be expanded to a vector
#'   of individual letters, e.g. `'clc'` becomes `c('c', 'l', 'c')`.
#' @param format_args A list of arguments to be passed to [format()] to format table values, e.g. `list(big.mark = ',')`.
#' @inheritParams knitr::kable
#'
#' @return A character vector.
#' @export
#'
#' @examples
#' mtcars %>% head() %>% pipe_table() %>% cat_lines()
pipe_table <- function(x,
                       incl_rownames = NULL,
                       strong_colnames = TRUE,
                       strong_rownames = TRUE,
                       align = NULL,
                       label = NULL,
                       digits = getOption("digits"),
                       format_args = list()) {
  
  assert_pkg("knitr")
  checkmate::assert_flag(incl_rownames,
                         null.ok = TRUE)
  
  # format rownames <strong> if requested and sensible
  if ((isTRUE(incl_rownames) && !is.null(rownames(x))) ||
      (is.null(incl_rownames) && !identical(rownames(x), as.character(seq_len(nrow(x)))))) {
    
    rownames(x) %<>% paste0("**", ., "**")
  }
  
  kable_args <-
    alist(x = x,
          format = "pipe",
          digits = digits,
          row.names = ifelse(is.null(incl_rownames),
                             NA,
                             incl_rownames),
          col.names = colnames(x) %>% purrr::when(checkmate::assert_flag(strong_colnames) ~ paste0("**", ., "**"),
                                                  ~ .),
          label = label,
          format.args = format_args) %>%
    purrr::when(!is.null(align) ~ c(., alist(align = align)),
                ~ .)
  
  do.call(what = knitr::kable,
          args = kable_args)
}
```

# R Markdown / Knitr

## Build `README.Rmd`

```{r}
#' Build `README.Rmd`
#'
#' This function is a simpler, but considerably faster alternative to [devtools::build_readme()] since it doesn't install your package in a temporary library
#' before building the `README.Rmd`. This has the pleasant side effect that, other than the latter function, it also works for `.Rmd` files which aren't part
#' of an R package.
#' 
#' Note that for public package repositories it's recommended to use `devtools::build_readme()` since it ensures the `README.Rmd` can be built reproducibly,
#' which means all the objects and files it references must be accessible from the repository.
#' 
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#' @inheritParams knitr::knit
#' @family rmd_knitr
#'
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md",
                         envir = parent.frame()) {
  
  assert_pkg("knitr")
  assert_pkg("rmarkdown")
  
  if (is_pkg_dir()) {
    
    assert_pkg("desc")
    
    assign(x = "pkg_metadata",
           value = desc::desc_get(desc::desc_fields()),
           envir = envir)
  }
  
  # knit Rmd to md
  knitr::knit(input = checkmate::assert_file(input,
                                             access = "r"),
              output = checkmate::assert_path_for_output(output,
                                                         overwrite = TRUE),
              quiet = TRUE,
              envir = envir)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    output_file = output,
                    quiet = TRUE,
                    envir = envir)
}
```

## Output formats

These are [custom R Markdown output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html) which can be used in addition to the [default output
formats](https://bookdown.org/yihui/rmarkdown/output-formats.html).

### `gitlab_document`

TODO:

-   Find out why param [`df_print`](https://bookdown.org/yihui/rmarkdown/html-document.html#data-frame-printing) has no effect (seems to always fall back to
    `"default"`; the same happens for `rmarkdown::github_document()`). Is this a bug?\`

    Setting `df_print = "kable"` should actually produce a [pipe table](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html#kable-formats)...

-   Finish the damn tocr package and switch to it for TOC generation instead of Pandoc's built-in but very limited `--table-of-contents` option!

-   As soon as Pandoc [offers native support for GitLab Flavored Markdown](https://github.com/jgm/pandoc/issues/3977), switching to that will be the next step.

```{r}
#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [`github_document`][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It basically ensures Pandoc is called with a custom set of options optimized for 
#' maximum compatibility with [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' ## Caveats regarding GitLab-Flavored-Markdown-specific features
#'
#' GitLab Flavored Markdown extends the [CommonMark](https://spec.commonmark.org/current/) Markdown specification with a bunch of
#' [special features](https://gitlab.com/help/user/markdown.md#gfm-extends-standard-markdown). To be able to properly make use of them, observe the following
#' points:
#'
#' - For [inline diffs](https://gitlab.com/help/user/markdown.md#inline-diff), only use curly braces (`{}`), not square brackets (`[]`). The latter will be
#'   escaped by Pandoc during conversion and thus not recognized by GitLab as starting/ending an inline diff.
#'
#' - You have to set `smart_punctuation = FALSE` in order to leave certain
#'   [special GitLab references](https://gitlab.com/help/user/markdown.md#special-gitlab-references) (like commit range comparisons) untouched for GitLab to
#'   interpret them correctly.
#'
#'   All the special GitLab references for snippets and labels that start with a tilde (`~`) or a dollar sign (`$`) won't work because these characters will be
#'   escaped by Pandoc during conversion.
#'
#' - The `[[_TOC_]]` tag to let GitLab [generate a table of contents](https://gitlab.com/help/user/markdown.md#table-of-contents) won't work because it will be
#'   escaped by Pandoc during conversion. You can let Pandoc generate the TOC instead by setting `toc = TRUE`.
#'
#' - [Multiline blockquotes](https://gitlab.com/help/user/markdown.md#multiline-blockquote) won't work because the fence delimiters `>>>` will be escaped by
#'   Pandoc during conversion.
#'
#' @param smart_punctuation Enable [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (—), `--` to an en-dash (–), and `...` to ellipses (…). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param parse_emoji_markup Enable [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param toc Include a table of contents (TOC) [automatically generated by Pandoc](https://pandoc.org/MANUAL.html#option--toc). Note that the TOC will be
#'   placed _before_ the README's body, meaning also _before_ the first Markdown header.
#' @param autolink_bare_uris Enable the [`autolink_bare_uris` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-autolink_bare_uris) which
#'   makes all absolute URIs into links, even when not surrounded by pointy braces `<...>`.
#' @param tex_math_single_backslash Enable the
#'   [`tex_math_single_backslash` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-tex_math_single_backslash) which causes anything between
#'   `\(` and `\)` to be interpreted as inline TeX math, and anything between `\[` and `\]` to be interpreted as display TeX math. Note: a drawback of this
#'   extension is that it precludes escaping `(` and `[`.
#' @inheritParams rmarkdown::output_format
#' @inheritParams rmarkdown::md_document
#'
#' @return R Markdown output format to pass to [rmarkdown::render()].
#' @family rmd_knitr
#' @export
#'
#' @examples
#' \donttest{
#' tmp_file <- fs::file_temp()
#' download.file(url = "https://gitlab.com/salim_b/r/pkgs/pal/-/raw/master/Rmd/pal.Rmd",
#'               destfile = tmp_file)
#'
#' rmarkdown::render(input = tmp_file,
#'                   output_format = pal::gitlab_document())}
gitlab_document <- function(#add_toc = FALSE,
                            smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            df_print = "kable",
                            toc = FALSE,
                            toc_depth = 6L,
                            fig_width = 7L,
                            fig_height = 5L,
                            dev = "png",
                            preserve_yaml = FALSE,
                            autolink_bare_uris = FALSE,
                            tex_math_single_backslash = FALSE) {
  assert_pkg("rmarkdown")
  
  rmarkdown::output_format(
    knitr = rmarkdown::knitr_options_html(fig_width = fig_width,
                                          fig_height = fig_height,
                                          fig_retina = NULL,
                                          keep_md = FALSE,
                                          dev = dev),
    pandoc = rmarkdown::pandoc_options(to =
                                         c("markdown",
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)],
                                           "-smart",
                                           "-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-pandoc_title_block",
                                           "-yaml_metadata_block"[!checkmate::assert_flag(preserve_yaml)]) %>%
                                         paste0(collapse = ""),
                                       from =
                                         c("markdown",
                                           "+autolink_bare_uris"[checkmate::assert_flag(autolink_bare_uris)],
                                           "+tex_math_single_backslash"[checkmate::assert_flag(tex_math_single_backslash)],
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)]) %>%
                                         paste0(collapse = ""),
                                       args = c("--atx-headers",
                                                "--columns=9999",
                                                "--standalone",
                                                "--table-of-contents"[checkmate::assert_flag(toc)],
                                                paste0("--toc-depth=", checkmate::assert_int(toc_depth,
                                                                                             lower = 1L,
                                                                                             upper = 6L))[checkmate::assert_flag(toc)])),
    df_print = df_print,
    pre_knit = NULL,
    post_knit = NULL,
    pre_processor = NULL,
    intermediates_generator = NULL,
    post_processor = NULL,
    # on_exit = purrr::when(checkmate::assert_flag(add_toc) ~ tocr::add_toc,
    #                       ~ NULL),
    base_format = NULL
  )
}
```

# R Packages

## Assert a package is installed

There is a similar (but way simpler) function
[`pkgsearch:::needs_packages()`](https://github.com/r-hub/pkgsearch/blob/9c0102e85929f25d23cb4f497ba4f01c3d3c0cd9/R/utils.R#L100-L127) and [I've
asked](https://github.com/r-hub/pkgsearch/issues/102) if there are any plans on standardizing this.

TODO:

-   Incorporate code from FA.

-   Add additional params `install_source`. Open question: How to best handle multiple pkgs at once if they don't share the install source? Just recycle
    `install_source`?

```{r}
#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together 🤲."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_pkg_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed!\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    
    invisible(pkg)
  }
}
```

## Get the value from a DESCRIPTION file field, cleaned up and with fallback

TODO: Make PR proposing new `trim` param.

```{r}
#' Get the value from a DESCRIPTION file field, cleaned up and with fallback
#'
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' desc_value(key = "Description",
#'            file = fs::path_package("pal"))
desc_value <- function(key,
                       file = ".") {
  
  assert_pkg("desc")
  
  desc::desc_get_field(key = key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = file) %>%
    stringr::str_squish()
}
```

## Test if packages are installed

This function [was originally proposed by Stack Overflow user Artem Klevtsov](https://stackoverflow.com/a/38082613/7196903).

```{r}
#' Test if packages are installed
#'
#' This function returns `TRUE` or `FALSE` for each `pkg`, depending on whether the `pkg` is installed on the current system or not.
#'
#' In contrast to [base::require()], it checks if the packages are installed without attaching their namespaces if so.
#' 
#' In contrast to [rlang::is_installed()], it doesn't load the packages if they're installed and it is fully vectorized, i.e. returns a (named) logical vector
#' of the same length as `pkg`.
#' 
#' It is
#' [considerably faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the
#' commonly used `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names. A character vector.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_installed(pkg = "tidyverse")
is_pkg_installed <- function(pkg) {
  
  purrr::map_lgl(magrittr::set_names(pkg, pkg),
                 ~ nzchar(system.file(package = .x)))
}
```

## Test if a directory is an R package

```{r}
#' Test if a directory is an R package
#'
#' This is a simple convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that this function will only
#' return `TRUE` for the root of a package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an R package, `FALSE` otherwise.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  assert_pkg("rprojroot")
  
  rprojroot::is_r_package$testfun[[1L]](path = checkmate::assert_directory(path,
                                                                           access = "r"))
}
```

## List a subset of all installed packages

```{r}
#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case Do not distinguish between upper and lower case letters in `pkg`. If `FALSE`, `pkg` is treated case-sensitive.
#' @param as_regex Interpret `pkg` as regular expression(s). If `FALSE`, `pkg` is interpreted literally.
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#' @family rpkgs
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE,
                   as_regex = FALSE) {
  
  regex <-
    checkmate::assert_character(pkg,
                                any.missing = FALSE,
                                min.chars = 1L) %>%
    purrr::when(checkmate::assert_flag(as_regex) ~ .,
                ~ paste0("\\Q", ., "\\E")) %>%
    fuse_regex() %>%
    purrr::when(checkmate::assert_flag(ignore_case) ~ paste0("^(?i)", .),
                ~ paste0("^", .)) %>%
    paste0("$")
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = regex))
}
```

## Load R script(s) as package

TODO: Create a function based upon [this StackOverflow answer](https://stackoverflow.com/a/15794201/7196903).

# Statistical computing

## Statistical mode

-   Solution borrowed from [hugovdberg](https://stackoverflow.com/a/38097776/7196903) and others.

```{r}
#' Statistical mode
#'
#' Compute the [statistical mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of a set of values. The mode is defined as the most frequent value, i.e. the
#' value that is most likely to be sampled.
#'
#' See the package [modeest](https://cran.r-project.org/package=modeest) for more powerful mode estimation functions.
#'
#' @param x An \R object.
#' @param type What the function should calculate.
#'   - `"one"`: Return _the_ mode of `x`. If multiple modes or no mode at all exists, `NA` is returned.
#'   - `"all"`: Return _all_ modes of `x`. If none exists (e.g. because all values of `x` are distinct), `NA` is returned.
#'   - `"n"`: Return the number of modes of `x`.
#' @param na_rm Ignore missing values in `x`. A logical scalar.
#'
#' @return If `type = "n"`, the number of modes in `x` (an integer). Otherwise, the mode(s) of `x` or `NA` if none exist(s) (same type as `x`).
#' @export
#'
#' @examples
#' stat_mode(c(rep(3L, times = 3), 1:9))
#' stat_mode(c(1.5, 4, 9.9))
#' 
#' # if no mode exists, `NA` (of the same type as x) is returned
#' stat_mode(letters)
#' stat_mode(c(letters, "a"))
#' 
#' # if multiple modes exist, `NA` is returned by default
#' stat_mode(c(letters, "a", "b"))
#' # set `type = "all"` to return all modes instead
#' stat_mode(c(letters, "a", "b"),
#'           type = "all")
#' 
#' # `NA` is treated as any other value by default
#' stat_mode(c(letters, "a", NA_character_, NA_character_),
#'           type = "all")
#' # set `rm_na = TRUE` to ignore `NA` values
#' stat_mode(c(letters, "a", NA_character_, NA_character_),
#'           type = "all",
#'           na_rm = TRUE)
stat_mode <- function(x,
                      type = c("one", "all", "n"),
                      na_rm = FALSE) {
  x <- unlist(x)
  type <- rlang::arg_match(type)
  if (checkmate::assert_flag(na_rm)) x <- x[!is.na(x)]
  
  # get unique values
  u_x <- unique(x)
  n_u_x <- length(u_x)
  
  # get frequencies of all unique values
  frequencies <- tabulate(match(x, u_x))
  modes <- frequencies == max(frequencies)
  
  # determine number of modes
  n_modes <- sum(modes) %>% dplyr::if_else(. == n_u_x, 0L, .)
  
  type %>% purrr::when(
    # return the number of modes if requested
    . == "n" ~
      n_modes,
    # or return mode(s) if requested and existing
    (. == "one" & n_modes == 1L) | (. == "all" & n_modes > 0L) ~
      u_x[which(modes)],
    # else return `NA` (of the same type as `x`)
    ~ x[NA][1L]
  )
}
```

# Strings

## Convert to a character vector

```{r}
#' Convert to a character vector
#'
#' This function _recursively_ applies [as.character()] to its inputs.
#'
#' @param ... The \R objects to be converted to a character vector. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' to_convert <-
#'   list(tibble::tibble(a = 1:3), "A", factor("wonderful"), xfun::strict_list("day")) %T>%
#'   print()
#'
#' as.character(to_convert)
#' as_chr(!!!to_convert)
as_chr <- function(...) {
  
  rlang::list2(...) %>%
    purrr::map(~ {
      
      if (purrr::vec_depth(.x) == 1L) {
        
        as.character(.x)
        
      } else {
        
        .x %>%
          purrr::map(as_chr) %>%
          purrr::flatten_chr()
      }
    }) %>%
    purrr::flatten_chr()
}
```

## Convert to a character scalar (aka string)

```{r}
#' Convert to a character scalar (aka string)
#'
#' This function is like [`paste0(..., collapse = "")`][paste0()], but _recursively_ converts its inputs to type character.
#'
#' @param ... The \R objects to be assembled to a single string. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param sep The separator to delimit `...`. Defaults to none (`""`).
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' input <-
#'   sample.int(n = 5,
#'              size = 3) %>%
#'   paste0(", ") %>%
#'   purrr::map(rep,
#'              times = 20) %>%
#'   list(c("This is a glut of ", "meaningless numbers: "), .)
#'
#' # while this just converts `input` in a lazy way ...
#' paste0(input,
#'        collapse = "")
#'
#' # ... this one works harder
#' as_string(input)
as_string <- function(...,
                      sep = "") {
  
  as_chr(...) %>% purrr::when(length(.) > 0L ~ paste0(., collapse = sep),
                              ~ .)
}
```

## Escape line feeds / newlines

```{r}
#' Escape line feeds / newlines
#'
#' This function escapes the [POSIX-standard newline control character `LF`](https://en.wikipedia.org/wiki/Newline) (aka `\n`) which is the standard on
#' Unix/Linux and recent versions of macOS. Set `escape_cr = TRUE` in order to also escape the carriage return character `CR` (aka `\r`) commonly used on
#' Microsoft Windows.
#'
#' @param x A character vector.
#' @param escape_cr Whether or not to also escape the carriage return character `CR` (aka `\r`). A logical scalar.
#'
#' @return A character vector of the same length as `x`.
#' @family string
#' @export
#'
#' @examples
#' # read in and print package description as-is
#' text <-
#'   fs::path_package(package = "pal",
#'                    "DESCRIPTION") %>%
#'   readr::read_file() %T>%
#'   cat_lines()
#'
#' # escape newlines and print again
#' escape_lf(text) %>% cat_lines()
escape_lf <- function(x,
                      escape_cr = FALSE) {
  
  checkmate::assert_character(x,
                              null.ok = TRUE) %>%
  stringr::str_replace_all(pattern = "\\n",
                           replacement = "\\\\n") %>%
    purrr::when(checkmate::assert_flag(escape_cr) ~ stringr::str_replace_all(string = .,
                                                                             pattern = "\\r",
                                                                             replacement = "\\\\r"),
                ~ .)
}
```

## Fuse regex

```{r}
#' Fuse regular expressions
#'
#' Combine a vector or list of regular expressions to a single one (by logical OR).
#'
#' @param ... The regular expressions. All elements will be converted to type character before fusing.
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' # perform some (nonsense) Jane Austen text extraction
#' regex <- c("My dear Jane",
#'            "make haste, ",
#'            "(?i)\\bevil")
#'
#' stringr::str_subset(string = janeaustenr::prideprejudice,
#'                     pattern = fuse_regex(regex))}
fuse_regex <- function(...) {
  
  paste0("(", as_string(..., sep = "|"), ")")
}
```

## Get column names of a delimiter-separated string

```{r}
#' Get column names of a delimiter-separated string
#'
#' This function returns the column names of a string in a [delimiter-separated-value](https://en.wikipedia.org/wiki/Delimiter-separated_values) format like
#' [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) or [TSV](https://en.wikipedia.org/wiki/Tab-separated_values).
#'
#' @param x The delimiter-separated string. A character scalar.
#' @param delim Single character used to separate fields within `x`.
#' @param quote Single character used to quote strings within `x`. Set to `NULL` for none.
#'
#' @return A character vector of column names.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' httr::GET("https://raw.githubusercontent.com/tidyverse/readr/master/inst/extdata/mtcars.csv") %>%
#'   httr::content(as = "text") %>%
#'   pal::dsv_colnames()}
dsv_colnames <- function(x,
                         delim = ",",
                         quote = "\"") {
  x %>%
    regexpr(pattern = "[\r\n]") %>%
    magrittr::subtract(1L) %>%
    substr(x = x,
           start = 1L) %>%
    stringr::str_split(pattern = checkmate::assert_string(delim,
                                                          min.chars = 1L,
                                                          pattern = "^.$")) %>%
    dplyr::first() %>%
    stringr::str_remove_all(pattern = glue::glue("^", checkmate::assert_string(quote,
                                                                                null.ok = TRUE,
                                                                                pattern = "^.$"),
                                                 "|{quote}$"))
}
```

## List items concatenated in prose-style (..., ... and ...)

```{r}
#' List items concatenated in prose-style (..., ... and ...)
#'
#' This function takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  
  result <- as_chr(x)
  length_result <- length(result)
  
  if (length_result == 1L) {
    
    result <- paste0(checkmate::assert_string(wrap), result, wrap)
    
  } else if (length_result > 1L) {
    
    result <-
      paste0(result[-length_result],
             collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, result[length_result], wrap)
  }
  
  result
}
```

## Print `x` as newline-separated character vector using `cat()`

```{r}
#' Print `x` as newline-separated character vector using `cat()`.
#' 
#' This is a convenience wrapper around [as_chr()] and [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param ... The \R object(s) to print. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @inherit base::cat return
#' @family string
#' @seealso [xfun::raw_string()], [xfun::file_string()]
#' @export
#'
#' @examples
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
cat_lines <- function(...) {
  
  cat(as_chr(...),
      sep = "\n")
}
```

## Replace matched patterns in a string *verbosely*

```{r}
#' Replace matched patterns in a string _verbosely_
#'
#' Apply a series of regular-expression-replacement pairs to a string. All performed replacements are displayed on the console by default.
#'
#' This function provides a subset of [stringr::str_replace_all()]'s functionality. If you don't need the visual console output, it's recommended to directly
#' resort to that function.
#'
#' @param pattern A named character vector with patterns as names and replacements as values (`c(pattern1 = replacement1)`). Patterns are interpreted as
#'   regular expressions as described in [stringi::stringi-search-regex()]. Replacements are interpreted as-is, except that references of the form `\1`, `\2`,
#'   etc. will be replaced with the contents of the respective matched group (created in patterns using `()`). Pattern-replacement pairs are processed in the
#'   order given, meaning that first listed pairs are applied before later listed ones.
#' @param verbose Whether to display replacements on the console.
#' @param n_context_chrs The (maximum) number of characters displayed around the actual `string` and its replacement. The number refers to a single side of
#'   `string`/replacement, so the total number of context characters is at the maximum `2 * n_context_chrs`. Only relevant if `verbose = TRUE`.
#' @inheritParams stringr::str_replace_all
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' "Make love, not war" %>% str_replace_verbose(pattern = c("love" = "hummus",
#'                                                          "war" = "walls"))
str_replace_verbose <- function(string,
                                pattern,
                                verbose = TRUE,
                                n_context_chrs = 20L) {
  
  purrr::map_chr(.x = string,
                 .f = str_replace_verbose_single,
                 pattern = pattern,
                 verbose = verbose,
                 n_context_chrs = n_context_chrs)
}

# non-vectorized helper
str_replace_verbose_single <- function(string,
                                       pattern,
                                       verbose,
                                       n_context_chrs) {
  
  checkmate::assert_string(string)
  checkmate::assert_flag(verbose)
  n_context_chrs <- checkmate::assert_count(n_context_chrs,
                                            coerce = TRUE)
  checkmate::assert_character(pattern,
                              any.missing = FALSE)
  all_named <- checkmate::test_named(pattern)
  if (!all_named) rlang::abort("All elements of `pattern` must be named (names are patterns, values are replacements).")
  
  # print replacement info for humans
  if (verbose) {
    
    cli_id_ul <- cli::cli_ul(.auto_close = FALSE)
    
    # we have to process each pattern-replacement pair one-by-one because other than `stringr::str_replace_all()`, `stringr::str_locate_all()` doesn't support
    # the pair-wise spec
    for (i in seq_along(pattern)) {
      
      hit <-
        string %>%
        stringr::str_locate_all(pattern = names(pattern[i])) %>%
        dplyr::first()
      
      purrr::walk2(.x = hit[, "start"],
                   .y = hit[, "end"],
                   .f = function(start, end) {
                     
                     # reduce to `string` excerpt of +/- 20 chars
                     ## determine if we prune
                     prune_start <- (start - n_context_chrs) > 1L 
                     prune_end <- (end + n_context_chrs) < nchar(string)
                     
                     ## extract excerpt
                     ### begin (part before `pattern`)
                     excerpt_begin <- string %>% stringr::str_sub(start = dplyr::if_else(prune_start,
                                                                                         start - n_context_chrs,
                                                                                         1L),
                                                                  end = start - 1L)
                     ### the `pattern` as-is, i.e. without regex syntax
                     pattern_asis <- string %>% stringr::str_sub(start = start,
                                                                 end = end)
                     
                     ### end (part after `pattern`)
                     excerpt_end <- string %>% stringr::str_sub(start = end + 1L,
                                                                end = dplyr::if_else(prune_end,
                                                                                     end + n_context_chrs,
                                                                                     -1L))
                     
                     # replace excerpt start/end with ellipsis dots (pruned to whole words if appropriate)
                     if (prune_start) excerpt_begin %<>% paste0("\u2026", .)
                     
                     if (prune_end) excerpt_end %<>% paste0("\u2026")
                     
                     # escape newlines (only relevant if we don't `process_line_by_line` and/or patterns/replacements contain newlines)
                     excerpt_begin %<>% escape_lf()
                     pattern %<>% escape_lf()
                     names(pattern) %<>% escape_lf()
                     excerpt_end %<>% escape_lf()
                     
                     # print info
                     cli_id_li <- cli::cli_li(as_string(cli::col_red("-"), " ", cli::bg_black(excerpt_begin), bg_red_dark(pattern_asis),
                                                        cli::bg_black(excerpt_end)),
                                              .auto_close = FALSE)
                     cli::cli_text(as_string(cli::col_green("+"), " ", cli::bg_black(excerpt_begin), bg_green_dark(pattern[i]), cli::bg_black(excerpt_end)))
                     cli::cli_end(id = cli_id_li)
                   })
      
      string %<>% stringr::str_replace_all(pattern = pattern[i])
    }
    
    cli::cli_end(id = cli_id_ul)
    return(string)
    
    # non-verbose shortcut
  } else {
    
    return(stringr::str_replace_all(string = string,
                                    pattern = pattern))
  }
}
```

## Replace matched patterns in text files

```{r}
#' Replace matched patterns in text files
#'
#' Apply pattern-based string replacement to multiple files at once. A series of regular-expression-replacement pairs can be provided and all performed
#' replacements can be displayed on the console (`verbose = TRUE`), optionally without actually changing any file content (`dry_run = TRUE`).
#'
#' @param path Paths to the text files. A character vector.
#' @param process_line_by_line Whether each line in a file should be treated as a separate string or the whole file as one single string. While the latter is 
#'   more performant, you probably want the former if you're using `"^"` or `"$"` in your `pattern`s.
#' @param show_rel_path Whether to display file `path`s as relative from the current working directory. If `FALSE`, absolute paths are displayed. Only relevant
#'   if `verbose = TRUE`.
#' @param dry_run Show replacements on the console only, without actually modifiying any files. Implies `verbose = TRUE`.
#' @inheritParams str_replace_verbose
#'
#' @return `path` invisibly.
#' @family string
#' @export
str_replace_file <- function(path,
                             pattern,
                             process_line_by_line = FALSE,
                             verbose = TRUE,
                             n_context_chrs = 20L,
                             show_rel_path = FALSE,
                             dry_run = FALSE) {
  
  assert_pkg("cli")
  checkmate::assert_file(path,
                         access = "r")
  checkmate::assert_flag(process_line_by_line)
  checkmate::assert_flag(verbose)
  checkmate::assert_flag(show_rel_path)
  checkmate::assert_flag(dry_run)
  
  if (dry_run && !verbose) {
    rlang::abort("Setting `dry_run = TRUE` and `verbose = FALSE` at the same time is pointless.")
  }
  
  purrr::walk(.x = path,
              .f = function(path) {
                
                # print file progress info
                if (verbose) {
                  
                  path_show <- dplyr::if_else(show_rel_path,
                                              fs::path_rel(path),
                                              fs::path_abs(path))
                  
                  cli::cli_alert_info(text = "Processing file {.file {path_show}}\u2026")
                }
                
                # perform replacement
                if (process_line_by_line) {
                  result <- readr::read_lines(path)
                } else {
                  result <- readr::read_file(path)
                }
                
                result %<>% str_replace_verbose(pattern = pattern,
                                                verbose = verbose,
                                                n_context_chrs = n_context_chrs)
                
                if (!dry_run) {
                  
                  readr::write_lines(x = result,
                                     path = path,
                                     na = NA_character_)
                }
              })
  
  invisible(path)
}
```

# System interaction

## Check if CLI tool is available on the system

```{r}
#' Check if CLI tool is available on the system
#'
#' This function checks if a CLI tool is found on the system's [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable)) and optionally returns the executable's
#' filesystem path.
#'
#' @param cmd The system command to invoke the CLI tool. A character scalar.
#' @param get_cmd_path Return the filesystem path to the CLI tool. If `FALSE` (the default), a boolean is returned indicating if the CLI tool is found on the
#'   system or not.
#' @param force_which If set to `TRUE`, [Sys.which()], which relies on the system command `which`, will be used instead of `command -v` to determine the
#'   availability of `cmd` on Unix-like systems. On Windows, `Sys.which()` is used in any case. `command -v` is
#'   [generally recommended for bourne-like shells](https://unix.stackexchange.com/q/85249/201803) and therefore is the default on Linux, macOS and other
#'   [Unixes](https://en.wikipedia.org/wiki/Unix-like).
#'
#' @return A logical scalar if `get_cmd_path = FALSE`, otherwise the filesystem [path][fs::path] to the `cmd` executable.
#' @family sys
#' @export
#'
#' @examples
#' check_cli("Rscript")
#'
#' cmd <- ifelse(xfun::is_windows(), "pandoc.exe", "pandoc")
#' check_cli(cmd, get_cmd_path = TRUE)
check_cli <- function(cmd,
                      get_cmd_path = FALSE,
                      force_which = FALSE) {
  
  # check deps and argument validity
  assert_pkg("fs")
  checkmate::assert_string(cmd)
  checkmate::assert_flag(get_cmd_path)
  checkmate::assert_flag(force_which)
  
  if (force_which | !xfun::is_unix()) {
    
    Sys.which(names = cmd) %>%
      as.character() %>%
      purrr::when(. == "" ~ character(0L),
                  ~ .) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  length(.) == 0L ~ FALSE,
                  ~ TRUE)
    
  } else {
    
    # define "defused" warning/error handler
    defuse <- function(e) if (get_cmd_path) character(0L) else FALSE
    
    rlang::with_handlers(system2(command = "command",
                                 args = c("-v",
                                          cmd),
                                 stdout = get_cmd_path,
                                 stderr = get_cmd_path),
                         warning = defuse,
                         error = defuse) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  isFALSE(.) ~ .,
                  ~ TRUE)
  }
}
```

## Determine file path of executing script

This function is inspired by an [answer from Stack Overflow user Jerry T](https://stackoverflow.com/a/36777602/7196903).

```{r}
#' Determine file path of executing script
#'
#' @return The file path to the executing script.
#' @family sys
#' @export
path_script <- function() {
  
  assert_pkg("rprojroot")
  assert_pkg("rstudioapi")
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  # Rscript
  if (length(match) > 0L) {
    
    return(normalizePath(sub(needle, "", cmd_args[match])))
  }
  
  # `source()`d via R console
  if (!is.null(sys.frames()[[1L]][["ofile"]])) {
    
    return(normalizePath(sys.frames()[[1L]][["ofile"]]))
    
    # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
  } else if (!is.null(rprojroot::thisfile())) {
    
    return(rprojroot::thisfile())
    
  } else {
    
    path <- normalizePath(rstudioapi::getActiveDocumentContext()[["path"]])
    
    if (path != "") {
      return(path)
    }
  }
  
  rlang::abort("Couldn't determine script path!'")
}
```

## Run CLI tool and get output as character vector

```{r}
run_cli <- function(cmd,
                    ...) {
  
  
}
```

# Miscellaneous

## Test if an HTTP request is successful

A shorter way to define a very similar function would be:

``` {.r}
is_http_success <- purrr::possibly(~ !httr::http_error(.x),
                                   otherwise = FALSE)
```

TODO: Figure out if it's really sensible to handle/catch interrupts.

```{r}
#' Test if an HTTP request is successful
#'
#' @description
#' This is a convenience wrapper around [`!httr::http_error()`][httr::http_error()] that returns
#'
#' - `TRUE` if the specified `url` could be resolved _and_ a [`HEAD`](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) request could
#'   be [successfully completed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes), or
#'
#' - `FALSE` in any other case.
#'
#' @details
#' This function is similar to [RCurl::url.exists()], i.e. it only retrieves the header, no body, but is based on [httr][httr::httr-package] which in turn is
#' based on [curl](https://jeroen.cran.dev/curl/).
#'
#' @param url The HTTP protocol address. The scheme is optional, so both `"google.com"` and `"https://google.com"` will work. A character scalar.
#' @param retries The maximum number of retries of the `HEAD` request in case of an HTTP error. An integer scalar >= `0`. The retries are performed using
#'   exponential backoff and jitter, see [httr::RETRY()] for details.
#' @param quiet Suppress the message displaying how long until the next retry in case an HTTP error occurred. A logical scalar. Only relevant if `retries > 0`.
#'
#' @return A logical scalar.
#' @seealso [RCurl::url.exists()]
#' @export
#'
#' @examples
#' is_http_success("goo.gl")
#' is_http_success("https://google.com/")
#' is_http_success("https://google.not/")
#' is_http_success("https://google.not/",
#'                 retries = 2,
#'                 quiet = FALSE)
is_http_success <- function(url,
                            retries = 0L,
                            quiet = TRUE) {
  
  assert_pkg("httr")
  
  rlang::with_handlers(!httr::http_error(httr::RETRY(verb = "HEAD",
                                                     url = url,
                                                     times = checkmate::assert_count(retries) + 1L,
                                                     quiet = quiet)),
                       error = ~ FALSE,
                       interrupt = ~ rlang::abort("Terminated by the user"))
}
```

# Extending other R packages

These functions are likely to be proposed upstream, and if accepted, will be removed from this package.

## cli

### Evaluate an expression with cli process indication

TODO:

-   Make this function work with tidyeval NSE verbs in `expr`!

    Reprex:

    ``` {.r}
    pal::cli_process_expr(msg = "WTF",
                          expr = {
                              col_name <- "Species"

                              iris %>% dplyr::select(!!col_name)
                          })
    ```

    The root cause of the problem might be similar to the one in `pkgpins::call_to_name()`...

-   Introduce a param for flexible condition "morphing" (e.g. errors as warnings)

    The class of the condition has to be changed for this before feeding it to `rlang::cnd_signal`.

-   Propose this function upstream!

```{r}
#' Evaluate an expression with cli process indication
#'
#' This is a convenience wrapper around [cli::cli_process_start()], [cli::cli_process_done()] and [cli::cli_process_failed()].
#'
#' @param expr An expression to be evaluated.
#' @param env Environment to evaluate `expr`, as well as possible [glue][glue::glue()] expressions within `msg`, in.
#' @inheritParams cli::cli_process_start
#'
#' @return The result of the evaluated `expr`.
#' @export
#'
#' @examples
#' \donttest{
#' cli_process_expr(Sys.sleep(3L), "Zzzz")}
#'
#' \dontrun{
#' # "russian roulette"
#' msg <- "Spinning the cylinder \U1F91E … "
#' cli_process_expr(msg = msg,
#'                  msg_done = paste0(msg, "and pulling the trigger – lucky again. \U1F60C"),
#'                  msg_failed = paste0(msg, "and pulling the trigger – head blast!"),
#'                  {
#'                    if (interactive()) Sys.sleep(1)
#'                    if (runif(1L) < 0.4) stop("\U1F92F\U2620")
#'                  })}
cli_process_expr <- function(expr,
                             msg,
                             msg_done = paste(msg, "... done"),
                             msg_failed = paste(msg, "... failed"),
                             msg_class = "alert-info",
                             done_class = "alert-success",
                             failed_class = "alert-danger",
                             env = parent.frame()) {
  assert_pkg("cli")
  
  # NOTE: We cannot rely on `on_exit = "done"` since in case of an error the on-exit code of this function will never be called because we actually throw
  #       the error using `rlang::cnd_signal(.x)`.
  status_bar_container_id <- cli::cli_process_start(msg = msg,
                                                    msg_done = msg_done,
                                                    msg_failed = msg_failed,
                                                    msg_class = msg_class,
                                                    done_class = done_class,
                                                    failed_class = failed_class,
                                                    .envir = env)
  
  rlang::with_handlers(.expr = eval(expr = rlang::enexpr(expr),
                                    envir = env),
                       error = ~ {
                         cli::cli_process_failed(status_bar_container_id)
                         rlang::cnd_signal(.x)
                       })
  
  cli::cli_process_done(status_bar_container_id)
}
```

## ellipsis

### Check that all dot parameter names are a valid subset of a function's parameter names.

**Remarks:**

-   Code to suggest proper dots params largely borrowed from `rlang::arg_match()`.

-   Function has been proposed upstream in [PR \#35](https://github.com/r-lib/ellipsis/pull/35).

```{r}
#' Check that all dot parameter names are a valid subset of a function's parameter names.
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' This function ensures that [dots (...)][base::dots()] are either empty (if `.empty_ok = TRUE`), or all named dot parameter names are a valid subset of a
#' function's parameter names. In case of an invalid or `.forbidden` argument, an informative message is shown and the defined `.action` is taken.
#'
#' @details
#'
#' `check_dots_named()` is intended to combat the second one of the two major downsides that using `...` usually brings. In chapter 6.6 of the book
#' _Advanced R_ it is [phrased](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot) as follows:
#'
#' _Using `...` comes with two downsides:_
#' 
#' - _When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to
#'   understand what you can do with functions like `lapply()` and `plot()`._
#' 
#' - **_A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed._**
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .additional Parameter names within `...` that should be treated as valid in addition to `.function`'s actual parameter names. A character vector.
#' @param .forbidden Parameter names within `...` that should be treated as invalid. This has precedence over `.additional`. A character vector.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of [rlang::abort()], [rlang::warn()], [rlang::inform()] or [rlang::signal()].
#' @export
#'
#' @examples
#' # We can use `check_dots_named()` to address this second downside:
#' sum_safe <- function(...,
#'                      na.rm = FALSE) {
#'   pal::check_dots_named(...,
#'                         .function = sum)
#'   sum(...,
#'       na.rm = na.rm)
#' }
#' 
#' # note how the misspelled `na_rm` (instead of `na.rm`) silently gets ignored
#' # in the original function
#' sum(1, 2, NA, na_rm = TRUE)
#'
#' \dontrun{
#' # whereas our safe version properly errors
#' sum_safe(1, 2, NA, na_rm = TRUE)}
#'
#' # we can even build an `sapply()` function that fails "intelligently" 
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#'
#' \dontrun{
#' # `sapply_safe()` will throw an informative error message
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")}
#'
#' \dontrun{
#' # but be aware that `check_dots_named()` might be a bit rash
#' sum_safe(a = 1, b = 2)}
#'
#' # while the original function actually has nothing to complain
#' sum(a = 1, b = 2)
#'
#' \dontrun{
#' # also, it doesn't play nicely with functions that don't expose all of
#' # their arg names (`to` and `by` in the case of `seq()`)
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             to = 100,
#'             by = 5)}
#'
#' # but providing `to` and `by` *unnamed* is fine of course:
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             100,
#'             5)
check_dots_named <- function(...,
                             .function,
                             .additional = NULL,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (...length()) {
    
    # determine original function name the `...` will be passed on to
    fun_arg_name <- deparse1(substitute(.function))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fun_arg_name %in% parent_param_names) {
      fun_name <- as.character(parent_call[which(parent_param_names == fun_arg_name) + 1L][[1L]])
    } else {
      fun_name <- fun_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(checkmate::assert_function(.function))
    
    # check named `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = check_dot_named,
                values = dots_param_names,
                allowed_values = setdiff(union(dots_param_names,
                                               checkmate::assert_character(.additional,
                                                                           any.missing = FALSE,
                                                                           null.ok = TRUE)),
                                         checkmate::assert_character(.forbidden,
                                                                     any.missing = FALSE,
                                                                     null.ok = TRUE)),
                fun_name = fun_name,
                action = .action)
    
  } else if (!checkmate::assert_flag(.empty_ok)) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = "`...` must be provided (!= NULL)!")
  }
}

check_dot_named <- function(dot,
                            values,
                            allowed_values,
                            fun_name,
                            action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- glue::glue(dplyr::if_else(is_forbidden,
                                     "Forbidden",
                                     "Invalid"), " argument provided in `...`: `{dot}`\n",
                      .trim = FALSE)
    
    if (length(allowed_values) > 0L) {
      
      msg %<>% glue::glue(dplyr::if_else(is_restricted,
                                         "Arguments allowed to pass on to ",
                                         "Valid arguments for "), "`{fun_name}()` include: ", prose_ls(allowed_values, wrap = "`"), "\n",
                          .trim = FALSE)
    } else {
      
      msg %<>% glue::glue("Only unnamed arguments are ", dplyr::if_else(is_restricted, "allowed", "valid"), " for `{fun_name}()`.")
    }
    
    i_partial <- pmatch(dot, allowed_values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values) / nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}
```

## readr

### Create column specification using regular expression matching

**Remarks:**

-   The "real" data in the examples stems from
    [here](https://opendata.swiss/en/dataset/wahlarchiv-des-kantons-zuerich/resource/893a7b0e-e394-4874-a0af-a99fb39358fd).

-   Function has been proposed upstream in [PR \#1112](https://github.com/tidyverse/readr/pull/1112) but was rejected.

```{r}
#' Create column specification using regular expression matching
#'
#' This function allows to define a regular expression per desired [column specification object][readr::cols] matching the respective column names.
#'
#' @param ... Named arguments where the names are (Perl-compatible) regular expressions and the values are column objects created by col_*(), or their
#'   abbreviated character names (as described in the col_types argument of [readr::read_delim()]).
#' @param .default Any named columns not matched by any of the regular expressions in `...` will be read with this column type.
#' @param .col_names The column names which should be matched by `...`.
#'
#' @return A [column specification][readr::cols].
#' @export
#'
#' @examples
#' # for some hypothetical CSV data column names like these ...
#' cnames <- c("VAR1_Text",
#'             "VAR2_Text",
#'             "VAR3_Text_Other",
#'             "VAR1_Code_R1",
#'             "VAR2_Code_R2",
#'             "HAS_R1_Lag",
#'             "HAS_R2_Lag",
#'             "GARBAGEX67",
#'             "GARBAGEY09")
#' 
#' # ... a column spec could be created concisely as follows:
#' pal::cols_regex(.col_names   = cnames,
#'                 "_Text(_|$)" = "c",
#'                 "_Code(_|$)" = "i",
#'                 "^GARBAGE"  = readr::col_skip(),
#'                 .default     = "l")
#'
#' # we can parse some real data:
#' raw_data <-
#'   httr::GET(paste0("http://www.web.statistik.zh.ch/ogd/data/",
#'                    "KANTON_ZUERICH_nrw_2019_listen_ergebnisse_gemeinde.csv")) %>%
#'   httr::content(as = "text",
#'                 encoding = "UTF-8")
#'
#' readr::read_csv(
#'   file = raw_data,
#'   col_types = pal::cols_regex(
#'     "^(Gemeindenamen|Partei)$" = "c",
#'     "(?i)anteil" = "d",
#'     .default = "i",
#'     .col_names = pal::dsv_colnames(raw_data)
#'   )
#' )
#'
#' # an alternative way to process the same data using `readr::type_convert()`:
#' readr::read_csv(file = raw_data,
#'                 col_types = list(.default = "c")) %>%
#'   readr::type_convert(col_types = pal::cols_regex(
#'     "^(Gemeindenamen|Partei)$" = "c",
#'     "(?i)anteil" = "d",
#'     .default = "i",
#'     .col_names = colnames(.)
#'   ))
cols_regex <- function(...,
                       .default = readr::col_character(),
                       .col_names) {
  
  assert_pkg("readr")
  
  if (length(names(list(...))) < ...length()) {
    rlang::abort("All column specifications in `...` must be named by a regular expression.")
  }
  
  patterns <- list(...)
  spec <- list()
  
  for (i in seq_along(patterns)) {
    matched_vars <- grep(x = .col_names,
                         pattern = names(patterns[i]),
                         value = TRUE,
                         perl = TRUE)
    
    spec <- c(spec, structure(rep(list(patterns[[i]]), length(matched_vars)),
                              names = matched_vars))
  }
  
  spec <- c(spec, alist(.default = .default))
  do.call(readr::cols, spec)
}
```

## roxygen2

### Get an object's roxygen2 tag value

```{r}
#' Get an object's roxygen2 tag value
#'
#' This function parses `text` for [roxygen2 blocks][roxygen2::roxy_block()] and extracts the value(s) belonging to the `tag_name`s documenting `obj_name`.
#'
#' @param text The R source code to extract the object's roxygen2 tag value from. A character vector.
#' @param obj_name The object name to which the roxygen2 tag belongs to, usually a function name. A character scalar.
#' @param tag_name The name of the [roxygen2 tag](https://roxygen2.r-lib.org/articles/rd.html) (without the `@`) to extract the value from. A character scalar.
#' @param param_name The parameter name to extract the value from. Only relevant if `tag_name = "param"`. A character scalar.
#'
#' @return A character scalar if `tag_name = "param"` and `param_name != NULL`, otherwise a list.
#' @export
#'
#' @examples
#' text <- readr::read_lines(paste0("https://raw.githubusercontent.com/r-lib/rlang/",
#'                                  "db52a58d505b65f58ba922d4752b5b0061f2a98c/R/fn.R"))
#'
#' roxy_tag_value(text = text,
#'                obj_name = "as_function",
#'                param_name = "x")
roxy_tag_value <- function(text,
                           obj_name,
                           tag_name = "param",
                           param_name = NULL) {
  
  assert_pkg("roxygen2")
  roxy_blocks <- roxygen2::parse_text(text = text)
  
  i_obj <- 
    roxy_blocks %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "object", "topic") %>%
    purrr::compact() %>%
    purrr::flatten_chr() %>%
    magrittr::equals(obj_name) %>%
    which()
  
  i_tag <-
    roxy_blocks[[i_obj]]$tags %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "tag") %>%
    purrr::compact() %>%
    purrr::flatten_chr() %>%
    magrittr::equals(tag_name) %>%
    which()
  
  tag_values <-
    i_tag %>%
    purrr::map(~ roxy_blocks[[i_obj]]$tags[[.x]]) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "val") %>%
    purrr::compact()
  
  if (tag_name == "param" & !is.null(param_name)) {
    
    i_param <-
      tag_values %>%
      purrr::map_depth(.depth = 1L,
                       .f = purrr::pluck,
                       "name") %>%
      purrr::compact() %>%
      purrr::flatten_chr() %>%
      magrittr::equals(checkmate::assert_string(param_name)) %>%
      which()
    
    result <- tag_values[[i_param]]$description
    
  } else {
    result <- tag_values
  }
  
  result
}
```

## RSelenium

### ...

```{r}
# assert_package("RSelenium")
```
