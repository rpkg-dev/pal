---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Logo

The package logo is based on the vector graphic [*help*](https://thenounproject.com/term/help/28807/) created by [Luis Prado](https://thenounproject.com/Luis)
which he licensed under [CC-BY 3.0](https://creativecommons.org/licenses/by/3.0/us/legalcode). The original logo is stored under `data-raw/logo/help.svg` and a
colored raster image version is stored under `data-raw/logo/help_yellow.png`.

This was fed to [hexSticker](https://github.com/GuangchuangYu/hexSticker) to create `data-raw/logo/hexsticker.png` and `data-raw/logo/hexsticker_alt.png` as
follows (the spotlight has some "random jitter", so hexSticker creates a slightly different image on each run):

```{r, purl = FALSE}
hexSticker::sticker(subplot = "data-raw/logo/help_yellow.png",
                    s_x = 1.0,
                    s_y = 1.31,
                    s_width = 0.47,
                    # the default asp 1.0 distorts the subplot, so we have to fiddle -.-
                    asp = 0.85,
                    package = "pal",
                    p_x = 1.0,
                    p_y	= 0.65,
                    p_color = "#ffcc00",
                    p_size = 40.0,
                    h_fill = "#000000",
                    h_color = "#ffcc00",
                    spotlight = TRUE,
                    l_x = 1.1,
                    l_y = 2.0,
                    l_width = 8.0,
                    l_height = 8.0,
                    l_alpha = 0.5,
                    url = "rpkg.dev/pal",
                    u_color = "#ffcc00",
                    u_size = 4.0,
                    filename = "data-raw/logo/hexsticker.png")
```

Finally, `data-raw/logo/hexsticker.png` was post-processed by the [G'MIC](https://gmic.eu/) filter *Felt Pen* in GIMP to create
`data-raw/logo/hexsticker_gmic_felt_pen.png` which, however, was discarded. Instead, the final package logo `data-raw/logo/hexsticker_smooth.png` is just
smoothed using the G'MIC filter *Smooth \[Diffusion\]* in GIMP.

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "data",
                                 "everything",
                                 "package",
                                 "Package",
                                 "repository",
                                 "rowid",
                                 "Version",
                                 "where"))
```

## Constants

```{r}
# forbidden dots arguments
forbidden_dots <- list(roxy_tag_value = c("pkgs",
                                          "destdir",
                                          "available",
                                          "type"))
```

## Functions

### `normalize_tree_path`

Normalize a tree path. Useful for GitHub's GraphQL API.

```{r}
normalize_tree_path <- function(path) {
  
  checkmate::assert_string(path) %>%
    fs::path_norm() %>%
    stringr::str_remove(pattern = "^\\.{0,2}(/|$)")
}
```

### CommonMark parsing helpers

#### `is_heading_node`

```{r}
is_heading_node <- function(xml_node) {
  
  xml2::xml_name(xml_node) == "heading"
}
```

#### `node_heading_lvl`

```{r}
node_heading_lvl <- function(xml_node) {
  
  xml_node %>%
    xml2::xml_attr(attr = "level") %>%
    as.integer()
}
```

#### `subnode_ix`

```{r}
subnode_ix <- function(xml_nodes,
                       i) {
  i_node <- i
  i <- i + 1L
  ix_subnodes <- integer()
  heading_lvl_node <- node_heading_lvl(xml_nodes[i_node])
  is_subnode <- is_heading_node(xml_nodes[i_node]) && i <= length(xml_nodes)
  
  while (is_subnode) {
    is_subnode <- !is_heading_node(xml_nodes[i]) || isTRUE(node_heading_lvl(xml_nodes[i]) > heading_lvl_node)
    ix_subnodes %<>% c(i[is_subnode])
    i <- i + 1L
    if (i > length(xml_nodes)) is_subnode <- FALSE
  }
  
  ix_subnodes
}
```

# Statistical computing / numbers

## `safe_seq_len`

```{r}
#' Generate an integer sequence of specific length (safe)
#'
#' Modified version of [`seq_len()`][base::seq_len()] that returns a zero-length integer in case of a zero-length input instead of throwing an error.
#'
#' @param n The desired length of the integer sequence.
#'
#' @return An integer sequence starting from `1L`.
#' @family stat
#' @export
#'
#' @examples
#' pal::safe_seq_len(5)
#'
#' # this function simply returns a zero-length integer for zero-length inputs ...
#' pal::safe_seq_len(NULL)
#' pal::safe_seq_len(integer())
#' 
#' # ... while `seq_len()` throws an error
#' \dontrun{
#' seq_len(NULL)
#' seq_len(integer())}
safe_seq_len <- function(n) {
  
  if (length(n)) {
    return(seq_len(n))
    
  } else return(integer())
}
```

## `safe_max`

Note that the `checkmate::assert_*()` functions currently [do *not* ensure correct types for `NA` input values](https://github.com/mllg/checkmate/issues/169).
Thus it is possible to feed `NA_character_` to the two functions below. A new param `typed.missing` has been [introduced in checkmate
devel](https://github.com/mllg/checkmate/pull/199) -> update fns below as soon as a new stable release is published!

```{r}
#' Maximum (safe)
#'
#' @description
#' Modified version of [`max()`][base::max()] that differs in the following ways:
#'
#' - `NA`s in the input (`...`) are ignored _by default_ (`rm_na = TRUE`).
#' - If the input is of length zero, the output will also be of length zero (of the same type as the input).
#' - It is ensured that all inputs are either numeric, of length zero or `NA`. There is _no_ case where the return value will be `Inf`.
#' - `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @param ... The numeric objects of which to determine the maximum. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param rm_na Ignore missing values in `...`. If missing values are present and `rm_na = FALSE`, the result will always be `NA`.
#'
#' @return A numeric scalar or empty value, of the same type as `...`.
#' @family stat
#' @export
#'
#' @examples
#' # other than `base::max()`, this function removes `NA`s by default
#' max(1, NA, 2)
#' pal::safe_max(1, NA, 2)
#'
#' # other than `base::max()`, this function does not return `Inf` or `NA_character_` for
#' # zero-length inputs
#' \dontrun{
#' max(NULL)
#' max(character())
#' max(integer())
#' pal::safe_max(NULL)
#' pal::safe_max(character())
#' pal::safe_max(integer())
#' 
#' # other than `base::max()`, this function fails for non-numeric, non-zero-length inputs
#' max("zero", 1L)
#' max("zero", "one")
#' pal::safe_max("zero", 1L)
#' pal::safe_max("zero", "one")}
safe_max <- function(...,
                     rm_na = TRUE) {
  
  rlang::list2(...) %>%
    purrr::map(checkmate::assert_numeric,
               null.ok = TRUE,
               .var.name = "...") %>%
    unlist() %>%
    purrr::when(length(.) == 0L ~ .[0L],
                all(is.na(.)) && rm_na ~ .[NA],
                ~ max(., na.rm = rm_na))
}
```

## `safe_min`

```{r}
#' Minimum (safe)
#'
#' @description
#' Modified version of [`min()`][base::min()] that differs in the following ways:
#'
#' - `NA`s in the input (`...`) are ignored _by default_ (`rm_na = TRUE`).
#' - If the input is of length zero, the output will also be of length zero (of the same type as the input).
#' - It is ensured that all inputs are either numeric, of length zero or `NA`. There is _no_ case where the return value will be `Inf`.
#' - `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @param ... The numeric objects of which to determine the minimum. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @inheritParams safe_max
#'
#' @inherit safe_max return
#' @family stat
#' @export
#'
#' @examples
#' # other than `base::min()`, this function removes `NA`s by default
#' min(1, NA, 2)
#' pal::safe_min(1, NA, 2)
#'
#' # other than `base::min()`, this function does not return `Inf` or `NA_character_` for
#' # zero-length inputs
#' \dontrun{
#' min(NULL)
#' min(character())
#' min(integer())
#' pal::safe_min(NULL)
#' pal::safe_min(character())
#' pal::safe_min(integer())
#' 
#' # other than `base::min()`, this function fails for non-numeric, non-zero-length inputs
#' min("zero", 1L)
#' min("zero", "one")
#' pal::safe_min("zero", 1L)
#' pal::safe_min("zero", "one")}
safe_min <- function(...,
                     rm_na = TRUE) {
  
  rlang::list2(...) %>%
    purrr::map(checkmate::assert_numeric,
               null.ok = TRUE,
               .var.name = "...") %>%
    unlist() %>%
    purrr::when(length(.) == 0L ~ .[0L],
                all(is.na(.)) && rm_na ~ .[NA],
                ~ min(., na.rm = rm_na))
}
```

## `round_to`

```{r}
#' Round to any number
#'
#' Round a numeric vector to any number, rounded up by default (`round_up = TRUE`).
#'
#' This function's precision is limited to 15 significant digits in order to account for the [limits of R's floating point
#' representation](https://stackoverflow.com/a/35349949/7196903).
#'
#' A computationally more efficient alternative would be the unexported `scales:::round_any()` which drives [scales::number()] â€“ with the drawback that it lacks
#' control of rounding up exact remainders of `accuracy / 2`, i.e. it _always_ rounds _off_.
#'
#' @param x A vector of numbers to round.
#' @param to The number to round `x` to. A numeric scalar.
#' @param round_up Whether to round a remainder of exactly `to / 2` _up_ or not. Set to `FALSE` in order to round _off_.
#'
#' @return A numeric vector of the same length as `x`.
#' @family stat
#' @export
#'
#' @examples
#' vals = c(0.025, 0.1, 0.1999, 0.099999, 0.49, 0.55, 0.5, 0.9, 1)
#' vals |> pal::round_to(to = 0.05)
#' vals |> pal::round_to(to = 0.05,
#'                       round_up = FALSE)
round_to <- function(x,
                     to = 0.2,
                     round_up = TRUE) {
  
  checkmate::assert_number(to,
                           lower = 0L,
                           finite = TRUE)
  checkmate::assert_flag(round_up)
  
  result <- x %/% to
  remainder <- signif(x %% to,
                      # round to a max of 15 significant digits to avoid exceeding floating-point representation limits
                      digits = 15L)
  
  if (round_up) {
    which_round <- remainder >= (to / 2L)
  } else {
    which_round <- remainder > (to / 2L)
  }
  
  result[which_round] <- result[which_round] + 1L
  
  result * to
}
```

## `stat_mode`

-   Solution borrowed from [hugovdberg](https://stackoverflow.com/a/38097776/7196903) and others.

```{r}
#' Statistical mode
#'
#' Computes the [statistical mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of a set of values. The mode is defined as the most frequent value, i.e. the
#' value that is most likely to be sampled.
#'
#' @param x An \R object.
#' @param type What the function should calculate.
#'   - `"one"`: Return _the_ mode of `x`. If multiple modes or no mode at all exists, `NA` is returned.
#'   - `"all"`: Return _all_ modes of `x`. If none exists (e.g. because all values of `x` are distinct), `NA` is returned.
#'   - `"n"`: Return the number of modes of `x`.
#' @param rm_na Ignore missing values in `x`. A logical scalar.
#'
#' @return If `type = "n"`, the number of modes in `x` (an integer). Otherwise, the mode(s) of `x` or `NA` if none exist(s) (same type as `x`).
#' @family stat
#' @seealso The package [modeest](https://cran.r-project.org/package=modeest) for more powerful mode estimation functions.
#' @export
#'
#' @examples
#' pal::stat_mode(c(rep(3L, times = 3), 1:9))
#' pal::stat_mode(c(1.5, 4, 9.9))
#' 
#' # if no mode exists, `NA` (of the same type as x) is returned
#' pal::stat_mode(letters)
#' pal::stat_mode(c(letters, "a"))
#' 
#' # if multiple modes exist, `NA` is returned by default
#' pal::stat_mode(c(letters, "a", "b"))
#' # set `type = "all"` to return all modes instead
#' pal::stat_mode(c(letters, "a", "b"),
#'                type = "all")
#' 
#' # `NA` is treated as any other value by default
#' pal::stat_mode(c(letters, "a", NA_character_, NA_character_),
#'                type = "all")
#' # set `rm_na = TRUE` to ignore `NA` values
#' pal::stat_mode(c(letters, "a", NA_character_, NA_character_),
#'                type = "all",
#'                rm_na = TRUE)
stat_mode <- function(x,
                      type = c("one", "all", "n"),
                      rm_na = FALSE) {
  x <- unlist(x)
  type <- rlang::arg_match(type)
  if (checkmate::assert_flag(rm_na)) x <- x[!is.na(x)]
  
  # get unique values
  u_x <- unique(x)
  n_u_x <- length(u_x)
  
  # get frequencies of all unique values
  frequencies <- tabulate(match(x, u_x))
  modes <- frequencies == max(frequencies)
  
  # determine number of modes
  n_modes <- sum(modes) %>% dplyr::if_else(. == n_u_x, 0L, .)
  
  type %>% purrr::when(
    # return the number of modes if requested
    . == "n" ~ n_modes,
    # or return mode(s) if requested and existing
    (. == "one" && n_modes == 1L) || (. == "all" && n_modes > 0L) ~ u_x[which(modes)],
    # else return `NA` (of the same type as `x`)
    ~ x[NA][1L]
  )
}
```

# Data frames / Tibbles

## `is_equal_df`

```{r}
#' Determine if two data frames/tibbles are equal
#'
#' Compares two [data frames][base::data.frame()]/[tibbles][tibble::tbl_df] (or two objects coercible to tibbles like [matrices][base::matrix()]), optionally
#' ignoring row and column ordering, and returns `TRUE` if both are equal, or `FALSE` otherwise. If the latter is the case and `quiet = FALSE`, information
#' about detected differences is printed to the console.
#'
#' Under the hood, this function relies on [waldo::compare()].
#'
#' @param x,y Two data frames/tibbles to compare. `y` is treated as the reference object, so messages describe how `x` is different to `y`.
#' @param ignore_col_order Whether or not to ignore the order of columns.
#' @param ignore_row_order Whether or not to ignore the order of rows.
#' @param ignore_col_types Whether or not to distinguish similar column types. Currently, if set to `TRUE`, this will convert factor to character and integer to
#'   double before comparison.
#' @param quiet Whether or not to output detected differences between `x` and `y` to the console.
#' @param max_diffs The maximum number of differences shown. Only relevant if `quiet = FALSE` or `return_waldo_compare = TRUE`. Set `max_diffs = Inf` to see all
#'   differences.
#' @param return_waldo_compare Whether to return a character vector of class [`waldo_compare`][waldo::compare] describing the differences between `x` and `y`
#'   instead of `TRUE` or `FALSE`.
#' @inheritParams waldo::compare
#'
#' @return If `return_waldo_compare = FALSE`, a logical scalar indicating the result of the comparison. Otherwise a character vector of class
#'   [`waldo_compare`][waldo::compare] describing the differences between `x` and `y`.
#' @family tibble
#' @export
#'
#' @examples
#' scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))]
#'
#' # by default, ordering of rows and columns matters ...
#' pal::is_equal_df(x = mtcars,
#'                  y = scramble(mtcars))
#'
#' # ... but those can be ignored if desired
#' pal::is_equal_df(x = mtcars,
#'                  y = scramble(mtcars),
#'                  ignore_col_order = TRUE)
#' pal::is_equal_df(x = mtcars,
#'                  y = scramble(mtcars),
#'                  ignore_row_order = TRUE)
#'
#' # by default, `is_equal_df()` is sensitive to column type differences ...
#' df1 <- data.frame(x = "a",
#'                   stringsAsFactors = FALSE)
#' df2 <- data.frame(x = factor("a"))
#' pal::is_equal_df(df1, df2)
#'
#' # ... but you can request it to not make a difference between similar types
#' pal::is_equal_df(df1, df2,
#'                  ignore_col_types = TRUE)
is_equal_df <- function(x,
                        y,
                        ignore_col_order = FALSE,
                        ignore_row_order = FALSE,
                        ignore_col_types = FALSE,
                        tolerance = NULL,
                        quiet = TRUE,
                        max_diffs = 10L,
                        return_waldo_compare = FALSE) {
  
  assert_pkg("waldo")
  checkmate::assert_flag(ignore_col_order)
  checkmate::assert_flag(ignore_row_order)
  checkmate::assert_flag(ignore_col_types)
  checkmate::assert_number(tolerance,
                           lower = 0,
                           null.ok = TRUE)
  checkmate::assert_flag(quiet)
  checkmate::assert_number(max_diffs,
                           lower = 1)
  checkmate::assert_flag(return_waldo_compare)
  
  # convert `x` and `y` to tibble if any modification is required
  if (ignore_col_order || ignore_row_order || ignore_col_types) {
    
    x %<>% tibble::as_tibble()
    y %<>% tibble::as_tibble()
  }
  
  # sort columns if necessary
  if (ignore_col_order) {
    
    x %<>% dplyr::select(sort(colnames(.)))
    y %<>% dplyr::select(sort(colnames(.)))
  }
  
  # sort rows if necessary
  if (ignore_row_order) {
    
    x %<>% dplyr::arrange(dplyr::across(.cols = everything()))
    y %<>% dplyr::arrange(dplyr::across(.cols = everything()))
  }
  
  # harmonize column types if necessary
  if (ignore_col_types) {
    
    x %<>% dplyr::mutate(dplyr::across(.cols = where(is.factor),
                                       .fns = as.character),
                         dplyr::across(.cols = where(is.integer),
                                       .fns = as.double))
    y %<>% dplyr::mutate(dplyr::across(.cols = where(is.factor),
                                       .fns = as.character),
                         dplyr::across(.cols = where(is.integer),
                                       .fns = as.double))
  }
  
  result <- waldo::compare(x = x,
                           y = y,
                           tolerance = tolerance,
                           x_arg = "x",
                           y_arg = "y",
                           max_diffs = max_diffs)
  
  if (length(result)) {
    
    if (!quiet) {
      
      cli::cli_alert_info(text = "`x` differs from `y`:")
      cat("\n")
      print(result)
    }
    
    if (!return_waldo_compare) result <- FALSE
    
  } else if (!return_waldo_compare) {
    result <- TRUE
  }
  
  result
}
```

## `reduce_df_list`

TODO: Add an example where this fn is useful.

```{r}
#' Reduce a nested list of data frames / tibbles to a single tibble
#'
#' Recursively reduces a nested list containing data frames / tibbles at its leafs to a single tibble.
#'
#' @param x A list containing data frames / tibbles at its leafs.
#' @param strict Ensure `x` contains data frames / tibbles only and throw an error otherwise. If `FALSE`, leafs containing other objects are ignored (skipped).
#'
#' @return `r pkgsnip::return_label("data")`
#' @family tibble
#' @export
reduce_df_list <- function(x,
                           strict = TRUE) {
  
  if (is.data.frame(x) || tibble::is_tibble(x)) {
    
    return(x)
    
  } else if (purrr::vec_depth(x) < 2L) {
    
    if (checkmate::assert_flag(strict)) {
      cli::cli_abort("At least one element of the list to be reduced is not a data frame / tibble!")
      
    } else return(NULL)
    
  } else purrr::map_dfr(.x = x,
                        .f = reduce_df_list,
                        strict = strict)
}
```

# Lists

## `as_flat_list`

TODO:

-   Behaviour with named (sub)lists like the following one is counter-intuitive:

    ``` r
    fokus::raw_q_suppl_election(ballot_date = ballot_date,
                                lvl = 'cantonal',
                                canton = canton,
                                prcd = "proportional",
                                election_nr = election_nr) %$%
        party %>%
        dplyr::first() %>%
        pal::as_flat_list() %>%
        str()
    ```

    When setting `keep_attrs = FALSE` (`names` is an attribute), the list is actually flattened (but parent names lost). Ideal would be to have a param like
    `concatenate_names = FALSE` which could be used to vary this behaviour.

```{r}
#' Convert to a flat list
#'
#' @description
#' _Recursively_ flattens a list. Unlike the similar `unlist()`, it
#'
#' - always returns a list, i.e. wraps `x` in a list if necessary, and will never remove the last list level. Thus it is
#'   [type-safe](https://en.wikipedia.org/wiki/Type_safety).
#'
#' - won't treat any of the list leafs specially (like `unlist()` does with factors). Thus leaf values will never be modified.
#'
#' - removes list names. `unlist()` concatenates nested names (separated by a dot).
#'
#' @param x `r pkgsnip::param_label("r_obj")`
#' @param keep_attrs Keep [attributes][base::attr()] (and thereby retain list structure of custom objects). A logical scalar.
#' @param attrs_to_drop Attribute names which should never be kept. Only relevant if `keep_attrs = TRUE`. A character vector.
#'
#' @return A [list][base::list()].
#' @family list
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' nested_list <- list(1:3, list("foo", list("bar"))) %T>% str()
#' 
#' # unlike `unlist()` which also removes the last list tier in many cases ...
#' unlist("foobar")
#' unlist(nested_list) %>% str()
#' # ... this function always returns an (unnested) list
#' pal::as_flat_list("foobar") %>% str()
#' pal::as_flat_list(nested_list) %>% str()
#' 
#' nested_list <- list(list(factor("a"), factor("b")), factor("c")) %T>% str()
#' 
#' # unlike `unlist()` which combines factors ...
#' unlist(nested_list) %>% str()
#' # ... this function does not modify the list elements
#' pal::as_flat_list(nested_list) %>% str()
#' 
#' nested_list <-
#'   list(c(list(1L), list(tibble::tibble(a = list(1.1, "2")))),
#'        list(tibble::as_tibble(mtcars[1:2, ]))) %T>%
#'   str()
#' nested_list_2 <- list(1:3, xfun::strict_list(list(list("buried deep")))) %T>% str()
#'
#' # by default, attributes and thus custom objects (except `xfun_strict_list`) are retained, i.e.
#' # not flattened ...
#' pal::as_flat_list(nested_list) %>% str()
#' pal::as_flat_list(nested_list_2) %>% str()
#' # ... but you can drop them and thereby flatten custom objects if needed ...
#' pal::as_flat_list(nested_list, keep_attrs = FALSE) %>% str()
#' # ... or retain `xfun_strict_list`s, too
#' pal::as_flat_list(nested_list_2, attrs_to_drop = NULL) %>% str()
as_flat_list <- function(x,
                         keep_attrs = TRUE,
                         attrs_to_drop = "xfun_strict_list") {
  
  regard_attrs <- checkmate::assert_flag(keep_attrs) && length(setdiff(attributes(x),
                                                                       checkmate::assert_character(attrs_to_drop,
                                                                                                   any.missing = FALSE,
                                                                                                   null.ok = TRUE)))
  depth <- purrr::vec_depth(x)
  
  # wrap `x` in a list if it's not
  if (regard_attrs || depth < 2L) {
    result <- list(x)
    
    # return `x` as-is if it is an unnested list
  } else if (depth < 3L) {
    result <- x
    
    # flatten the two last list levels (keeping attributes if requested)
  } else if (depth < 4L) {
    result <- x %>% purrr::when(keep_attrs ~ rm_list_level(.,
                                                           attrs_to_drop = attrs_to_drop),
                                ~ purrr::flatten(.))
  } else {
    
    # recursively feed the elements of `x` to this function and flatten the two last list levels (keeping attributes if requested)
    result <-
      x %>%
      purrr::map(.f = as_flat_list,
                 keep_attrs = keep_attrs,
                 attrs_to_drop = attrs_to_drop) %>%
      purrr::when(keep_attrs ~ rm_list_level(.,
                                             attrs_to_drop = attrs_to_drop),
                  ~ purrr::flatten(.))
  }
  
  result
}

rm_list_level <- function(x,
                          attrs_to_drop = "xfun_strict_list") {
  
  result <- list()
  
  for (i in seq_along(checkmate::assert_list(x))) {
    
    regard_attrs <- length(setdiff(attributes(x[[i]]), attrs_to_drop))
    
    if (!regard_attrs && purrr::vec_depth(x[[i]]) > 1L) {
      result %<>% c(x[[i]])
    } else {
      result %<>% c(list(x[[i]]))
    }
  }
  
  result
}
```

## `list_drop`

```{r}
#' Drop list elements by name
#'
#' Drops all list elements whose names match the provided set.
#'
#' @param x A list.
#' @param drop The names of the list elements to drop.
#'
#' @return A list.
#' @family list
#' @export
#'
#' @examples
#' as.list(mtcars) |> pal::list_drop(c("disp", "drat", "qsec"))
#' 
#' # works with any R objects that are internally of type list
#' mtcars |> pal::list_drop(c("disp", "drat", "qsec"))
list_drop <- function(x,
                      drop) {
  
  if (!is.list(x)) cli::cli_abort("{.arg x} must be of type list.")
  
  checkmate::assert_character(drop,
                              any.missing = FALSE)
  
  names_x <- names(x) %||% FALSE
  
  if (any(names_x %in% drop)) {
    x <- x[-which(names_x %in% drop)]
  }
  
  x
}
```

## `list_keep`

```{r}
#' Keep list elements by name
#'
#' Keeps only the list elements whose names match the provided set.
#'
#' @param x A list.
#' @param keep The names of the list elements to keep.
#'
#' @return A list.
#' @family list
#' @export
#'
#' @examples
#' as.list(mtcars) |> pal::list_keep(c("gear", "carb"))
#' 
#' # works with any R objects that are internally of type list
#' mtcars |> pal::list_keep(c("gear", "carb"))
list_keep <- function(x,
                      keep) {
  
  if (!is.list(x)) cli::cli_abort("{.arg x} must be of type list.")
  
  checkmate::assert_character(keep,
                              any.missing = FALSE)
  
  x[which(names(x) %in% keep)]
}
```

# Strings

## `as_comment_string`

```{r}
#' Assemble an (R) comment string of the desired line width
#'
#' Takes a vector of paragraphs, wraps them at the specified line width, prefixes them with comment markers and returns the result as a single string.
#'
#' @param ... Comment lines. A character vector or something coercible to.
#' @param line_width Maximum character width at which to wrap lines. An integer scalar.
#' @param comment_prefix Character sequence that indicates the start of a comment. A character scalar.
#' @param sep_paragraphs Whether or not to separate paragraphs with an empty comment line.
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' pal::as_comment_string(glue::glue("Copyright (C) {format(Sys.Date(), '%Y')} Santa Clause"),
#'                        "No presents without code.") |>
#'   cat()
#'
#' # wrap lines at 20 chars
#' pal::as_comment_string(glue::glue("Copyright (C) {format(Sys.Date(), '%Y')} Santa Clause"),
#'                        "No presents without code.", line_width = 20L) |>
#'   cat()
#'
#' # disable empty comment lines between paragraphs:
#' pal::as_comment_string(glue::glue("Copyright (C) {format(Sys.Date(), '%Y')} Santa Clause"),
#'                        "Hohoho.",
#'                        sep_paragraphs = FALSE) |>
#'   cat()
as_comment_string <- function(...,
                              line_width = 160L,
                              comment_prefix = "# ",
                              sep_paragraphs = TRUE) {
  as_chr(...) %>%
    stringr::str_wrap(width = checkmate::assert_count(line_width) - nchar(checkmate::assert_string(comment_prefix))) %>%
    stringr::str_split(pattern = "\n") %>%
    purrr::map(~ paste0(comment_prefix, .x) %>%
                 paste0(collapse = "\n")) %>%
    purrr::map2_chr(.f =
                      function(.x, .y, n_lines) {
                        if (checkmate::assert_flag(sep_paragraphs) && .y < n_lines) paste0(.x, "\n", comment_prefix, "\n") else paste0(.x, "\n")
                      },
                    .y = seq_along(.),
                    n_lines = length(.)) %>%
    paste0(collapse = "")
}
```

## `as_chr`

```{r}
#' Convert to a character vector
#'
#' _Recursively_ applies [as.character()] to its inputs.
#'
#' @param ... The \R objects to be converted to a character vector. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' to_convert <-
#'   list(tibble::tibble(a = 1:3), "A", factor("wonderful"), xfun::strict_list("day")) %T>%
#'   print()
#'
#' as.character(to_convert)
#' pal::as_chr(!!!to_convert)
as_chr <- function(...) {
  
  rlang::list2(...) %>%
    purrr::map(~ {
      
      if (purrr::vec_depth(.x) == 1L) {
        
        as.character(.x)
        
      } else {
        
        .x %>%
          purrr::map(as_chr) %>%
          purrr::flatten_chr()
      }
    }) %>%
    purrr::flatten_chr()
}
```

## `as_line_feed_chr`

```{r}
#' Convert control character sequence name to actual character sequence
#'
#' @param eol `r pkgsnip::param_label("eol")`
#'
#' @return A character scalar.
#' @family string
#' @export
as_line_feed_chr <- function(eol = c("LF", "CRLF", "CR", "LFCR")) {
  
  switch(EXPR = rlang::arg_match(eol),
         LF = "\n",
         CRLF = "\r\n",
         CR = "\r",
         LFCR = "\n\r")
}
```

## `as_string`

```{r}
#' Convert to a character scalar (aka string)
#'
#' Similar to [`paste0(..., collapse = "")`][paste0()], but _recursively_ converts its inputs to type character.
#'
#' @param ... The \R objects to be assembled to a single string. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param sep The separator to delimit `...`. Defaults to none (`""`).
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' input <-
#'   sample.int(n = 5,
#'              size = 3) %>%
#'   paste0(", ") %>%
#'   purrr::map(rep,
#'              times = 20) %>%
#'   list(c("This is a glut of ", "meaningless numbers: "), .)
#'
#' # while this just converts `input` in a lazy way ...
#' paste0(input,
#'        collapse = "")
#'
#' # ... this one works harder
#' pal::as_string(input)
as_string <- function(...,
                      sep = "") {
  
  as_chr(...) %>% purrr::when(length(.) > 0L ~ paste0(., collapse = sep),
                              ~ .)
}
```

## `sentenceify`

```{r}
#' Convert to sentence case with trailing punctuation mark
#'
#' Converts the input to a character vector and ensures it starts with an upper case letter and ends with the specified punctuation mark.
#'
#' Note that this function doesn't alter any characters in `x` other than the first and the last one.
#'
#' @param x The input to be converted to [sentence case](https://en.wikipedia.org/wiki/Letter_case#Case_styles), typically a character vector.
#' @param punctuation_mark The punctuation mark to be appended to `x`. A character scalar.
#'
#' @return A character vector.
#' @family string
#' @seealso
#' [stringr::str_to_sentence()] to convert a character vector to all lowercase except for the first character. Note that this also includes lowercasing [proper
#' nouns](https://en.wikipedia.org/wiki/Proper_and_common_nouns), [abbreviations](https://en.wikipedia.org/wiki/Abbreviation) etc.
#' 
#' [snakecase::to_sentence_case()] that builds upon [stringr::str_to_sentence()] but offers additional options to finetune the conversion. Note that
#' `abbreviations` have to be manually specified in order to be preserved in upper case.
#' @export
#'
#' @examples
#' pal::sentenceify("no verb, no sentence")
#'
#' # punctuation mark won't be duplicated if already existing
#' pal::sentenceify(c("I've made my point",
#'                    "good point."))
sentenceify <- function(x,
                        punctuation_mark = ".") {
  
  checkmate::assert_string(punctuation_mark)
  
  x %>%
    stringr::str_replace(pattern = "^.",
                         replacement = toupper) %>%
    purrr::map_chr(~ {
      if (is.na(.x) || stringr::str_sub(string = .x, start = -1L) == punctuation_mark) {
        .x
      } else {
        paste0(.x, punctuation_mark)
      }
    })
}
```

## `escape_lf`

```{r}
#' Escape line feeds / newlines
#'
#' Escapes the [POSIX-standard newline control character `LF`](https://en.wikipedia.org/wiki/Newline) (aka `\n`) which is the standard on Unix/Linux and recent
#' versions of macOS. Set `escape_cr = TRUE` in order to also escape the carriage return character `CR` (aka `\r`) commonly used on Microsoft Windows.
#'
#' @param x A character vector.
#' @param escape_cr Whether or not to also escape the carriage return character `CR` (aka `\r`). A logical scalar.
#'
#' @return A character vector of the same length as `x`.
#' @family string
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' # read in and print package description as-is
#' text <-
#'   fs::path_package(package = "pal",
#'                    "DESCRIPTION") %>%
#'   readr::read_file() %T>%
#'   pal::cat_lines()
#'
#' # escape newlines and print again
#' pal::escape_lf(text) %>% pal::cat_lines()
escape_lf <- function(x,
                      escape_cr = FALSE) {
  
  checkmate::assert_character(x,
                              null.ok = TRUE) %>%
  stringr::str_replace_all(pattern = "\\n",
                           replacement = "\\\\n") %>%
    purrr::when(checkmate::assert_flag(escape_cr) ~ stringr::str_replace_all(string = .,
                                                                             pattern = "\\r",
                                                                             replacement = "\\\\r"),
                ~ .)
}
```

## `fuse_regex`

TODO:

-   [ ] Deprecate `fuse_regex(...)` in favor of \`rex::rex(or(...))\`\`?

-   [ ] Incorporate `fuzzify_regex()` and `diacritify_regex` from FA

    open question: make a separate pkg, say `rgx`?

```{r}
#' Fuse regular expressions
#'
#' Combines a vector or list of regular expressions to a single one (by logical OR).
#'
#' @param ... The regular expressions. All elements will be converted to type character before fusing. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return A character scalar.
#' @seealso The [rex][rex::rex] package which provides an intuitive framework to build complex regular expressions.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' # perform some (nonsense) Jane Austen text extraction
#' regex <- c("My dear Jane",
#'            "make haste, ",
#'            "(?i)\\bevil")
#'
#' stringr::str_subset(string = janeaustenr::prideprejudice,
#'                     pattern = pal::fuse_regex(regex))}
fuse_regex <- function(...) {
  
  result <- as_string(..., sep = "|")
  
  if (length(rlang::list2(...)) > 1L || length(rlang::list2(...)[[1L]]) > 1L) {
    result %<>% paste0("(", ., ")")
  }
  
  result
}
```

## `dsv_colnames`

```{r}
#' Get column names of a delimiter-separated string
#'
#' Returns the column names of a string in a [delimiter-separated-value](https://en.wikipedia.org/wiki/Delimiter-separated_values) format like
#' [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) or [TSV](https://en.wikipedia.org/wiki/Tab-separated_values).
#'
#' @param x The delimiter-separated string. A character scalar.
#' @param delim Single character used to separate fields within `x`.
#' @param quote Single character used to quote strings within `x`. Set to `NULL` for none.
#'
#' @return A character vector of column names.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' httr::GET("https://raw.githubusercontent.com/tidyverse/readr/master/inst/extdata/mtcars.csv") |>
#'   httr::content(as = "text") |>
#'   pal::dsv_colnames()}
dsv_colnames <- function(x,
                         delim = ",",
                         quote = "\"") {
  x %>%
    regexpr(pattern = "[\r\n]") %>%
    magrittr::subtract(1L) %>%
    substr(x = x,
           start = 1L) %>%
    stringr::str_split(pattern = checkmate::assert_string(delim,
                                                          min.chars = 1L,
                                                          pattern = "^.$")) %>%
    dplyr::first() %>%
    stringr::str_remove_all(pattern = glue::glue("^", checkmate::assert_string(quote,
                                                                                null.ok = TRUE,
                                                                                pattern = "^.$"),
                                                 "|{quote}$"))
}
```

## `prose_ls`

TODO: Thoroughly compare this fn to `knitr::combine_words()` and maybe deprecate it in favor of the latter?

```{r}
#' List items concatenated in prose style (..., ... and ...)
#'
#' Takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' pal::prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  
  result <- as_chr(x)
  length_result <- length(result)
  
  if (length_result == 1L) {
    
    result <- paste0(checkmate::assert_string(wrap), result, wrap)
    
  } else if (length_result > 1L) {
    
    result <-
      paste0(result[-length_result],
             collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, result[length_result], wrap)
  }
  
  result
}
```

## `prettify_nr`

```{r}
#' Prettify a numeric vector
#'
#' Prettifies a numeric vector by rounding, separating thousands and optionally other procedures. Basically a convenience wrapper around [round_to()] and
#' [`format()`][base::format()].
#'
#' @param x A numeric vector to prettify.
#' @param round_to The number to round `x` to. A numeric scalar.
#' @param big_mark The character used between every 3 digits to separate thousands.
#' @param decimal_mark The character used to indicate the numeric decimal point. Only relevant if `x` does not solely consist of integers.
#' @param justify_right Whether to right-justify the results to a common width. See the `trim` parameter of [base::format()] for details.
#' @param ... Further arguments passed on to [base::format()].
#' @inheritParams round_to
#'
#' @return A character vector of the same length as `x`.
#' @family string
#' @export
#'
#' @examples
#' c(0.11, 11111.11) |> pal::prettify_nr()
#'
#' c(0.11, 11111.11) |>
#'   pal::prettify_nr(justify_right = TRUE) |>
#'   pal::cat_lines()
prettify_nr <- function(x,
                        round_to = 0.1,
                        round_up = TRUE,
                        big_mark = "'",
                        decimal_mark = ".",
                        justify_right = FALSE,
                        ...) {
  round_to(x = x,
           to = round_to,
           round_up = round_up) %>%
    format(big.mark = big_mark,
           decimal.mark = decimal_mark,
           trim = !justify_right,
           ... = ...)
}
```

## `cat_lines`

```{r}
#' Print `x` as newline-separated character vector using `cat()`.
#' 
#' Convenience wrapper around [as_chr()] and [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param ... The \R object(s) to print. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @inherit base::cat return
#' @family string
#' @seealso
#' [cli::cat_line()] for a faster alternative that doesn't _recursively_ convert its input to type character.
#'
#' [xfun::raw_string()] (and [xfun::file_string()]) for an alternative approach to the same use case (but without any conversion to type character at all). 
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   pal::cat_lines()
#' 
#' # recursive conversion to type character or not
#' to_convert <-
#'   list(tibble::tibble(a = 1:3), "A", factor("wonderful"), xfun::strict_list("day")) %T>%
#'   print()
#' 
#' to_convert %>% pal::cat_lines()
#' to_convert %>% cli::cat_line()
cat_lines <- function(...) {
  
  cat(as_chr(...),
      sep = "\n")
}
```

## `wrap_chr`

```{r}
#' Wrap character vector in string
#'
#' @param x A character vector or something coercible to. Will be fed to [as_chr()] before wrapping.
#' @param wrap The string `x` is to be wrapped in.
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' mtcars %>%
#'   magrittr::set_colnames(pal::wrap_chr(x = colnames(.),
#'                                        wrap = "`")) %>%
#'   pal::pipe_table()
wrap_chr <- function(x,
                     wrap = "\"") {
  
  paste0(wrap, as_chr(x), wrap)
}
```

# Dots

## DESCRIPTION

Extending the [ellipsis](https://ellipsis.r-lib.org/) package, making the use of [R's `...` argument placeholder](https://rdrr.io/r/base/dots.html) yet another
bit safer.

## `check_dots_named`

TODO:

-   The `msg` gets truncated if more cli classes are used (e.g. `"{.fn {fn_name}}"`) so we have to avoid it below. Investigate what exactly is going on and
    report upstream!

NOTES:

-   Code to suggest proper dots params largely borrowed from
    [`rlang:::stop_arg_match()`](https://github.com/r-lib/rlang/blob/2a269c44aaa3985ce742e0e91a48b2d3c4664f3c/R/arg.R#L79-L110) (MIT-licensed).

-   Function has been proposed upstream in [PR #35](https://github.com/r-lib/ellipsis/pull/35).

```{r}
#' Check that all named dots arguments are valid
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' Ensures that [dots][base::dots()] `...` are either empty (if `.empty_ok = TRUE`), or all named elements in dots are a valid subset of `.fn`'s parameter
#' names. In case of an invalid or `.forbidden` argument, an informative message is shown and the defined `.action` is taken.
#'
#' @details
#'
#' `check_dots_named()` is intended to combat the second one of the two major downsides that using `...` usually brings. In chapter 6.6 of the book
#' _Advanced R_ it is [phrased](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot) as follows:
#'
#' _Using `...` comes with two downsides:_
#' 
#' - _When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to
#'   understand what you can do with functions like `lapply()` and `plot()`._
#' 
#' - **_A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed._**
#'
#' @param ... The dots argument to check.
#' @param .fn The function the `...` will be passed on to.
#' @param .additional Parameter names within `...` that should be treated as valid in addition to `.fn`'s actual parameter names. A character vector.
#' @param .forbidden Parameter names within `...` that should be treated as invalid. This has precedence over `.additional`. A character vector.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. A function expecting a condition message string as first argument. For example [cli::cli_abort()],
#'   [cli::cli_warn()], [cli::cli_inform()] or [rlang::signal()].
#'
#' @family dots
#' @export
#'
#' @examples
#' # We can use `check_dots_named()` to address this second downside:
#' sum_safe <- function(...,
#'                      na.rm = FALSE) {
#'   pal::check_dots_named(...,
#'                         .fn = sum)
#'   sum(...,
#'       na.rm = na.rm)
#' }
#' 
#' # note how the misspelled `na_rm` (instead of `na.rm`) silently gets ignored
#' # in the original function
#' sum(1, 2, NA, na_rm = TRUE)
#'
#' \dontrun{
#' # whereas our safe version properly errors
#' sum_safe(1, 2, NA, na_rm = TRUE)}
#'
#' # we can even build an `sapply()` function that fails "intelligently" 
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .fn = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#'
#' \dontrun{
#' # `sapply_safe()` will throw an informative error message
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")}
#'
#' \dontrun{
#' # but be aware that `check_dots_named()` might be a bit rash
#' sum_safe(a = 1, b = 2)}
#'
#' # while the original function actually has nothing to complain
#' sum(a = 1, b = 2)
#'
#' \dontrun{
#' # also, it doesn't play nicely with functions that don't expose all of
#' # their arg names (`to` and `by` in the case of `seq()`)
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             to = 100,
#'             by = 5)}
#'
#' # but providing `to` and `by` *unnamed* is fine of course:
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             100,
#'             5)
check_dots_named <- function(...,
                             .fn,
                             .additional = NULL,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = cli::cli_abort) {
  
  checkmate::assert_function(.fn)
  checkmate::assert_character(.additional,
                              any.missing = FALSE,
                              null.ok = TRUE)
  checkmate::assert_character(.forbidden,
                              any.missing = FALSE,
                              null.ok = TRUE)
  checkmate::assert_flag(.empty_ok)
  checkmate::assert_function(.action)
  
  if (...length()) {
    
    # determine original function name the `...` will be passed on to
    fn_arg_name <- deparse1(substitute(.fn))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fn_arg_name %in% parent_param_names) {
      fn_name <- as.character(parent_call[which(parent_param_names == fn_arg_name) + 1L][[1L]])
    } else {
      fn_name <- fn_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(.fn)
    
    # check named `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = check_dot_named,
                values = dots_param_names,
                allowed_values = setdiff(union(dots_param_names,
                                               .additional),
                                         .forbidden),
                fn_name = fn_name,
                action = .action)
    
  } else if (!.empty_ok) {
    .action(cli::format_error("{.arg ...} must be provided (!= NULL)."))
  }
}

check_dot_named <- function(dot,
                            values,
                            allowed_values,
                            fn_name,
                            action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- paste0(dplyr::if_else(is_forbidden,
                                 "Forbidden",
                                 "Invalid"),
                  " argument provided in `...`: `{dot}`\n\n")
    
    if (length(allowed_values) > 0L) {
      
      msg %<>% paste0(dplyr::if_else(is_restricted,
                                     "Arguments allowed to pass on to ",
                                     "Valid arguments for "),
                      "`{fn_name}()` include: ", prose_ls(allowed_values, wrap = "`"), ".")
    } else {
      
      msg %<>% paste0("Only unnamed arguments are ", dplyr::if_else(is_restricted, "allowed", "valid"), " for `{fn_name}()`.")
    }
    
    i_partial <- pmatch(dot, allowed_values)
    candidate <- NULL
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values) / nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (!is.null(candidate)) {
      msg <- paste0(msg, "\n\nDid you mean {.arg {candidate}}?")
    }
    
    action(msg)
  }
}
```

# R packages

## `ls_pkg`

```{r}
#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case Do not distinguish between upper and lower case letters in `pkg`. If `FALSE`, `pkg` is treated case-sensitive.
#' @param as_regex Interpret `pkg` as regular expression(s). If `FALSE`, `pkg` is interpreted literally.
#'
#' @return A [tibble][tibble::tbl_df].
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE,
                   as_regex = FALSE) {
  
  regex <-
    checkmate::assert_character(pkg,
                                any.missing = FALSE,
                                min.chars = 1L) %>%
    purrr::when(checkmate::assert_flag(as_regex) ~ .,
                ~ paste0("\\Q", ., "\\E")) %>%
    fuse_regex() %>%
    purrr::when(checkmate::assert_flag(ignore_case) ~ paste0("(?i)", .),
                ~ .) %>%
    purrr::when(as_regex ~ .,
                ~ paste0("^", ., "$"))
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = regex))
}
```

## `assert_pkg`

TODO:

-   Incorporate code from FA.

-   Add additional params `install_source`. Open question: How to best handle multiple pkgs at once if they don't share the install source? Just recycle
    `install_source`?

```{r}
#' Assert a package is installed
#'
#' Asserts a package is installed on the current system, optionally ensuring a `min_version`. If the package is not installed, an informative error `message` is
#' thrown that by default includes an autogenerated `install_hint`.
#'
#' @param pkg Package name. A character scalar.
#' @param min_version Minimum required version number of `pkg`. Must be either `NULL` to ignore version numbers, or a single
#'   [`package_version`][base::package_version()] or something coercible to.
#' @param message The error message to display in case the package is not installed. `r pkgsnip::param_label("cli_markup_support")` If `NULL`, a sensible
#'   standard message is generated.
#' @param install_hint Additional package installation instructions appended to `message`. Either `NULL` in order to autogenerate the hint, or a
#'   character scalar. Set `install_hint = ""` in order to disable the hint.
#'
#' @return `pkg`, invisibly.
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::assert_pkg("pal")
#'
#' pal::assert_pkg(pkg = "glue",
#'                 message = paste("You should really consider to install the awesome {.pkg {pkg}}",
#'                                 "package! It's the glue that keeps strings and variables",
#'                                 "together ðŸ¤²."))
#' \dontrun{
#' pal::assert_pkg("pal", min_version = 9999.9)
#' 
#' pal::assert_pkg("yay",
#'                 install_hint = paste0("To install the latest development version, run ",
#'                                       "{.code remotes::install_gitlab(\"salim_b/r/pkgs/yay\")}."))}
assert_pkg <- function(pkg,
                       min_version = NULL,
                       message = NULL,
                       install_hint = NULL) {
  
  checkmate::assert_string(pkg)
  min_version %<>% as.package_version()
  checkmate::assert_string(message,
                           null.ok = TRUE)
  checkmate::assert_string(install_hint,
                           null.ok = TRUE)
  
  # check if required version is available
  if (!is_pkg_installed(pkg = pkg,
                        min_version = min_version)) {
    
    # check if pkg is installed at all
    lacks_min_version <- length(min_version) > 0L && is_pkg_installed(pkg = pkg)
    
    # generate message if necessary
    if (is.null(message)) {
      
      message <- paste0("Package {.pkg {pkg}",
                        dplyr::if_else(length(min_version) == 0L,
                                       "",
                                       " (>= {min_version})"),
                        "} is required for this operation but ",
                        dplyr::if_else(lacks_min_version,
                                       paste0("installed version is ",
                                              max(as.package_version(ls_pkg(pkg = pkg)$Version)), "."),
                                       "is not installed."))
    }
    
    # generate installation hint if necessary
    if (is.null(install_hint)) {
      
      assert_pkg("pkgsearch")
      
      cran <- pkgsearch::pkg_search(pkg, size = 1L)
      is_cran_pkg <- length(intersect(cran$package, pkg)) > 0L
      is_cran_min_version <- ifelse(length(min_version) == 0L,
                                    is_cran_pkg,
                                    cran %>%
                                      dplyr::filter(version >= min_version) %$%
                                      package %>%
                                      intersect(pkg) %>%
                                      length() %>%
                                      magrittr::is_greater_than(0L))
      
      if (is_cran_min_version) {
        install_hint <- "To install the latest version, run {.code install.packages(\"{pkg}\")}."
        
      } else {
        install_hint <- paste0("Please first ", dplyr::if_else(lacks_min_version, "update {.pkg {pkg}}", "install it"),
                               " and then try again. Note that ",
                               dplyr::if_else(is_cran_pkg, "the required version of {.pkg {pkg}} is not available on CRAN (yet).",
                                              "{.pkg {pkg}} is not available on CRAN."))
      }
    }
    
    cli::cli_abort(paste(message, install_hint))
    
  }
  
  invisible(pkg)
}
```

## `is_pkg_installed`

Part of this function [was originally proposed by Artem Klevtsov on Stack Overflow](https://stackoverflow.com/a/38082613/7196903).

```{r}
#' Test if packages are installed
#'
#' Returns `TRUE` or `FALSE` for each `pkg`, depending on whether the `pkg` is installed on the current system or not, optionally ensuring a `min_version`.
#'
#' In contrast to [base::require()], it checks if the packages are installed without attaching their namespaces if so.
#' 
#' In contrast to [rlang::is_installed()] or [xfun::pkg_available()], it doesn't load the packages if they're installed and it is fully vectorized, i.e. returns
#' a (named) logical vector of the same length as `pkg`.
#' 
#' It is [considerably
#' faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the commonly used
#' `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names. A character vector.
#' @param min_version Minimum required version number of each `pkg`. Must be either `NULL` to ignore version numbers, or a vector of
#'   [`package_version`][base::package_version()]s or something coercible to.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::is_pkg_installed("tidyverse")
#'
#' # it is vectorized ...
#' pal::is_pkg_installed(pkg = c("dplyr", "tibble", "magrittr"),
#'                       min_version = c("1.0", "2.0", "99.9.9000"))
#'
#' # ... and scalar arguments will be recycled
#' pal::is_pkg_installed(pkg = "dplyr",
#'                       min_version = c("0.5", "1.0", "99.9.9000"))
#'
#' pal::is_pkg_installed(pkg = c("dplyr", "tibble", "magrittr"),
#'                       min_version = "1.0")
is_pkg_installed <- function(pkg,
                             min_version = NULL) {
  
  checkmate::assert_character(pkg,
                              any.missing = FALSE)
  min_version %<>% as.package_version()
  
  if (length(min_version) == 0L) {
    
    result <- purrr::map_lgl(magrittr::set_names(pkg, pkg),
                             ~ nzchar(system.file(package = .x)))
  } else {
    
    result <-
      is_pkg_installed(pkg = pkg) %>%
      list(names(.), min_version) %>%
      purrr::pmap_lgl(~ {
        if (..1) utils::packageVersion(pkg = ..2) >= ..3 else ..1
      })
  }
  
  result
}
```

## `is_pkg_cran`

```{r}
#' Test if a package is available on CRAN
#'
#' @inheritParams assert_pkg
#'
#' @return A logical scalar.
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::is_pkg_cran("foobar")
#' pal::is_pkg_cran("dplyr")
#' pal::is_pkg_cran("dplyr", min_version = 9999.9)
is_pkg_cran <- function(pkg,
                        min_version = NULL) {
  
  checkmate::assert_string(pkg)
  min_version %<>% as.package_version()
  assert_pkg("pkgsearch")
  
  pkg %>%
    pkgsearch::pkg_search() %>%
    purrr::when(length(min_version) == 0L ~ .,
                ~ dplyr::filter(.data = .,
                                version >= min_version)) %$%
    package %>%
    intersect(pkg) %>%
    length() %>%
    magrittr::is_greater_than(0L)
}
```

## `is_pkg_dir`

```{r}
#' Test if a directory is an \R package
#'
#' Convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that it will only return `TRUE` for the root of a
#' package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an \R package, `FALSE` otherwise.
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::is_pkg_dir()
#' pal::is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  assert_pkg("rprojroot")
  checkmate::assert_directory(path,
                              access = "r")
  
  rprojroot::is_r_package$testfun %>%
    purrr::map_lgl(~ .x(path = path)) %>%
    any()
}
```

## `is_pkgdown_dir`

TODO:

-   [ ] Remove custom `Remotes:` dep as soon as [this](https://github.com/r-lib/rprojroot/pull/79) is merged and released.

```{r}
#' Test if pkgdown is set up for an R package directory
#'
#' Convenience wrapper around the [rprojroot::is_pkgdown_project] root criterion. Note that it will only return `TRUE` for the root of a
#' package directory and the `pkgdown` subdirectory, not other subdirectories.
#'
#' @param path The path of the R package directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if pkgdown is set up for `path`, `FALSE` otherwise.
#' @family rpkgs
#' @export
#'
#' @examples
#' pal::is_pkgdown_dir()
#' pal::is_pkgdown_dir(fs::path_package("pal"))
is_pkgdown_dir <- function(path = ".") {
  
  assert_pkg("rprojroot")
  checkmate::assert_directory(path,
                              access = "r")
  
  rprojroot::is_pkgdown_project$testfun %>%
    purrr::map_lgl(~ .x(path = path)) %>%
    any()
}
```

## Package DESCRIPTION

### DESCRIPTION

Extending the [desc](https://github.com/r-lib/desc#readme) package.

### `desc_list`

TODO:

-   [ ] Figure out why the example below throws the error

    ``` error
    No root directory found in .../r/pkgs/pal.Rcheck or its parent directories.
    Root criterion: contains a file "DESCRIPTION" with contents matching "^Package: "
    ```

    during R CMD Check while almost the same example in `desc_value()` doesn't...!?

```{r}
#' Get all `DESCRIPTION` file fields as cleaned up list
#'
#' @description
#' Returns all fields from a specific `DESCRIPTION` file as a named list with values cleaned up:
#' - Whitespaces at the start and end of field values as well as repeated whitespaces within them are removed.
#' - Multi-value fields are returned as vectors.
#' - The fields `Depends`, `Imports` and `Suggests` are returned as a single data frame named `dependencies`.
#'
#' @inheritParams desc_value
#'
#' @return A list.
#' @family desc
#' @export
#'
#' @examples
#' \dontrun{
#' pal::desc_list(file = fs::path_package(package = "pal"))
#' }
desc_list <- function(file = ".") {
  
  fields <- desc::desc_fields(file = file)
  
  result <-
    fields %>%
    setdiff(c("Authors@R",
              "Depends",
              "Imports",
              "Suggests",
              "URL")) %>%
    rlang::set_names() %>%
    purrr::map(desc_value,
               file = file)
  
  if ("Authors@R" %in% fields) result[["Authors@R"]] <- desc::desc_get_authors(file = file)
  if (any(c("Depends", "Imports", "Suggests") %in% fields)) result[["dependencies"]] <- desc::desc_get_deps(file = file)
  if ("URL" %in% fields) result[["URL"]] <- desc::desc_get_urls(file = file)
  
  result
}
```

### `desc_value`

TODO:

-   [ ] Use `desc::desc_get_field()`'s `squish_ws` param (introduced in v1.4.0). And rename fn to something like `desc_get_field_safe()`?

-   [ ] Figure out why setting `default` to an error call referring to `key` doesn't work, i.e.:

    ``` r
    pal::desc_value("Suggestss", default = cli::cli_abort("No {.field {key}} field set in {.file DESCRIPTION}!")))
    ```

```{r}
#' Get the value from a `DESCRIPTION` file field, cleaned up and with dynamic fallback
#'
#' Returns the value from a specific `DESCRIPTION` file field (aka _key_). Whitespaces at the start and end of the value as well as repeated whitespaces within
#' it are removed.
#' 
#' This function is a slightly modified version of [desc::desc_get_field()] that allows the `default` parameter to be dependent on the `key` parameter.
#'
#' By default, the following string is returned if `key = "NoRealKey"` is not found:
#'
#' ```
#' "<No `NoRealKey` field set in DESCRIPTION!>"
#' ```
#'
#' If you rather want to take an action like throwing an error, it's recommended to call [desc::desc_get_field()] directly.
#'
#' @param default Default value to return if `key` is not found.
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @family desc
#' @export
#'
#' @examples
#' pal::desc_value(key = "Description",
#'                 file = fs::path_package("pal"))
desc_value <- function(key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = ".") {
  assert_pkg("desc")
  
  desc::desc_get_field(key = key,
                       default = default,
                       file = file)
}
```

### `desc_url_git`

TODO:

-   [ ] Propose this function upstream.

```{r}
#' Get the Git repository URL from a `DESCRIPTION` file
#'
#' Returns the first Git repository URL found in the `URL` (preferred) or `BugReports` fields of a `DESCRIPTION` file.
#'
#' Currently, this function recognizes [GitLab](https://gitlab.com/), [GitHub](https://github.com/), [Gitea](https://gitea.com/),
#' [Codeberg](https://codeberg.org/), [Pagure](https://pagure.io/), [Bitbucket](https://bitbucket.org/) and [SourceHut](https://sr.ht/) repository URLs.
#'
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @family desc
#' @export
desc_url_git <- function(file = ".") {
  
  assert_pkg("desc")
  
  desc::desc_get_field(key = "BugReports",
                       default = character(),
                       file = file) %>%
    stringr::str_replace(pattern = "/issues/?$",
                         replacement = "/") %>%
    c(desc::desc_get_urls(), .) %>%
    stringr::str_subset(pattern = "^https?://(git(hub|lab|ea)\\..+|(codeberg|bitbucket)\\.org|(git\\.)?src\\.ht|pagure\\.io)/") %>%
    dplyr::first()
}
```

## Package documentation

### DESCRIPTION

Extending the [roxygen2](https://roxygen2.r-lib.org/) package.

### `roxy_blocks`

TODO: Figure out how we can properly run the examples during R CMD check and then remove the `\dontrun{}` (also in examples of `roxy_tag_value()`)

```{r}
#' Get roxygen2 blocks
#'
#' Parses the roxygen2 package documentation of a specific R package or from a single `.R` source code file.
#'
#' @param pkg,text Either a package name or a character vector of \R source code lines to extract the object's roxygen2 tag value from.
#' @param ... Further arguments passed on to [download.packages()], excluding `r forbidden_dots$roxy_tag_value %>% prose_ls(wrap = "\x60")`. Only relevant
#'   if `pkg` is provided. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param quiet `r pkgsnip::param_label("quiet")`
#'
#' @return A list of [`roxy_block`][roxygen2::roxy_block] objects.
#' @family roxy
#' @export
#'
#' @examples
#' # Either provide an R source file as a character vector `text` ...
#' text <- readr::read_lines(paste0("https://raw.githubusercontent.com/r-lib/rlang/",
#'                                  "db52a58d505b65f58ba922d4752b5b0061f2a98c/R/fn.R"))
#'
#' pal::roxy_blocks(text = text) |> head(n = 3L)
#'
#' # ... or provide a package name
#' \dontrun{
#' pal::roxy_blocks(pkg = "rlang",
#'                  repos = "https://cloud.r-project.org") |>
#'   head(n = 3L)}
roxy_blocks <- function(pkg = NULL,
                        ...,
                        text = NULL,
                        quiet = TRUE) {
  
  assert_pkg("roxygen2")
  checkmate::assert_flag(quiet)
  checkmate::assert_string(pkg, null.ok = TRUE)
  checkmate::assert_character(text, null.ok = TRUE)
  is_pkg_null <- is.null(pkg)
  is_text_null <- is.null(text)
  if (is_pkg_null && is_text_null) cli::cli_abort("One of {.arg pkg} and {.arg text} mustn't be {.val NULL}.")
  if (!is_pkg_null && !is_text_null) cli::cli_abort("Only one of {.arg pkg} and {.arg text} can be provided.")
  
  if (is_pkg_null) {
    
    assert_pkg("ellipsis")
    ellipsis::check_dots_empty()
    
    blocks <- rlang::with_handlers(roxygen2::parse_text(text = text),
                                   error = ~ list(FALSE, .x))
    
    if (length(blocks) && isFALSE(blocks[[1L]])) {
      
      error_msg <- as.character(blocks[[2L]])
      is_missing_obj <- error_msg %>% stringr::str_detect(" (not found|could not find .+)\\n")
      
      cli::cli_abort(ifelse(is_missing_obj,
                            error_msg %>%
                              stringr::str_remove(pattern = '^.*: ') %>%
                              stringr::str_replace(pattern = "could not find function \"(.+?)\"",
                                                   replacement = "Function {.fun \\1} not found") %>%
                              stringr::str_replace(pattern = "object '(.+?)'",
                                                   replacement = "Object {.var \\1}") %>%
                              stringr::str_replace(pattern = "not found\\n?",
                                                   replacement = paste0("was not found when parsing {.arg text}. You might need to attach the package you're ",
                                                                        "trying to extract the roxygen2 tag value from. Or try ",
                                                                        "{.fn pkg_roxy_tag_value}.")),
                            "Error parsing {.arg text}: {error_msg}"))
    }
  } else {
    
    assert_pkg("rappdirs")
    check_dots_named(...,
                     .fn = utils::download.packages,
                     .forbidden = forbidden_dots$roxy_tag_value)
    
    # alert if installed version doesn't match downloaded one:
    pkgs_available <-
      utils::available.packages(type = "source",
                                filters = c("R_version",
                                            "OS_type",
                                            "subarch",
                                            "CRAN")) %>%
      tibble::as_tibble() %>%
      dplyr::filter(Package == pkg)
    
    pkg_version_max_installed <-
      ls_pkg(pkg = pkg,
             as_regex = FALSE) %$%
      Version %>%
      max()
    
    if (pkg_version_max_installed %in% pkgs_available$Version) { 
      
      pkgs_available %<>% dplyr::filter(Version == pkg_version_max_installed)
      
    } else {
      
      cli::cli_alert_warning(paste0("No sources available for download of locally installed version {.val pkg_version_max_installed} of package {.pkg {pkg}}. ",
                                    "Downloading sources of latest available version {.val {max(pkgs_available[, 'Version'])}} instead. If the following ",
                                    "roxygen tag parsing fails or produces unexpected results, consider updating package {.pkg {pkg}}."))
    }
    
    pkgs_available %<>%
      as.matrix() %>%
      magrittr::set_rownames(.[, 1L])
    
    tmp_dir <-
      rappdirs::user_cache_dir() %>%
      fs::path(glue::glue("pal-roxy_tag_value-{pkg}")) %>%
      fs::dir_create() %>%
      fs::path_real()
    
    tmp_archive <- utils::download.packages(pkgs = pkg,
                                            destdir = tmp_dir,
                                            available = pkgs_available,
                                            ... = !!!rlang::list2(...),
                                            type = "source",
                                            quiet = quiet)
    
    utils::untar(tarfile = tmp_archive[1L, 2L],
                 exdir = tmp_dir)
    
    tmp_pkg <- fs::path(tmp_dir, pkg)
    blocks <- if (quiet) suppressMessages(roxygen2::parse_package(path = tmp_pkg)) else roxygen2::parse_package(path = tmp_pkg)
    
    unlink(x = tmp_dir,
           recursive = TRUE)
  }
  
  blocks
}
```

### `roxy_obj`

```{r}
#' Get roxygen2 block object
#'
#' Extracts a single object from a list of [`roxy_block`][roxygen2::roxy_block] objects.
#'
#' @param blocks A list of [`roxy_block`][roxygen2::roxy_block] objects as returned by [roxy_blocks()].
#' @param obj_name The object name to extract, usually a function name. A character scalar.
#'
#' @return A [`roxy_block`][roxygen2::roxy_block] object.
#' @family roxy
#' @export
roxy_obj <- function(blocks,
                     obj_name) {
  
  checkmate::assert_list(blocks,
                         types = "roxy_block",
                         all.missing = FALSE)
  obj_names <-
    blocks %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "object", "topic") %>%
    purrr::compact() %>%
    purrr::flatten_chr()
  
  obj_name <- rlang::arg_match(arg = obj_name,
                               values = obj_names)
  
  blocks[[which(obj_names == obj_name)]]
}
```

### `roxy_tag_value`

```{r}
#' Get an object's roxygen2 tag value(s)
#'
#' Extracts the value(s) belonging to the `tag_name`s documenting `obj_name` from a list of [`roxy_block`][roxygen2::roxy_block] objects.
#'
#' @inheritParams roxy_obj
#' @param tag_names The name(s) of the [roxygen2 tags](https://roxygen2.r-lib.org/articles/rd.html) (without the `@`) to extract the value(s) from. A character
#'   vector.
#' @param param_name The parameter name to extract the value from. Only relevant if `"param" %in% tag_names`. A character scalar.
#'
#' @return A character vector of the same length as `tag_names`.
#' @family roxy
#' @export
#'
#' @examples
#' \dontrun{
#' blocks <- pal::roxy_blocks(pkg = "dplyr")
#'
#' pal::roxy_tag_value(blocks = blocks,
#'                     obj_name = "across",
#'                     tag_names = "param",
#'                     param_name = ".fns") |>
#'   cat()}
roxy_tag_value <- function(blocks,
                           obj_name,
                           tag_names = "param",
                           param_name) {
  
  block <- roxy_obj(blocks = blocks,
                    obj_name = obj_name)
  tags <- block$tags
  
  tag_names <-
    checkmate::assert_subset(tag_names,
                             choices = tags %>% purrr::map_chr(purrr::pluck, "tag"),
                             empty.ok = FALSE) %>%
    unique()
  
  if ("param" %in% tag_names) {
    
    ix_param <-
      tags %>%
      purrr::map_lgl(~ .x$tag == "param") %>%
      which()
    
    param_name <- rlang::arg_match(arg = param_name,
                                   values = tags[ix_param] %>% purrr::map_chr(purrr::pluck,
                                                                              "val", "name"))
    i_to_keep <-
      tags[ix_param] %>%
      purrr::map_lgl(~ .x$val$name == param_name) %>%
      which()
    
    block$tags %<>% magrittr::extract(-ix_param[-i_to_keep])
  }
  
  tag_names %>%
    purrr::map_chr(~ roxygen2::block_get_tag_value(block = block,
                                                   tag = .x) %>%
                     purrr::when(is.list(.) ~ .$description,
                                 ~ .))
}
```

# (Pandoc) Markdown

## `as_md_list`

TODO:

-   [ ] Mention usefulness of this fn for roxygen2 doc as soon as [issue #1112](https://github.com/r-lib/roxygen2/issues/1112) is resolved.

```{r}
#' Convert a character vector to a Markdown list
#'
#' Convenience wrapper around [pander::pandoc.list.return()] to convert a character vector (or something coercible to) to a [Markdown
#' list](https://pandoc.org/MANUAL.html#lists).
#'
#' @param x The character vector to be converted to a Markdown list.
#' @param type The Markdown list type. One of
#'   - `"unordered"` for an unordered aka [bullet list](https://pandoc.org/MANUAL.html#bullet-lists). Corresponds to `<ul>` in HTML.
#'   - `"ordered"` for an ordered aka [numbered list](https://pandoc.org/MANUAL.html#ordered-lists). Corresponds to `<ol>` in HTML.
#'   - `"ordered_roman"` for a variation of an ordered/numbered list with uppercase roman numerals instead of Arabic numerals as list markers.
#' @param tight Whether or not to add additional spacing between list items.
#' @param indent_lvl The level of indentation of the resulting Markdown list. For each level, four additional spaces are added in front of every list item. An
#'   integer scalar.
#' @param wrap An optional string to wrap the list items in.
#'
#' @return A character scalar.
#' @family md
#' @export
#'
#' @examples
#' rownames(mtcars) |> pal::as_md_list() |> cat()
as_md_list <- function(x,
                       type = c("unordered", "ordered", "ordered_roman"),
                       tight = TRUE,
                       indent_lvl = 0L,
                       wrap = NULL) {
  
  type <- rlang::arg_match(type)
  checkmate::assert_flag(tight)
  checkmate::assert_count(indent_lvl)
  checkmate::assert_string(wrap,
                           null.ok = TRUE)
  assert_pkg("pander")
  
  pander::pandoc.list.return(elements = paste0(wrap, as_chr(x), wrap),
                             style = switch(EXPR = type,
                                            unordered = "bullet",
                                            ordered = "ordered",
                                            ordered_roman = "roman"),
                             loose = !tight,
                             indent.level = indent_lvl,
                             add.line.breaks = FALSE,
                             add.end.of.list = FALSE)
}
```

## `pipe_table`

```{r}
#' Convert dataframe/tibble to Markdown pipe table
#'
#' Convenience wrapper around [`knitr::kable(format = "pipe")`][knitr::kable()] to create a [Markdown pipe
#' table](https://pandoc.org/MANUAL.html#extension-pipe_tables).
#' 
#' # Create tables dynamically in roxygen2 documentation
#' 
#' This function can be useful to create tables inside [roxygen2][roxygen2::roxygen2] documentation programmatically from data using
#' [dynamic \R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1).
#' 
#' For example, the inline code
#' 
#' `` `r mtcars %>% head() %>% pipe_table()` ``
#'
#' should produce the following table in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' `r mtcars %>% head() %>% pipe_table()`
#'
#' @inherit knitr::kable details
#'
#' @param x The dataframe/tibble/matrix to be converted to a pipe table.
#' @param incl_rownames Whether to include row names or not. A logical scalar or `NULL`. If `NULL`, row names are included if `rownames(x)` is neither `NULL`
#'   nor identical to `seq_len(nrow(x))`.
#' @param strong_colnames Highlight column names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param strong_rownames Highlight row names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param align Column alignment. Either `NULL` for auto-alignment or a character vector consisting of `'l'` (left), `'c'` (center) and/or `'r'` (right). If
#'   `align = NULL`, numeric columns are right-aligned, and other columns are left-aligned. If `length(align) == 1L`, the string will be expanded to a vector
#'   of individual letters, e.g. `'clc'` becomes `c('c', 'l', 'c')`.
#' @param format_args A list of arguments to be passed to [format()] to format table values, e.g. `list(big.mark = ',')`.
#' @inheritParams knitr::kable
#'
#' @return A character vector.
#' @family md
#' @export
#'
#' @examples
#' mtcars |> head() |> pal::pipe_table() |> pal::cat_lines()
pipe_table <- function(x,
                       incl_rownames = NULL,
                       strong_colnames = TRUE,
                       strong_rownames = TRUE,
                       align = NULL,
                       label = NULL,
                       digits = getOption("digits"),
                       format_args = list()) {
  
  assert_pkg("knitr")
  checkmate::assert_flag(incl_rownames,
                         null.ok = TRUE)
  
  # format rownames <strong> if requested and sensible
  if ((isTRUE(incl_rownames) && !is.null(rownames(x))) ||
      (is.null(incl_rownames) && !identical(rownames(x), as.character(seq_len(nrow(x)))))) {
    
    rownames(x) %<>% paste0("**", ., "**")
  }
  
  kable_args <-
    alist(x = x,
          format = "pipe",
          digits = digits,
          row.names = ifelse(is.null(incl_rownames),
                             NA,
                             incl_rownames),
          col.names = colnames(x) %>% purrr::when(checkmate::assert_flag(strong_colnames) ~ paste0("**", ., "**"),
                                                  ~ .),
          label = label,
          format.args = format_args) %>%
    purrr::when(!is.null(align) ~ c(., alist(align = align)),
                ~ .)
  
  do.call(what = knitr::kable,
          args = kable_args)
}
```

## `strip_md`

```{r}
#' Strip Markdown formatting from character vector
#'
#' Removes all Markdown formatting from a character vector.
#'
#' This function relies on [commonmark::markdown_text()] which [supports the CommonMark specification plus the Github
#' extensions](https://github.com/jeroen/commonmark#readme). Unfortunately, [Markdown footnotes](https://pandoc.org/MANUAL.html#footnotes) aren't supported
#' (yet). Therefore a separate option `strip_footnotes` is offered which relies on a simple regular expression to remove inline footnotes and footnote
#' references.
#'
#' @param x A character vector to strip Markdown formatting from.
#' @param strip_footnotes Whether to remove Markdown footnotes, too.
#'
#' @return A character vector of the same length as `x`.
#' @family md
#' @export
#'
#' @examples
#' pal::strip_md(
#'   "A **MD** formatted [string](https://en.wikipedia.org/wiki/String_(computer_science))"
#' )
#'
#' # link references are only removed *iff* the reference is included in `x`:
#' pal::strip_md("[A reference link][refid]\n\n[refid]: https://example.com")
#' pal::strip_md("[A reference link][refid]\n\n_No ref here..._")
strip_md <- function(x,
                     strip_footnotes = TRUE) {
  
  assert_pkg("commonmark")
  
  checkmate::assert_character(x) %>%
    purrr::map_chr(~ .x %>% purrr::when(is.na(.) ~ .,
                                        ~ commonmark::markdown_text(text = .,
                                                                    extensions = TRUE) %>%
                                          stringr::str_remove(pattern = "\n$") %>%
                                          purrr::when(checkmate::assert_flag(strip_footnotes) ~ strip_md_footnotes(.),
                                                      ~ .)))
}
```

## `strip_md_footnotes`

TODO: Write some tests!

```{r}
#' Strip Markdown footnotes from character vector
#'
#' Removes all Markdown footnotes from a character vector.
#'
#' @param x A character vector to strip Markdown footnotes from. Note that elements in `x` are processed as separate Markdown domains, i.e. _not_ as individual
#' lines belonging to the same Markdown document.
#'
#' @return A character vector of the same length as `x`.
#' @family md
#' @export
strip_md_footnotes <- function(x) {
  
  checkmate::assert_character(x) %>%
    stringr::str_remove_all(pattern = "((?<=(^|\\n))\\[\\^.+?\\]: +(.|\\n)+?(\\n{2,}|\\s*$)( {4,}.*?\\n+)*|\\[\\^.+?\\]|\\^\\[.+?\\])")
}
```

## CommonMark parsing

### DESCRIPTION

Extending the [commonmark](https://github.com/r-lib/commonmark#readme) package.

### `md_to_xml`

TODO:

-   [ ] There's already the [tinkr](https://docs.ropensci.org/tinkr/) package providing [`to_xml()`](https://docs.ropensci.org/tinkr/reference/to_xml.html). The
    main advantage of `md_to_xml()` is that `strip_yaml_header()` is more robust in YAML header detection than [blogdown's
    `split_yaml_body()`](https://github.com/ropensci/tinkr/blob/master/R/utils.R#L25-L40) used in `to_xml()`.

    Thus it would be ideal to:

    1.  Submit PR introducing `xfun::split_yaml_body()` based on logic in `strip_yaml_header()`; xfun is already imported in blogdown and xaringan.

    2.  Submit PR replacing [`blogdown:::split_yaml_body()`](https://github.com/rstudio/blogdown/blob/main/R/utils.R#L761-L775) with `xfun::split_yaml_body()`.

    3.  Submit PR replacing [`xaringan:::split_yaml_body()`](https://github.com/yihui/xaringan/blob/master/R/utils.R#L34-L43) with `xfun::split_yaml_body()`.

    4.  Submit PR importing xfun and replacing [`tinkr:::split_yaml_body()`](https://github.com/ropensci/tinkr/blob/master/R/utils.R#L25-L40) with
        `xfun::split_yaml_body()`.

    5.  Deprecate `md_to_xml()` and instead rely on `tinkr::to_xml()$body` for the same purpose.

```{r}
#' Parse (R) Markdown as CommonMark XML tree
#'
#' Parses (R) Markdown file content according to the [CommonMark](https://commonmark.org/) specification and returns it as an XML parse tree.
#'
#' @inheritParams as_line_feed_chr
#' @inheritParams gitlab_document
#' @inheritParams commonmark::markdown_xml
#' @param md The (R) Markdown file content as a character scalar.
#' @param hardbreaks Whether or not to treat newlines as hard line breaks.
#' @param strip_xml_ns Whether or not to [remove the default XML namespace][xml2::xml_ns_strip] (`d1`) assigned by [commonmark::markdown_xml()].
#'
#' @return An [`xml_document`][xml2::xml_document-class].
#' @family commonmark
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "Rmd/pal.Rmd",
#'                   owner = "salim-b",
#'                   name = "pal") |>
#'   pal::md_to_xml()
md_to_xml <- function(md,
                      smart_punctuation = FALSE,
                      hardbreaks = FALSE,
                      normalize = TRUE,
                      sourcepos = FALSE,
                      extensions = TRUE,
                      eol = c("LF", "CRLF", "CR", "LFCR"),
                      strip_xml_ns = TRUE) {
  
  assert_pkg("commonmark")
  assert_pkg("xml2")
  
  result <-
    strip_yaml_header(rmd = md,
                      eol = eol) %>%
    commonmark::markdown_xml(hardbreaks = hardbreaks,
                             smart = smart_punctuation,
                             normalize = normalize,
                             sourcepos = sourcepos,
                             extensions = extensions) %>%
    xml2::read_xml() %>%
    purrr::when(strip_xml_ns ~ xml2::xml_ns_strip(.),
                ~ .)
  
  # `xml2::xml_ns_strip()` returns its result invisibly, so we make it visible again
  (result)
}
```

### `md_xml_subnode_ix`

```{r}
#' Determine CommonMark XML subnode indices
#'
#' Determines the XML children node indices for every XML node at the highest level of `xml` by interpreting [Markdown heading
#' levels](https://pandoc.org/MANUAL.html#headings) (1â€“6).
#'
#' [commonmark::markdown_xml()] (and so [md_to_xml()] which builds upon it) **do** parse (R) Markdown file content according to the
#' **[CommonMark](https://commonmark.org/) specification**, but **do not** return any information about the document's **heading hierarchy**.
#' `md_xml_subnode_ix()` fills this gap by giving the hierarchy structure in the form of the XML subnode indices for every node at the highest level of `xml`.
#'
#' @param xml The CommonMark parse tree. An [`xml_document`][xml2::xml_document-class], [`xml_nodeset`][xml2::xml_nodeset-class] or
#'   [`xml_node`][xml2::xml_node-class].
#'
#' @return A list of integer vectors of the same length as the number of XML nodes at the highest level of `xml`.
#' @family commonmark
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "Rmd/pal.Rmd",
#'                   owner = "salim-b",
#'                   name = "pal") |>
#'   pal::md_to_xml() |>
#'   pal::md_xml_subnode_ix() |>
#'   head()
md_xml_subnode_ix <- function(xml) {
  
  assert_class_any(xml,
                   classes = c("xml_document", "xml_nodeset", "xml_node"),
                   name = "xml")
  assert_pkg("xml2")
  
  xml_names <- xml2::xml_name(xml)
  
  if (length(xml_names) == 1L && xml_names == "document") {
    xml %<>% xml2::xml_contents()
  }
  
  seq_along(xml) %>% purrr::map(~ subnode_ix(xml_nodes = xml,
                                             i = .x))
}
```

### `xml_to_md`

```{r}
#' Convert from CommonMark XML to (R) Markdown
#'
#' @inheritParams md_xml_subnode_ix
#'
#' @return A character scalar.
#' @family commonmark
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "Rmd/pal.Rmd",
#'                   owner = "salim-b",
#'                   name = "pal") |>
#'   pal::md_to_xml() |>
#'   xml2::xml_contents() |>
#'   magrittr::extract(23:25) |>
#'   pal::xml_to_md() |>
#'   cat()
xml_to_md <- function(xml) {
  
  assert_class_any(xml,
                   classes = c("xml_document", "xml_nodeset", "xml_node"),
                   name = "xml")
  assert_pkg("tinkr")
  assert_pkg("xml2")
  assert_pkg("xslt")
  
  xml %>%
    as.character() %>%
    paste0(collapse = "\n") %>%
    # trim whitespace in case `xml` was already of type character
    stringr::str_trim() %>%
    # add CommonMark XML namespace
    purrr::when(stringr::str_detect(string = .,
                                    pattern = "^<document[>\\s]") ~ .,
                ~ paste0('<document xmlns="', as.character(tinkr::md_ns()), '">', ., '</document>')) %>%
    xml2::read_xml() %>%
    # convert XML to CommonMark
    xslt::xml_xslt(stylesheet = xml2::read_xml(tinkr::stylesheet()))
}
```

# R Markdown / knitr

## `build_readme`

```{r}
#' Build `README.Rmd`
#'
#' A simpler, but considerably faster alternative to [devtools::build_readme()] since it doesn't install your package in a temporary library before building the
#' `README.Rmd`. This has the pleasant side effect that, other than the latter function, it also works for `.Rmd` files which aren't part of an \R package.
#' 
#' Note that for public package repositories, it's recommended to use [devtools::build_readme()] since it ensures the `README.Rmd` can be built _reproducibly_,
#' which means all the objects and files it references must be accessible from the repository.
#' 
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#' @param build_index_md Whether to build a separate [pkgdown][pkgdown::pkgdown]-optimized `pkgdown/index.md` alongside `output` (i.e. in the same parent
#'   directory). If `NULL`, it will only be built if the parent directory of `output` [contains a pkgdown configuration file][is_pkgdown_dir]. Note that it will
#'   be built with the \R option `pal.build_readme.is_pkgdown = TRUE`, allowing for conditional content inclusion in `input` â€“ e.g. via the [code chunk
#'   option](https://yihui.org/knitr/options/#code-evaluation) `eval = isTRUE(getOption("pal.build_readme.is_pkgdown"))`.
#' @param env Environment in which code chunks are to be evaluated, e.g. [parent.frame()], [new.env()], or [globalenv()].
#'
#' @return The path to `input` as a character scalar, invisibly.
#' @family rmd_knitr
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md",
                         build_index_md = NULL,
                         env = parent.frame()) {
  # add args to env
  rlang::env_bind(.env = checkmate::assert_environment(env),
                  input = checkmate::assert_string(input),
                  output = checkmate::assert_path_for_output(output,
                                                             overwrite = TRUE),
                  build_index_md = checkmate::assert_flag(build_index_md, null.ok = TRUE))
  
  # add `pkg_metadata` to env
  parent_dir <- fs::path_dir(input) %>% fs::path_abs()
  
  if (is_pkg_dir(parent_dir)) {
    
    assert_pkg("desc")
    
    rlang::env_bind(.env = env,
                    pkg_metadata = desc_list(parent_dir))
  }
  
  status_msg <- "Building {.file {input}}..."
  cli::cli_progress_step(msg = status_msg,
                         msg_done = paste(status_msg, "done"),
                         msg_failed = paste(status_msg, "failed"))
  
  assert_pkg("knitr")
  assert_pkg("rmarkdown")
  
  # generate `output`
  ## render to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = input,
                    output_file = output,
                    quiet = TRUE,
                    envir = env)
  
  # generate `index.md` if indicated
  if (!isFALSE(build_index_md)) {
    
    output_dir <- fs::path_dir(output)
    
    if (is_pkgdown_dir(output_dir)) {
      
      index_md_path <-
        fs::path(output_dir, "pkgdown") %>%
        fs::dir_create() %>%
        fs::path("index.md") %>%
        checkmate::assert_path_for_output(overwrite = TRUE) %>%
        fs::path_abs()
      
      # clean Rmd file
      # TODO: submit PR to pkgdown doing this?
      assert_pkg("brio")
      assert_pkg("withr")
      ## we store the temp file next to `input` since otherwise, knitr won't find relative `child` document paths
      ## cf. https://community.rstudio.com/t/why-doesnt-knitrs-root-dir-option-apply-to-relative-child-document-paths/117563
      tmp_file <-
        fs::path(parent_dir, "tmp-pal-build_readme") %>%
        fs::path_ext_set(ext = fs::path_ext(input)) %>%
        checkmate::assert_path_for_output(.var.name = "tmp_file")
      
      brio::read_file(input) %>%
        # remove possible trailing horizontal line in Rmd file since pkgdown always adds one below content
        stringr::str_replace(pattern = " {0,3}([-\\*_]{3,}|<hr */?>)(\\s*(\\n\\[\\^[\\w-]+\\]:.*\\n?)*$)",
                             replacement = "\\2") %>%
        # remove `align` and `height` <img> tags (rely on custom CSS file `pkgdown/extra.css` instead)
        stringr::str_replace_all(pattern = "(<img [^>]+)(align=['\"].*?['\"]\\s*)",
                                 replacement = "\\1") %>%
        stringr::str_replace_all(pattern = "(<img [^>]+)(height=['\"].*?['\"]\\s*)",
                                 replacement = "\\1") %>%
        brio::write_file(path = tmp_file)
      
      # render `pkgdown/index.md`
      withr::with_options(
        new = list(pal.build_readme.is_pkgdown = TRUE),
        code = rmarkdown::render(input = tmp_file,
                                 output_file = index_md_path,
                                 output_format =
                                   rmarkdown::md_document(variant = "markdown",
                                                          # disable Pandoc extensions in input which rmarkdown only adds for backwards compatibility
                                                          md_extensions = c("-autolink_bare_uris",
                                                                            "-tex_math_single_backslash"),
                                                          pandoc_args = "--columns=9999") %>%
                                   # disable Pandoc's raw attributes in output to have more control over inline HTML
                                   purrr::list_modify(pandoc = list(to = "markdown-raw_attribute")),
                                 knit_root_dir = parent_dir,
                                 quiet = TRUE,
                                 envir = env)
      )
      
      fs::file_delete(tmp_file)
    }
  }
}
```

## `knitr_table_format`

```{r}
#' Determine current knitr table format
#'
#' Determines the current knitr table format based on the \R option
#' [`knitr.table.format`](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html#kable-formats) which can either be set directly to a valid format string or
#' to a function returning one of these strings conditionally.
#'
#' This is basically a convenience wrapper to be able to access the current `knitr.table.format` in a hassle-free way, i.e. it provides the conditional logic to
#' account for the possibility that `knitr.table.format` is set to a function rather than a format string.
#'
#' @param default The knitr table format to fall back to when the \R option `knitr.table.format` is not set. One of
#' `r prose_ls_fn_param(param = "default", fn = knitr_table_format, as_scalar = FALSE) %>% as_md_list()`
#'   
#' See [knitr::kable()]'s `format` argument for details.
#'
#' @return A character scalar.
#' @family rmd_knitr
#' @export
knitr_table_format <- function(default = c("pipe",
                                           "simple",
                                           "html",
                                           "latex",
                                           "rst")) {
  
  allowed_formats <- eval(formals()$default)
  
  opt <- getOption("knitr.table.format")
  result <- opt %||% rlang::arg_match(default)
  
  if (is.function(result)) result <- result()
  
  if (!(result %in% allowed_formats)) {
    
    cli::cli_abort(paste0("R option {.field knitr.table.format} must evaluate to one of ",
                          prose_ls(x = paste0("{.val ", allowed_formats, "}"),
                                   last_separator = " or "),
                          ", but is {.code {deparse1(opt)}}",
                          dplyr::if_else(is.function(opt),
                                         " which evaluates to {.val {result}}",
                                         ""),
                          "."))
  }
  
  result
}
```

## `strip_yaml_header`

```{r}
#' Strip YAML header from R Markdown
#'
#' Extracts the body from R Markdown file content, stripping a possible [YAML metadata 
#' block](https://bookdown.org/yihui/rmarkdown-cookbook/rmarkdown-anatomy.html#yaml-metadata) at the beginning.
#'
#' Note that for the [R Markdown file format](https://rmarkdown.rstudio.com/), the [YAML metadata 
#' block](https://pandoc.org/MANUAL.html#extension-yaml_metadata_block) must occur at the beginning of the document (and there can be only one). Additional
#' whitespace characters (incl. newlines) before the YAML metadata block are allowed.
#'
#' @inheritParams as_line_feed_chr
#' @param rmd The R Markdown file content as a character scalar.
#'
#' @return The body of the R Markdown file as a character vector of lines.
#' @family rmd_knitr
#' @export
#'
#' @examples
#' library(magrittr)
#' 
#' pal::gh_text_file(path = "README.Rmd",
#'                   owner = "salim-b",
#'                   name = "pal") %T>%
#'   pal::strip_yaml_header()
strip_yaml_header <- function(rmd,
                              eol = c("LF", "CRLF", "CR", "LFCR")) {
  
  checkmate::assert_string(rmd)
  
  has_yaml <- grepl(x = rmd,
                    pattern = "^(\\n\\s*)?---\\s*\\n.*(---|...)\\s*\\n")
  
  eol %<>% pal::as_line_feed_chr()
  rmd %<>% stringr::str_split(pattern = eol) %>% magrittr::extract2(1L)
  last_yaml_line_nr <- 0L
  
  if (has_yaml) {
    
    last_yaml_line_nr <-
      rmd %>%
      stringr::str_locate("^---\\s*$") %>%
      tibble::as_tibble() %>%
      tibble::rowid_to_column() %>%
      dplyr::filter(!dplyr::if_any(.fns = is.na)) %$%
      rowid[2L] %>%
      min(rmd %>%
            stringr::str_locate("^\\.{3}\\s*$") %>%
            tibble::as_tibble() %>%
            tibble::rowid_to_column() %>%
            dplyr::filter(!dplyr::if_any(.fns = is.na)) %$%
            rowid[1L],
          na.rm = TRUE)
  }
  
  rmd[(last_yaml_line_nr + 1L):length(rmd)]
}
```

## Output formats

### DESCRIPTION

[Custom R Markdown output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html) which can be used in addition to the [default output
formats](https://bookdown.org/yihui/rmarkdown/output-formats.html).

### `gitlab_document`

TODO:

-   Find out why param [`df_print`](https://bookdown.org/yihui/rmarkdown/html-document.html#data-frame-printing) has no effect (seems to always fall back to
    `"default"`; the same happens for `rmarkdown::github_document()`). Is this a bug?\`

    Setting `df_print = "kable"` should actually produce a [pipe table](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html#kable-formats)...

-   Finish the damn tocr package and switch to it for TOC generation instead of Pandoc's built-in but very limited `--table-of-contents` option!

-   As soon as Pandoc [offers native support for GitLab Flavored Markdown](https://github.com/jgm/pandoc/issues/3977), switching to that will be the next step.

```{r}
#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [`github_document`][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It basically ensures Pandoc is called with a custom set of options optimized for 
#' maximum compatibility with [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' ## Caveats regarding GitLab-Flavored-Markdown-specific features
#'
#' GitLab Flavored Markdown extends the [CommonMark](https://spec.commonmark.org/current/) Markdown specification with a bunch of
#' [special features](https://gitlab.com/help/user/markdown.md#gfm-extends-standard-markdown). To be able to properly make use of them, observe the following
#' points:
#'
#' - For [inline diffs](https://gitlab.com/help/user/markdown.md#inline-diff), only use curly braces (`{}`), not square brackets (`[]`). The latter will be
#'   escaped by Pandoc during conversion and thus not recognized by GitLab as starting/ending an inline diff.
#'
#' - You have to set `smart_punctuation = FALSE` in order to leave certain
#'   [special GitLab references](https://gitlab.com/help/user/markdown.md#special-gitlab-references) (like commit range comparisons) untouched for GitLab to
#'   interpret them correctly.
#'
#'   All the special GitLab references for snippets and labels that start with a tilde (`~`) or a dollar sign (`$`) won't work because these characters will be
#'   escaped by Pandoc during conversion.
#'
#' - The `[[_TOC_]]` tag to let GitLab [generate a table of contents](https://gitlab.com/help/user/markdown.md#table-of-contents) won't work because it will be
#'   escaped by Pandoc during conversion. You can let Pandoc generate the TOC instead by setting `toc = TRUE`.
#'
#' - [Multiline blockquotes](https://gitlab.com/help/user/markdown.md#multiline-blockquote) won't work because the fence delimiters `>>>` will be escaped by
#'   Pandoc during conversion.
#'
#' @param smart_punctuation Whether to enable [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts straight quotes to
#'   curly quotes, `---` to an em-dash (â€”), `--` to an en-dash (â€“), and `...` to ellipses (â€¦). Nonbreaking spaces are inserted after certain abbreviations, such
#'   as `Mr.`.
#' @param parse_emoji_markup Whether to enable [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji markup (e.g.
#'   `:smile:`) as Unicode emoticons.
#' @param toc Include a table of contents (TOC) [automatically generated by Pandoc](https://pandoc.org/MANUAL.html#option--toc). Note that the TOC will be
#'   placed _before_ the README's body, meaning also _before_ the first Markdown header.
#' @param add_footnotes_hr Whether to add a trailing horizontal rule (`---`) to the final Markdown file if it doesn't already end in one and contains footnotes
#'   (currently only checks for Pandoc's [reference-style footnotes](https://pandoc.org/MANUAL.html#footnotes) and not inline footnotes). This improves
#'   readability when the file is rendered on `GitLab.com`.
#' @param autolink_bare_uris Enable the [`autolink_bare_uris` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-autolink_bare_uris) which
#'   makes all absolute URIs into links, even when not surrounded by pointy braces `<...>`.
#' @param tex_math_single_backslash Enable the
#'   [`tex_math_single_backslash` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-tex_math_single_backslash) which causes anything between
#'   `\(` and `\)` to be interpreted as inline TeX math, and anything between `\[` and `\]` to be interpreted as display TeX math. Note: a drawback of this
#'   extension is that it precludes escaping `(` and `[`.
#' @inheritParams rmarkdown::output_format
#' @inheritParams rmarkdown::md_document
#'
#' @return R Markdown output format intended to be fed to [rmarkdown::render()].
#' @family rmd_format
#' @export
#'
#' @examples
#' \donttest{
#' tmp_file <- fs::file_temp()
#' download.file(url = "https://gitlab.com/salim_b/r/pkgs/pal/-/raw/master/Rmd/pal.Rmd",
#'               destfile = tmp_file,
#'               quiet = TRUE)
#'
#' rmarkdown::render(input = tmp_file,
#'                   output_format = pal::gitlab_document(),
#'                   quiet = TRUE) |>
#'   brio::read_lines() |>
#'   length()}
gitlab_document <- function(smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            df_print = "kable",
                            toc = FALSE,
                            toc_depth = 6L,
                            fig_width = 7L,
                            fig_height = 5L,
                            dev = "png",
                            preserve_yaml = FALSE,
                            add_footnotes_hr = TRUE,
                            autolink_bare_uris = FALSE,
                            tex_math_single_backslash = FALSE) {
  assert_pkg("rmarkdown")
  
  # `post_process` fn to ensure MD ends in trailing horizontal rule
  if (checkmate::assert_flag(add_footnotes_hr)) {
    
    ensure_trailing_md_hr <- function(metadata,
                                      input_file,
                                      output_file,
                                      clean,
                                      verbose) {
      assert_pkg("brio")
      
      md <-
        checkmate::assert_file(output_file,
                               access = "w") %>%
        brio::read_file()
      
      # check if file contains footnotes
      if (stringr::str_detect(string = md,
                              pattern = "(\\n\\[\\^[\\w-]+\\]:.*)")) {
        
        # check if there's already a trailing horizontal rule
        if (!stringr::str_detect(string = md,
                                 pattern = " {0,3}([-\\*_]{3,}|<hr */?>)(\\s*(\\n\\[\\^[\\w-]+\\]:.*\\n?)*$)")) {
          
          md %>%
            stringr::str_replace(pattern = "((\\n\\[\\^[\\w-]+\\]:.*\\n?)*$)",
                                 replacement = "\n---\n\\1") %>%
            brio::write_file(path = output_file)
        }
        
      }
      
      output_file
    }
  } else {
    ensure_trailing_md_hr <- NULL
  }
  
  # create rmd output format
  rmarkdown::output_format(
    knitr = rmarkdown::knitr_options_html(fig_width = fig_width,
                                          fig_height = fig_height,
                                          fig_retina = NULL,
                                          keep_md = FALSE,
                                          dev = dev),
    pandoc = rmarkdown::pandoc_options(to =
                                         c("markdown",
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)],
                                           "-smart",
                                           "-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-pandoc_title_block",
                                           "-yaml_metadata_block"[!checkmate::assert_flag(preserve_yaml)]) %>%
                                         paste0(collapse = ""),
                                       from =
                                         c("markdown",
                                           "+autolink_bare_uris"[checkmate::assert_flag(autolink_bare_uris)],
                                           "+tex_math_single_backslash"[checkmate::assert_flag(tex_math_single_backslash)],
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)]) %>%
                                         paste0(collapse = ""),
                                       args = c("--columns=9999",
                                                "--standalone",
                                                "--table-of-contents"[checkmate::assert_flag(toc)],
                                                paste0("--toc-depth=", checkmate::assert_int(toc_depth,
                                                                                             lower = 1L,
                                                                                             upper = 6L))[checkmate::assert_flag(toc)])),
    df_print = df_print,
    pre_knit = NULL,
    post_knit = NULL,
    pre_processor = NULL,
    intermediates_generator = NULL,
    post_processor = ensure_trailing_md_hr,
    on_exit = NULL,
    base_format = NULL
  )
}
```

# GitHub

NOTES:

-   Use the [GitHub GraphQL API Explorer](https://docs.github.com/en/graphql/overview/explorer) to test raw queries like

    ``` graphql
    {
      repository(name: "pal", owner: "salim-b") {
        object(expression: "master:tests") {
          ... on Tree {
            entries {
              path
              type
            }
          }
        }
      }
    }
    ```

-   The documentation about the `expression` argument of the `object` field of the [`Repository` object
    type](https://docs.github.com/en/graphql/reference/objects#repository) says it would accept "a Git revision expression suitable for rev-parse", but more
    specifically only seems to support a `<rev>:<path>` specification and not [`<sha1>` etc.](https://git-scm.com/docs/git-rev-parse#_specifying_revisions)

## DESCRIPTION

Extending the [gh](https://gh.r-lib.org/) package, leveraging [GitHub's GraphQL API](https://docs.github.com/en/graphql).

## `gh_text_file`

Inspiration: <https://gist.github.com/Integralist/9482061#gistcomment-2750049>

```{r}
#' Read in a text file from a GitHub repository
#'
#' Downloads the text file under the specified path from a GitHub repository via [GitHub's GraphQL API
#' v4](https://docs.github.com/en/graphql/overview/about-the-graphql-api) and returns its content as a string.
#'
#' @details
#' Works for both public and private repositories, for the latter you just need to set up a sufficiently authorized [GitHub Personal Access Token
#' (PAT)][gh::gh_token].
#'
#' Note that nothing is returned in case of a [_binary_ file](https://en.wikipedia.org/wiki/Binary_file), as if no file at all existed under the given
#' `path`.
#'
#' @inheritParams gh_dir_ls
#'
#' @return A character scalar, or an empty character vector in case no text file is found under `rev:path`.
#' @family gh
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "pal.Rproj",
#'                   owner = "salim-b",
#'                   name = "pal",
#'                   rev = "HEAD~2") |>
#'   cat()
gh_text_file <- function(path,
                         owner,
                         name,
                         rev = "HEAD") {
  assert_pkg("gh")
  path <- checkmate::assert_string(path) %>% normalize_tree_path()
  checkmate::assert_string(owner)
  checkmate::assert_string(name)
  checkmate::assert_string(rev)
  
  gh::gh_gql(query = 'query ($name: String!, $owner: String!, $expression: String!) {
                        repository(name: $name, owner: $owner) {
                          object(expression: $expression) {
                            ... on Blob {
                              text
                            }
                          }
                        }
                      }',
             variables = list(name = name,
                              owner = owner,
                              expression = glue::glue("{rev}:{path}"))) %>%
    purrr::pluck("data", "repository", "object", "text") %>%
    purrr::when(is.null(.) ~ character(),
                ~ .)
}
```

## `gh_text_files`

Inspiration: <https://gist.github.com/MichaelCurrin/6777b91e6374cdb5662b64b8249070ea>

```{r}
#' Read in text files from a GitHub repository
#'
#' @description
#' Downloads all text files under the specified path from a GitHub repository via [GitHub's GraphQL API
#' v4](https://docs.github.com/en/graphql/overview/about-the-graphql-api) and returns a named character vector with the file paths as names and the file
#' contents as values.
#'
#' This is a simple convenience function combining [gh_dir_ls()] and [gh_text_file()]. 
#'
#' @param recurse Whether or not to also include text files in subfolders of `path`. A logical scalar. Enabling this option may result in many API calls and
#'   thus produce a significant delay.
#' @inheritParams gh_dir_ls
#' @inherit gh_text_file details
#'
#' @return A named character vector of length equal to the number of files found under `rev:path` with the file paths as names and the file contents as
#'   values.
#' @family gh
#' @export
#'
#' @examples
#' pal::gh_text_files(path = "tests",
#'                    owner = "salim-b",
#'                    name = "pal") |>
#'   str()
#' 
#' # you have to opt-in into directory recursion
#' pal::gh_text_files(path = "tests",
#'                    owner = "salim-b",
#'                    name = "pal",
#'                    recurse = TRUE) |>
#'   str()
gh_text_files <- function(path,
                          owner,
                          name,
                          rev = "HEAD",
                          recurse = FALSE) {
  gh_dir_ls(path = path,
            owner = owner,
            name = name,
            rev = rev,
            recurse = recurse,
            incl_dirs = FALSE) %>%
    magrittr::set_names(x = .,
                        value = .) %>%
    purrr::map(gh_text_file,
               owner = owner,
               name = name,
               rev = rev) %>%
    purrr::compact() %>%
    unlist()
}
```

## `gh_dir_ls`

```{r}
#' List files and directories in a GitHub repository
#'
#' Lists file and directory names found under
#' [`rev:path`](https://git-scm.com/docs/revisions#Documentation/revisions.txt-emltrevgtltpathgtemegemHEADREADMEememmasterREADMEem) in a GitHub repository via
#' [GitHub's GraphQL API v4](https://docs.github.com/en/graphql/overview/about-the-graphql-api).
#'
#' Works for both public and private repositories, for the latter you just need to set up a sufficiently authorized [GitHub Personal Access Token
#' (PAT)][gh::gh_token].
#'
#' @param path The path from the repository's root to the desired directory. A [path][fs::fs_path] or character scalar.
#' @param owner The repository owner's GitHub user or organization name. A character scalar.
#' @param name The repository name. A character scalar.
#' @param rev The [Git revision expression](https://git-scm.com/docs/revisions#Documentation/revisions.txt-emltrevgtltpathgtemegemHEADREADMEememmasterREADMEem)
#'   matching the desired Git tree object, e.g. a branch name or another symbolic reference like `"HEAD@{yesterday}"` or `"HEAD~10"`. A character scalar.
#' @param recurse Whether or not to recurse into subdirectories of `path`.
#' @param incl_dirs Whether or not to list directories (and subdirectories if `recurse = TRUE`).
#' @param incl_files Whether or not to list files (also inside subdirectories if `recurse = TRUE`).
#'
#' @return A character vector of paths from the repository root to the files and subdirectories found under `rev:path`.
#' @family gh
#' @export
#'
#' @examples
#' # you can opt-out from directory recursion...
#' pal::gh_dir_ls(owner = "salim-b",
#'                name = "pal",
#'                recurse = FALSE) |>
#'   pal::cat_lines()
#'
#' # ...or list only files...
#' pal::gh_dir_ls(path = "tests",
#'                owner = "salim-b",
#'                name = "pal",
#'                incl_files = FALSE) |>
#'   pal::cat_lines()
#'
#' # ...or directories
#' pal::gh_dir_ls(path = "tests",
#'                owner = "salim-b",
#'                name = "pal",
#'                incl_dirs = FALSE) |>
#'   pal::cat_lines()
gh_dir_ls <- function(path = "",
                      owner,
                      name,
                      rev = "HEAD",
                      recurse = TRUE,
                      incl_dirs = TRUE,
                      incl_files = TRUE) {
  
  assert_pkg("gh")
  path <- checkmate::assert_string(path) %>% normalize_tree_path()
  checkmate::assert_string(owner)
  checkmate::assert_string(name)
  checkmate::assert_string(rev)
  checkmate::assert_flag(recurse)
  checkmate::assert_flag(incl_dirs)
  checkmate::assert_flag(incl_files)
  
  entries <-
    gh::gh_gql(query = 'query($name:String!, $owner:String!, $expression:String!) {
                          repository(name: $name, owner: $owner) {
                            object(expression: $expression) {
                              ... on Tree {
                                entries {
                                  path
                                  type
                                }
                              }
                            }
                          }
                        }',
    variables = list(name = name,
                     owner = owner,
                     expression = glue::glue("{rev}:{path}"))) %>%
    purrr::pluck("data", "repository", "object", "entries")
  
  dirs <-
    entries %>%
    purrr::keep(~ .x$type %in% c("tree")) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "path") %>%
    purrr::flatten_chr()
  
  result <-
    entries %>%
    purrr::keep(~ .x$type %in% c("blob"[incl_files], "tree"[incl_dirs])) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "path") %>%
    purrr::flatten_chr()
  
  if (recurse && length(dirs)) {
    
    result <-
      dirs %>%
      purrr::map(.f = gh_dir_ls,
                 owner = owner,
                 name = name,
                 rev = rev,
                 recurse = TRUE,
                 incl_dirs = incl_dirs,
                 incl_files = incl_files) %>%
      purrr::flatten_chr() %>%
      c(result)
  }
  
  result %>% sort()
}
```

# HTTP

## DESCRIPTION

Extending the [httr](https://httr.r-lib.org/) package that wraps the [curl](https://jeroen.cran.dev/curl/) package.

## `assert_mime_type`

```{r}
#' Assert MIME type
#'
#' Asserts a [response object][httr::response] is of a specific [MIME type](https://en.wikipedia.org/wiki/Media_type). Convenience wrapper around
#' [httr::http_type()].
#'
#' @param response A [response object][httr::response].
#' @param mime_type The expected MIME type, e.g. `"application/json"`. A character scalar.
#' @param msg The message to display in case of an error. `r pkgsnip::param_label("cli_markup_support")` A character scalar.
#' @param msg_suffix An additional string to append to `msg`. `r pkgsnip::param_label("cli_markup_support")`
#'
#' @return `response`, invisibly.
#' @family http
#' @export
#'
#' @examples
#' httr::GET("https://api.github.com/users/salim-b") |>
#'   pal::assert_mime_type("application/json") |>
#'   httr::content()
#' 
#' \dontrun{
#' httr::GET("https://api.github.com/users/salim-b") |> pal::assert_mime_type("text/plain")}
assert_mime_type <- function(response,
                             mime_type,
                             msg = paste0("The response's MIME type is {.val {mime_type_actual}} ",
                                          "but expected was {.val {mime_type}}."),
                             msg_suffix = "") {
  
  checkmate::assert_class(response, "response")
  checkmate::assert_string(mime_type)
  checkmate::assert_string(msg)
  checkmate::assert_string(msg_suffix)
  mime_type_actual <- httr::http_type(response)
  
  if (mime_type_actual != mime_type) {
    cli::cli_abort(paste0(msg, msg_suffix))
  }
  
  invisible(response)
}
```

## `is_http_success`

A shorter way to define a very similar function would be:

``` r
is_http_success <- purrr::possibly(~ !httr::http_error(.x),
                                   otherwise = FALSE)
```

TODO: Figure out if it's really sensible to handle/catch interrupts.

```{r}
#' Test if an HTTP request is successful
#'
#' @description
#' Convenience wrapper around [`!httr::http_error()`][httr::http_error()] that returns
#'
#' - `TRUE` if the specified `url` could be resolved _and_ a [`HEAD`](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) request could
#'   be [successfully completed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes), or
#'
#' - `FALSE` in any other case.
#'
#' @details
#' This function is similar to [RCurl::url.exists()], i.e. it only retrieves the header, no body, but is based on [httr][httr::httr-package] which in turn is
#' based on [curl](https://jeroen.cran.dev/curl/).
#'
#' @param url The HTTP protocol address. The scheme is optional, so both `"google.com"` and `"https://google.com"` will work. A character scalar.
#' @param retries The maximum number of retries of the `HEAD` request in case of an HTTP error. An integer scalar >= `0`. The retries are performed using
#'   exponential backoff and jitter, see [httr::RETRY()] for details.
#' @param quiet Whether or not to suppress the message displaying how long until the next retry in case an HTTP error occurred. A logical scalar. Only relevant
#'   if `retries > 0`.
#'
#' @return A logical scalar.
#' @family http
#' @export
#'
#' @examples
#' pal::is_http_success("goo.gl")
#' pal::is_http_success("https://google.com/")
#' pal::is_http_success("https://google.not/")
#' pal::is_http_success("https://google.not/",
#'                      retries = 2,
#'                      quiet = FALSE)
is_http_success <- function(url,
                            retries = 0L,
                            quiet = TRUE) {
  assert_pkg("httr")
  checkmate::assert_string(url)
  checkmate::assert_count(retries)
  checkmate::assert_flag(quiet)
  
  rlang::with_handlers(!httr::http_error(httr::RETRY(verb = "HEAD",
                                                     url = url,
                                                     times = retries + 1L,
                                                     quiet = quiet)),
                       error = ~ FALSE,
                       interrupt = ~ cli::cli_abort("Terminated by the user"))
}
```

# CLI

## DESCRIPTION

Extending the [cli](https://cli.r-lib.org/) package.

## `cli_qty_lgl`

```{r}
#' [cli](https://cli.r-lib.org/) pluralization helpers for booleans
#'
#' Equivalents to [cli::qty()] and [cli::no()] for a logical input.
#' 
#' If `cnd` evaluates to `TRUE`, the resulting cli quantity is `1`, otherwise `0`. See cli's [pluralization
#' rules](https://cli.r-lib.org/articles/pluralization.html#pluralization-markup-1) for details about how these quantities are interpreted.
#'
#' @param cnd Condition. A logical scalar.
#'
#' @return `0L` or `1L` with the additional class `cli_noprint`.
#' @export
#'
#' @examples
#' cnd <- runif(1L) < 0.5
#' 
#' cli::pluralize(paste0(
#'   "{pal::cli_qty_lgl(cnd)}I think this function ",
#'   "{?comes in handy/is not worth a second of my attention}. Having looked at the rest of the ",
#'   "package, this {?is quite surprising/does not come as a surprise}."
#' ))
#' 
#' cli::pluralize("This function is worth exactly {pal::cli_no_lgl(cnd)} second of my time.")
cli_qty_lgl <- function(cnd) {
  
  structure(as.integer(checkmate::assert_flag(cnd)),
            class = "cli_noprint")
}
```

## `cli_no_lgl`

```{r}
#' @rdname cli_qty_lgl
#' @export
cli_no_lgl <- function(cnd) {
  
  structure(as.integer(checkmate::assert_flag(cnd)),
            class = "cli_no")
}
```

## `cli_process_expr`

TODO:

-   Introduce a param for flexible condition "morphing" (e.g. errors as warnings)

    The class of the condition has to be changed for this before feeding it to `rlang::cnd_signal`.

-   Propose this function upstream?

```{r}
#' Evaluate an expression with [cli](https://cli.r-lib.org/) process indication
#'
#' Convenience wrapper around [cli::cli_process_start()], [cli::cli_process_done()] and [cli::cli_process_failed()].
#'
#' @param expr An expression to be evaluated.
#' @param env Default environment to evaluate `expr`, as well as possible [glue][glue::glue()] expressions within `msg`, in.
#' @inheritParams cli::cli_process_start
#'
#' @return The result of the evaluated `expr`, invisibly.
#' @seealso [cli::cli_progress_step()] which additionally shows the time elapsed within the associated step.
#' @export
#'
#' @examples
#' \donttest{
#' pal::cli_process_expr(Sys.sleep(3L), "Zzzz")}
#'
#' \dontrun{
#' # "russian roulette"
#' msg <- "Spinning the cylinder \U0001F91E â€¦ "
#' pal::cli_process_expr(msg = msg,
#'                       msg_done = paste0(msg, "and pulling the trigger â€“ lucky again. \U0001F60C"),
#'                       msg_failed = paste0(msg, "and pulling the trigger â€“ head blast!"),
#'                       expr = {
#'                         if (interactive()) Sys.sleep(1)
#'                         if (runif(1L) < 0.4) stop("\U0001F92F\u2620")
#'                       })}
cli_process_expr <- function(expr,
                             msg,
                             msg_done = paste(msg, "... done"),
                             msg_failed = paste(msg, "... failed"),
                             msg_class = "alert-info",
                             done_class = "alert-success",
                             failed_class = "alert-danger",
                             env = parent.frame()) {
  checkmate::assert_string(msg,
                           # NOTE: This is necessary since `cli::cli_process_start(msg = "")` throws an error
                           min.chars = 1L)
  checkmate::assert_string(msg_done)
  checkmate::assert_string(msg_failed)
  checkmate::assert_string(msg_class)
  checkmate::assert_string(done_class)
  checkmate::assert_string(failed_class)
  checkmate::assert_environment(env)
  
  # NOTE: We cannot rely on `on_exit = "done"` since in case of an error the on-exit code of this function won't reach execution because we throw the error
  #       using `rlang::cnd_signal(.x)` first.
  status_bar_container_id <- cli::cli_process_start(msg = msg,
                                                    msg_done = msg_done,
                                                    msg_failed = msg_failed,
                                                    msg_class = msg_class,
                                                    done_class = done_class,
                                                    failed_class = failed_class,
                                                    .envir = env)
  
  result <- rlang::with_handlers(.expr = rlang::eval_tidy(expr = {{ expr }},
                                                          env = env),
                                 error = ~ {
                                   cli::cli_process_failed(status_bar_container_id)
                                   rlang::cnd_signal(.x)
                                 })
  
  cli::cli_process_done(status_bar_container_id)
  
  invisible(result)
}
```

# System interaction

## `check_cli`

```{r}
#' Check if CLI tool is available on the system
#'
#' Checks if a CLI tool is found on the system's [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable)) and optionally returns the executable's filesystem
#' path.
#'
#' @param cmd The system command to invoke the CLI tool. A character scalar.
#' @param get_cmd_path Return the filesystem path to the CLI tool. If `FALSE` (the default), a boolean is returned indicating if the CLI tool is found on the
#'   system or not.
#' @param force_which If set to `TRUE`, [Sys.which()], which relies on the system command `which`, will be used instead of `command -v` to determine the
#'   availability of `cmd` on Unix-like systems. On Windows, `Sys.which()` is used in any case. `command -v` is
#'   [generally recommended for bourne-like shells](https://unix.stackexchange.com/q/85249/201803) and therefore is the default on Linux, macOS and other
#'   [Unixes](https://en.wikipedia.org/wiki/Unix-like).
#'
#' @return A logical scalar if `get_cmd_path = FALSE`, otherwise the filesystem [path][fs::path] to the `cmd` executable.
#' @family sys
#' @export
#'
#' @examples
#' pal::check_cli("Rscript")
#'
#' cmd <- ifelse(xfun::is_windows(), "pandoc.exe", "pandoc")
#' pal::check_cli(cmd, get_cmd_path = TRUE)
check_cli <- function(cmd,
                      get_cmd_path = FALSE,
                      force_which = FALSE) {
  
  assert_pkg("xfun")
  checkmate::assert_string(cmd)
  checkmate::assert_flag(get_cmd_path)
  checkmate::assert_flag(force_which)
  
  if (force_which || !xfun::is_unix()) {
    
    result <-
      Sys.which(names = cmd) %>%
      as.character() %>%
      purrr::when(. == "" ~ character(0L),
                  ~ .) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  length(.) == 0L ~ FALSE,
                  ~ TRUE)
  } else {
    
    # define "defused" warning/error handler
    defuse <- function(e) if (get_cmd_path) character(0L) else FALSE
    
    result <-
      rlang::with_handlers(system2(command = "command",
                                   args = c("-v",
                                            cmd),
                                   stdout = get_cmd_path,
                                   stderr = get_cmd_path),
                           warning = defuse,
                           error = defuse) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  isFALSE(.) ~ .,
                  ~ TRUE)
  }
  
  result
}
```

## `path_script`

This function is inspired by an [answer from Stack Overflow user Jerry T](https://stackoverflow.com/a/36777602/7196903).

```{r}
#' Determine file path of executing script
#'
#' Tries to determine the path to the R/Rmd script that this function is called from.
#'
#' @return The file path to the executing script.
#' @family sys
#' @export
path_script <- function() {
  
  assert_pkg("rprojroot")
  assert_pkg("rstudioapi")
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  # Rscript
  if (length(match) > 0L) {
    
    return(normalizePath(sub(needle, "", cmd_args[match])))
  }
  
  # `source()`d via R console
  if (!is.null(sys.frames()[[1L]][["ofile"]])) {
    
    return(normalizePath(sys.frames()[[1L]][["ofile"]]))
    
    # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
  } else if (!is.null(rprojroot::thisfile())) {
    
    return(rprojroot::thisfile())
    
    # RStudio document
  } else {
    
    path <- rstudioapi::getActiveDocumentContext()[["path"]]
    
    if (path != "") {
      return(normalizePath(path))
    }
  }
  
  cli::cli_abort("Couldn't determine script path.")
}
```

## !`run_cli`

TODO!

```{r, purl = FALSE}
run_cli <- function(cmd,
                    ...) {
  
  
}
```

# Miscellaneous

## `assert_class_any`

```{r}
#' Assert an object is member of any of the specified classes
#'
#' @param x The \R object to test.
#' @param classes Class names to check for inheritance. A character vector.
#' @param name Name of the checked object to print in error message in case the assertion fails. A character scalar.
#'
#' @return `x`, invisibly.
#' @export
#'
#' @examples
#' pal::gh_text_file(path = "README.md",
#'                   owner = "salim-b",
#'                   name = "pal") |>
#'   pal::md_to_xml() |>
#'   assert_class_any(classes = c("xml_document", "xml_nodeset", "xml_node"))
assert_class_any <- function(x,
                             classes,
                             name = "x") {
  
  checkmate::assert_character(classes,
                              any.missing = FALSE)
  
  if (!inherits(x = x,
                what = classes)) {
    
    checkmate::assert_string(name)
    classes_actual <- class(x)
    cli::cli_abort(paste0("{.arg {name}} must {cli::qty(classes)} be {?of class/member of any of the classes} ",
                          classes %>% paste0("{.val ", ., "}") %>% pal::prose_ls(last_separator = " or "),
                          ", but is {cli::qty(classes_actual)} of class{?es} {.val {classes_actual}}"))
  }
  
  invisible(x)
}
```

## `capture_print`

```{r}
#' Capture printed console output as string
#'
#' Returns what [`print(x)`][base::print()] would output on the console â€“ if `collapse` is set to anything other than `NULL`, as a character scalar
#' (i.e. a string), otherwise as a character vector of output lines.
#'
#' This is a simple convenience wrapper around [utils::capture.output()]. Note that [ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
#' (e.g. as output by the `print()` methods of tidyverse packages) are included in the result. To remove them, use [cli::ansi_strip()].
#'
#' @param x The \R object of which the output of `print()` is to be captured.
#' @param collapse An optional string for concatenating the results. If `NULL`, a character vector of print lines is returned.
#'
#' @return A character vector if `collapse = NULL`, otherwise a character scalar.
#' @export
#'
#' @examples
#' mtcars |> pal::capture_print()
#' mtcars |> pal::capture_print(collapse = "\n") |> cat()
#' 
#' # to strip ANSI escape sequences, use `cli::ansi_strip()`
#' mtcars |> tibble::as_tibble()
#' 
#' mtcars |>
#'   tibble::as_tibble() |>
#'   pal::capture_print(collapse = "\n") |>
#'   cli::ansi_strip() |>
#'   cat()
capture_print <- function(x,
                          collapse = NULL) {
  
  utils::capture.output(print(x),
                        file = NULL,
                        type = "output",
                        split = FALSE) %>%
    paste0(collapse = collapse)
}
```

## `cols_regex`

TODO:

-   [ ] Remove cosmetic workaround-whitespaces in `@param ...` doc as soon as [roxygen2 issue #1112](https://github.com/r-lib/roxygen2/issues/1112) is fixed.

NOTES:

-   The "real" data in the examples stems from
    [here](https://opendata.swiss/en/dataset/wahlarchiv-des-kantons-zuerich/resource/893a7b0e-e394-4874-a0af-a99fb39358fd).

-   Function has been proposed upstream in [PR #1112](https://github.com/tidyverse/readr/pull/1112) but was
    [rejected](https://github.com/tidyverse/readr/pull/1112#issuecomment-691294787).

```{r}
#' Create [readr][readr::readr-package] column specification using regular expression matching
#'
#' Allows to define a regular expression per desired [column specification object][readr::cols] matching the respective column names.
#'
#' @param ... Named arguments where the names are (Perl-compatible) regular expressions and the values are column objects created by `col_*()`, or their
#'   abbreviated character names (as described in the `col_types` parameter of [readr::read_delim()]). `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param .default Any named columns not matched by any of the regular expressions in `...` will be read with this column type.
#' @param .col_names The column names which should be matched by `...`.
#'
#' @return A [column specification][readr::cols].
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' # for some hypothetical CSV data column names like these ...
#' col_names <- c("VAR1_Text",
#'                "VAR2_Text",
#'                "VAR3_Text_Other",
#'                "VAR1_Code_R1",
#'                "VAR2_Code_R2",
#'                "HAS_R1_Lag",
#'                "HAS_R2_Lag",
#'                "GARBAGEX67",
#'                "GARBAGEY09")
#' 
#' # ... a column spec could be created concisely as follows:
#' col_regex <- list("_Text(_|$)" = "c",
#'                   "_Code(_|$)" = "i",
#'                   "^GARBAGE"  = readr::col_skip())
#' 
#' pal::cols_regex(.col_names = col_names,
#'                 !!!col_regex,
#'                 .default     = "l")
#'
#' # we can parse some real data:
#' raw_data <-
#'   httr::GET(paste0("http://www.web.statistik.zh.ch/ogd/data/",
#'                    "KANTON_ZUERICH_nrw_2019_listen_ergebnisse_gemeinde.csv")) %>%
#'   httr::content(as = "text",
#'                 encoding = "UTF-8")
#'
#' readr::read_csv(file = raw_data,
#'                 col_types = pal::cols_regex("^(Gemeindenamen|Partei)$" = "c",
#'                                             "(?i)anteil" = "d",
#'                                             .default = "i",
#'                                             .col_names = pal::dsv_colnames(raw_data)))
#'
#' # an alternative way to process the same data using `readr::type_convert()`:
#' readr::read_csv(file = raw_data,
#'                 col_types = list(.default = "c")) %>%
#'   readr::type_convert(col_types = pal::cols_regex("^(Gemeindenamen|Partei)$" = "c",
#'                                                   "(?i)anteil" = "d",
#'                                                   .default = "i",
#'                                                   .col_names = colnames(.)))
cols_regex <- function(...,
                       .default = readr::col_character(),
                       .col_names) {
  
  assert_pkg("readr")
  spec <- list()
  patterns <- rlang::list2(...)
  
  if (length(setdiff(names(patterns), "")) < length(patterns)) {
    cli::cli_abort("All column specifications in {.arg ...} must be named by a regular expression.")
  }
  
  for (i in seq_along(patterns)) {
    matched_vars <- grep(x = .col_names,
                         pattern = names(patterns[i]),
                         value = TRUE,
                         perl = TRUE)
    
    spec <- c(spec, structure(rep(list(patterns[[i]]), length(matched_vars)),
                              names = matched_vars))
  }
  
  spec <- c(spec, alist(.default = .default))
  do.call(readr::cols, spec)
}
```

## `order_by`

```{r}
#' Order a vector by another vector
#'
#' @param x The vector to be ordered.
#' @param by The reference vector which `x` will be ordered by.
#'
#' @return A permutation of `x`.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' # generate 100 random letters
#' random_letters <-
#'   letters %>%
#'   magrittr::extract(sample.int(n = 26L,
#'                                size = 100L,
#'                                replace = TRUE)) %T>%
#'   print()
#'
#' # sort the random letters alphabetically
#' random_letters %>% pal::order_by(by = letters)
order_by <- function(x,
                     by) {
  
  x[order(match(x = x, table = by))]
}
```

## `prose_ls_fn_param`

TODO:

-   Write tests for non-character default vals.
-   Wrap `eval(expr = default_vals, envir = env)` in try-catch if necessary (test!).

```{r}
#' List a function's default parameter values in prose-style
#'
#' Extracts the default value(s) of a function's definition and returns it in [prose style listing][prose_ls].
#'
#' This function can be very convenient to avoid duplication in roxygen2 documentation by leveraging [inline \R code
#' evaluation](https://roxygen2.r-lib.org/articles/rd-formatting.html#inline-code) as follows:
#'
#' ```r
#' #' @param some_param Some parameter. One of `r prose_ls_fn_param(param = "some_param", fn = "some_fn")`.
#' some_fn <- function(some_param = c("a", "b", "c")) {
#'   some_param <- rlang::arg_match(some_param)
#'   ...
#' }
#' ```
#'
#' Or to list the possible parameter values formatted as an unnumbered list instead, use the inline code
#' `` `r prose_ls_fn_param(param = "some_param", fn = "some_fn", as_scalar = FALSE) %>% as_md_list()` `` in the example above.
#'
#' # Caveats
#'
#' - This function does not work for [Primitives][base::.Primitive].
#' - [deparse()] is used internally to get a character representation of non-character default values. Therefore all of `deparse()`'s fuzziness also applies to
#'   this function.
#'
#' @param param The parameter name. A character scalar.
#' @param fn A [function][base::function] or a function name (searched for in `env`). See [formals()] for details.
#' @param env The [environment][base::environment] `fn` is defined in. See [formals()] for details.
#' @param as_scalar Whether to return the result as a single string concatenated by `separator` and `last_separator`.
#' @param wrap The string (usually a single character) in which `param`s default values are to be wrapped.
#' @param separator The separator to delimit `param`s default values. Only relevant if `as_scalar = TRUE`.
#' @param last_separator The separator to delimit the second-last and last one of `param`s default values. Only relevant if `as_scalar = TRUE`.
#'
#' @return A character vector. Of length 1 if `as_scalar = TRUE`.
#' @export
#'
#' @examples
#' pal::prose_ls_fn_param(param = ".name_repair",
#'                        fn = tibble::as_tibble) |>
#' pal::cat_lines()
#'
#' pal::prose_ls_fn_param(param = ".name_repair",
#'                        fn = tibble::as_tibble,
#'                        as_scalar = FALSE) |>
#' pal::cat_lines()
prose_ls_fn_param <- function(param,
                              fn = sys.function(sys.parent()),
                              env = parent.frame(),
                              as_scalar = TRUE,
                              wrap = "`",
                              separator = ",",
                              last_separator = " or ") {
  
  checkmate::assert_string(param)
  checkmate::assert_flag(as_scalar)
  
  # turn `fn` into type function if necessary (the same as `formals(fun)` does internally)
  if (is.character(fn)) {
    fn %<>% get(mode = "function",
                envir = env)
  }
  
  if (is.primitive(fn)) cli::cli_abort("Listing parameters of R Primitives is not supported. Sorry.")
  
  default_vals <- formals(fun = fn,
                          envir = env)
  
  if (param %in% names(default_vals)) {
    default_vals <- default_vals[[param]]
  } else {
    fn_name <- deparse1(expr = substitute(fn),
                        backtick = FALSE)
    cli::cli_abort("The function {.fn {fn_name}}` does not have a parameter named {.arg {param}}.")
  }
  
  if (missing(default_vals)) {
    fn_name <- deparse1(expr = substitute(fn),
                        backtick = FALSE)
    cli::cli_abort("{.fn {fn_name}}'s parameter {.arg {param}} does not have a default value.")
  }
  
  # evaluate default param if it results in a character vector
  if (is.language(default_vals)) {
    
    evaluated_default_vals <- rlang::with_handlers(.expr = eval(expr = default_vals,
                                                                envir = env),
                                                   error = ~ NULL)
    
    if (is.character(evaluated_default_vals)) default_vals <- evaluated_default_vals
  }
  
  if (is.character(default_vals)) {
    default_vals %<>% wrap_chr()
  } else {
    default_vals %<>% deparse1(backtick = FALSE,
                               control = c("keepNA",
                                           "keepInteger",
                                           "niceNames",
                                           "showAttributes",
                                           "warnIncomplete"))
  }
  
  if (as_scalar) {
    default_vals %<>% prose_ls(wrap = wrap,
                               separator = separator,
                               last_separator = last_separator)
  } else {
    default_vals %<>% wrap_chr(wrap = wrap)
  }
  
  default_vals
}
```
