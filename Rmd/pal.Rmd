---
editor_options:
  chunk_output_type: console
---

# INTERNAL

## Avoid `R CMD check` notes about undefined global objects used in magrittr pipes

Cf. <https://github.com/tidyverse/magrittr/issues/29#issuecomment-74313262>

```{r}
utils::globalVariables(names = c(".",
                                 "Package"))
```

# Pandoc / Markdown

## Convert dataframe/tibble to Markdown pipe table

```{r}
#' Convert dataframe/tibble to Markdown pipe table
#'
#' This is a simple wrapper around [pander::pandoc.table.return()] with sensible defaults to create a
#' [Markdown pipe table](https://pandoc.org/MANUAL.html#extension-pipe_tables).
#' 
#' # Create tables dynamically in roxygen2 documentation
#' 
#' This function can be useful to create tables inside [roxygen2][roxygen2::roxygen2] documentation programmatically from data using
#' [dynamic R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1).
#' 
#' The inline code
#' 
#' `` `r mtcars %>% head() %>% pipe_table()` ``
#'
#' should produce the following table in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' `r mtcars %>% head() %>% pipe_table()`
#'
#' @param x The dataframe/tibble/matrix to be converted to a pipe table.
#' @param strong_colnames Highlight column names by formatting them `<strong>`. Enabled by default.
#' @param strong_rownames Highlight row names by formatting them `<strong>`. Enabled by default.
#' @inheritParams pander::pandoc.table.return
#' @param ... Additional arguments passed to [pander::pandoc.table.return()].
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' library(magrittr)
#' mtcars %>% head() %>% pipe_table() %>% cat()
pipe_table <- function(x,
                       strong_colnames = TRUE,
                       strong_rownames = TRUE,
                       justify = "left",
                       ...) {
  
  check_dots_named(...,
                   .function = pander::pandoc.table.return,
                   .forbidden = c("t",
                                  "style",
                                  "justify", 
                                  "emphasize.rownames",
                                  "split.tables"))
  
  x %>%
    purrr::when(strong_colnames ~ magrittr::set_colnames(x = .,
                                                         value = pander::pandoc.strong.return(names(.))),
                ~ .) %>%
    pander::pandoc.table.return(style = "rmarkdown",
                                justify = justify,
                                emphasize.rownames = strong_rownames,
                                split.tables = Inf,
                                ...)
}
```

# R Markdown / Knitr

## Build `README.Rmd`

```{r}
#' Build `README.Rmd`
#'
#' This function is a simpler, but considerabily faster alternative to [devtools::build_readme()] since it doesn't install your package in a temporary library
#' before building the `README.Rmd`. This has the pleasant side effect that, other than the latter function, it also works for `.Rmd` files which aren't part
#' of an R package.
#' 
#' Note that for public package repositories it's recommended to use `devtools::build_readme()` since it ensures the `README.Rmd` can be built reproducibly,
#' which means all the objects and files it references must be accessible from the repository.
#' 
#' `r pkgsnippets::md_snippet("rstudio_addin_hint")`
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#' @inheritParams knitr::knit
#' @family rmd_knitr
#'
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md",
                         envir = parent.frame()) {
  
  if (is_pkg_dir()) {
    
    assign(x = "pkg_metadata",
           value = desc::desc_get(desc::desc_fields()),
           envir = envir)
  }
  
  # knit Rmd to md
  knitr::knit(input = checkmate::assert_file(input,
                                             access = "r"),
              output = checkmate::assert_path_for_output(output,
                                                         overwrite = TRUE),
              quiet = TRUE,
              envir = envir)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    output_file = output,
                    quiet = TRUE,
                    envir = envir)
}
```

## Output formats

These are [custom R Markdown output formats](https://bookdown.org/yihui/rmarkdown/new-formats.html) which can be used in addition to the [default output formats](https://bookdown.org/yihui/rmarkdown/output-formats.html).

### `gitlab_document`

TODO:

- Finish the damn tocr package and switch to it for TOC generation instead of Pandoc's built-in but very limited `--table-of-contents` option!

- As soon as Pandoc [offers native support for GitLab Flavored Markdown](https://github.com/jgm/pandoc/issues/3977), switching to that will be the next step.

```{r}
#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [`github_document`][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It basically ensures Pandoc is called with a custom set of options optimized for 
#' maximum compatibility with [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' ## Caveats regarding GitLab-Flavored-Markdown-specific features
#'
#' GitLab Flavored Markdown extends the [CommonMark](https://spec.commonmark.org/current/) Markdown specification with a bunch of
#' [special features](https://gitlab.com/help/user/markdown.md#gfm-extends-standard-markdown). To be able to properly make use of them, observe the following
#' points:
#'
#' - For [inline diffs](https://gitlab.com/help/user/markdown.md#inline-diff), only use curly braces (`{}`), not square brackets (`[]`). The latter will be
#'   escaped by Pandoc during conversion and thus not recognized by GitLab as starting/ending an inline diff.
#'
#' - You have to set `smart_punctuation = FALSE` in order to leave certain
#'   [special GitLab references](https://gitlab.com/help/user/markdown.md#special-gitlab-references) (like commit range comparisons) untouched for GitLab to
#'   interpret them correctly.
#'
#'   All the special GitLab references for snippets and labels that start with a tilde (`~`) or a dollar sign (`$`) won't work because these characters will be
#'   escaped by Pandoc during conversion.
#'
#' - The `[[_TOC_]]` tag to let GitLab [generate a table of contents](https://gitlab.com/help/user/markdown.md#table-of-contents) won't work because it will be
#'   escaped by Pandoc during conversion. You can let Pandoc generate the TOC instead by setting `toc = TRUE`.
#'
#' - [Multiline blockquotes](https://gitlab.com/help/user/markdown.md#multiline-blockquote) won't work because the fence delimiters `>>>` will be escaped by
#'   Pandoc during conversion.
#'
#' @param smart_punctuation Enable [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (â€”), `--` to an en-dash (â€“), and `...` to ellipses (â€¦). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param parse_emoji_markup Enable [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param toc Include a table of contents (TOC) [automatically generated by Pandoc](https://pandoc.org/MANUAL.html#option--toc). Note that the TOC will be
#'   placed _before_ the README's body, meaning also _before_ the first Markdown header.
#' @param autolink_bare_uris Enable the [`autolink_bare_uris` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-autolink_bare_uris) which makes all absolute URIs into links, even when not surrounded by pointy braces `<...>`.
#' @param tex_math_single_backslash Enable the [`tex_math_single_backslash` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-tex_math_single_backslash) which causes anything between `\(` and `\)` to be interpreted as inline TeX math, and anything between `\[` and `\]` to be interpreted as display TeX math. Note: a drawback of this extension is that it precludes escaping `(` and `[`.
#' @inheritParams rmarkdown::output_format
#' @inheritParams rmarkdown::md_document
#'
#' @return R Markdown output format to pass to [rmarkdown::render()].
#' @family rmd_knitr
#' @export
#'
#' @examples
#' \donttest{
#' tmp_file <- fs::file_temp()
#' download.file(url = "https://gitlab.com/salim_b/r/pkgs/pal/-/raw/master/Rmd/pal.Rmd",
#'               destfile = tmp_file)
#'
#' rmarkdown::render(input = tmp_file,
#'                   output_format = pal::gitlab_document())}
gitlab_document <- function(#add_toc = FALSE,
                            smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            df_print = "kable",
                            toc = FALSE,
                            toc_depth = 6L,
                            fig_width = 7L,
                            fig_height = 5L,
                            dev = "png",
                            preserve_yaml = FALSE,
                            autolink_bare_uris = FALSE,
                            tex_math_single_backslash = FALSE) {
  
  rmarkdown::output_format(
    knitr = rmarkdown::knitr_options_html(fig_width = fig_width,
                                          fig_height = fig_height,
                                          fig_retina = NULL,
                                          keep_md = FALSE,
                                          dev = dev),
    pandoc = rmarkdown::pandoc_options(to =
                                         c("markdown",
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)],
                                           "-smart",
                                           "-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-pandoc_title_block",
                                           "-yaml_metadata_block"[!checkmate::assert_flag(preserve_yaml)]) %>%
                                         paste0(collapse = ""),
                                       from =
                                         c("markdown",
                                           "+autolink_bare_uris"[checkmate::assert_flag(autolink_bare_uris)],
                                           "+tex_math_single_backslash"[checkmate::assert_flag(tex_math_single_backslash)],
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)]) %>%
                                         paste0(collapse = ""),
                                       args = c("--atx-headers",
                                                "--columns=9999",
                                                "--standalone",
                                                "--table-of-contents"[checkmate::assert_flag(toc)],
                                                paste0("--toc-depth=", checkmate::assert_int(toc_depth,
                                                                                             lower = 1L,
                                                                                             upper = 6L))[checkmate::assert_flag(toc)])),
    df_print = df_print,
    pre_knit = NULL,
    post_knit = NULL,
    pre_processor = NULL,
    intermediates_generator = NULL,
    post_processor = NULL,
    # on_exit = purrr::when(checkmate::assert_flag(add_toc) ~ tocr::add_toc,
    #                       ~ NULL),
    base_format = NULL
  )
}
```

# R Packages

## Assert a package is installed

There is a similar (but way simpler) function
[`pkgsearch:::needs_packages()`](https://github.com/r-hub/pkgsearch/blob/9c0102e85929f25d23cb4f497ba4f01c3d3c0cd9/R/utils.R#L100-L127) and
[I've asked](https://github.com/r-hub/pkgsearch/issues/102) if there are any plans on standardizing this.

TODO:

- Incorporate code from FA.

- Add additional params `install_source`. Open question: How to best handle multiple pkgs at once if they don't share the install source? Just recycle
  `install_source`?

```{r}
#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together ðŸ¤²."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed!\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    
    invisible(pkg)
  }
}
```

## Get the value from a DESCRIPTION file field, cleaned up and with fallback

TODO: Make PR proposing new `trim` param.

```{r}
#' Get the value from a DESCRIPTION file field, cleaned up and with fallback
#'
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' desc_value(key = "Description",
#'            file = fs::path_package("pal"))
desc_value <- function(key,
                       file = ".") {
  
  desc::desc_get_field(key = key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = file) %>%
    stringr::str_squish()
}
```

## Test if packages are installed

This function [was originally proposed by Stack Overflow user Artem Klevtsov](https://stackoverflow.com/a/38082613/7196903).

```{r}
#' Test if packages are installed
#'
#' This function returns `TRUE` for each `pkg` that is installed on the current system and `FALSE` otherwise.
#'
#' In contrast to [base::require()], it checks if a package is installed without attaching its namespace if so.
#' 
#' In contrast to [rlang::is_installed()], it is fully vectorized, i.e. returns a (named) logical vector of the same length as `pkg`.
#' 
#' It is
#' [considerably faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the
#' commonly used `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_installed(pkg = "tidyverse")
is_installed <- function(pkg) {
  
  pkg %>%
    magrittr::set_names(., .) %>%
    purrr::map_lgl(~ nzchar(system.file(package = .x)))
}
```

## Test if a directory is an R package

```{r}
#' Test if a directory is an R package
#'
#' This is a simple convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that this function will only
#' return `TRUE` for the root of a package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an R package, `FALSE` otherwise.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  rprojroot::is_r_package$testfun[[1]](path = checkmate::assert_directory(path,
                                                                          access = "r"))
}
```

## List a subset of all installed packages

```{r}
#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case Do not distinguish between upper and lower case letters in `pkg`. If `FALSE`, `pkg` is treated case-sensitive.
#' @param as_regex Interpret `pkg` as regular expression(s). If `FALSE`, `pkg` is interpreted literally.
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#' @family rpkgs
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE,
                   as_regex = FALSE) {
  
  regex <-
    checkmate::assert_character(pkg,
                                any.missing = FALSE,
                                min.chars = 1L) %>%
    purrr::when(checkmate::assert_flag(as_regex) ~ .,
                ~ paste0("\\Q", ., "\\E")) %>%
    fuse_regex() %>%
    purrr::when(checkmate::assert_flag(ignore_case) ~ paste0("^(?i)", .),
                ~ paste0("^", .)) %>%
    paste0("$")
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = regex))
}
```

# Spoken language

## List items concatenated in prose-style (..., ... and ...)

```{r}
#' List items concatenated in prose-style (..., ... and ...)
#'
#' This function takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @export
#' @family spoken
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  if (length(x) < 2) {
    paste0(checkmate::assert_string(wrap), x, wrap)
    
  } else {
    paste0(x[-length(x)],
           collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, x[length(x)], wrap)
  }
}
```

# Strings

## Convert to a character scalar (aka string)

```{r}
#' Convert to a character scalar (aka string)
#'
#' This function is like `paste0(..., collapse = TRUE)`, but _recursively_ converts all its elements to type character.
#'
#' @param ... The elements to be assembled to a single string.
#' @param sep The separator to delimit `...`. Defaults to none (`""`).
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' input <-
#'   sample.int(n = 5,
#'              size = 3) %>%
#'   paste0(", ") %>%
#'   purrr::map(rep,
#'              times = 20) %>%
#'   list(c("This is a glut of ", "meaningless numbers: "), .)
#'
#' # while this just converts `input` in a lazy way
#' paste0(input,
#'        collapse = "")
#'
#' # this one works harder
#' as_string(input)
as_string <- function(...,
                      sep = "") {
  
  list(...) %>%
    purrr::map_chr(~ {
      if (purrr::vec_depth(.x) == 1) {
        paste0(as.character(.x), collapse = sep)
      } else {
        paste0(purrr::map_chr(.x,
                              as_string,
                              sep = sep),
               collapse = sep)
      }
    }) %>%
    paste0(collapse = sep)
}
```

## Fuse regex

```{r}
#' Fuse regular expressions
#'
#' Combine a vector or list of regular expressions to a single one (by logical OR).
#'
#' @param ... The regular expressions. All elements will be converted to type character before fusing.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' \donttest{
#' # perform some (nonsense) Jane Austen text extraction
#' regex <- c("My dear Jane",
#'            "make haste, ",
#'            "(?i)\\bevil")
#'
#' stringr::str_subset(string = janeaustenr::prideprejudice,
#'                     pattern = fuse_regex(regex))}
fuse_regex <- function(...) {
  
  paste0("(", as_string(..., sep = "|"), ")")
}
```

## Get column names of a delimiter-separated string

```{r}
#' Get column names of a delimiter-separated string
#'
#' This function returns the column names of a string in a [delimiter-separated-value](https://en.wikipedia.org/wiki/Delimiter-separated_values) format like
#' [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) or [TSV](https://en.wikipedia.org/wiki/Tab-separated_values).
#'
#' @param x The delimiter-separated string. A character scalar.
#' @param delim Single character used to separate fields within `x`.
#' @param quote Single character used to quote strings within `x`. Set to `NULL` for none.
#'
#' @return A character vector of column names.
#' @export
#'
#' @examples
#' \donttest{
#' httr::GET("https://raw.githubusercontent.com/tidyverse/readr/master/inst/extdata/mtcars.csv") %>%
#'   httr::content(as = "text") %>%
#'   pal::dsv_colnames()}
dsv_colnames <- function(x,
                         delim = ",",
                         quote = "\"") {
  x %>%
    regexpr(pattern = "[\r\n]") %>%
    magrittr::subtract(1L) %>%
    substr(x = x,
           start = 1L) %>%
    stringr::str_split(pattern = checkmate::assert_string(delim,
                                                          min.chars = 1L,
                                                          pattern = "^.$")) %>%
    dplyr::first() %>%
    stringr::str_remove_all(pattern = glue::glue("^", checkmate::assert_string(quote,
                                                                                null.ok = TRUE,
                                                                                pattern = "^.$"),
                                                 "|{quote}$"))
}
```

## Print `x` as newline-separated character vector using `cat()`

```{r}
#' Print `x` as newline-separated character vector using [`cat()`][base::cat()].
#' 
#' This is simply a convenience wrapper around [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param x A vector to print.
#'
#' @inherit base::cat return
#' @seealso [xfun::raw_string()], [xfun::file_string()]
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
cat_lines <- function(x) {
  
  cat(as.character(unlist(x)),
      sep = "\n")
}
```

# System interaction

## Check if CLI tool is available on the system

```{r}
#' Check if CLI tool is available on the system
#'
#' This function checks if a CLI tool is found on the system's [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable)) and optionally returns the executable's
#' filesystem path.
#'
#' @param cmd The system command to invoke the CLI tool. A character scalar.
#' @param get_cmd_path Return the filesystem path to the CLI tool. If `FALSE` (the default), a boolean is returned indicating if the CLI tool is found on the
#'   system or not.
#' @param force_which If set to `TRUE`, [Sys.which()], which relies on the system command `which`, will be used instead of `command -v` to determine the
#'   availability of `cmd` on Unix-like systems. On Windows, `Sys.which()` is used in any case. `command -v` is
#'   [generally recommended for bourne-like shells](https://unix.stackexchange.com/q/85249/201803) and therefore is the default on Linux, macOS and other
#'   [Unixes](https://en.wikipedia.org/wiki/Unix-like).
#'
#' @return A logical scalar if `get_cmd_path = FALSE`, otherwise the filesystem [path][fs::path] to the `cmd` executable.
#' @family sys
#' @export
#'
#' @examples
#' check_cli("Rscript")
#'
#' cmd <- ifelse(xfun::is_windows(), "pandoc.exe", "pandoc")
#' check_cli(cmd, get_cmd_path = TRUE)
check_cli <- function(cmd,
                      get_cmd_path = FALSE,
                      force_which = FALSE)
{
  # check argument validity
  checkmate::assert_string(cmd)
  checkmate::assert_flag(get_cmd_path)
  checkmate::assert_flag(force_which)
  
  if (force_which | !xfun::is_unix()) {
    
    Sys.which(names = cmd) %>%
      as.character() %>%
      purrr::when(. == "" ~ character(0),
                  ~ .) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  length(.) == 0 ~ FALSE,
                  ~ TRUE)
    
  } else {
    
    # define "defused" warning/error handler
    defuse <- function(e) if (get_cmd_path) character(0) else FALSE
    
    rlang::with_handlers(system2(command = "command",
                                 args = c("-v",
                                          cmd),
                                 stdout = get_cmd_path,
                                 stderr = get_cmd_path),
                         warning = defuse,
                         error = defuse) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  isFALSE(.) ~ .,
                  ~ TRUE)
  }
}
```

## Determine file path of executing script

This function is inspired by an [answer from Stack Overflow user Jerry T](https://stackoverflow.com/a/36777602/7196903).

```{r}
#' Determine file path of executing script
#'
#' @return The file path to the executing script.
#' @family sys
#' @export
path_script <- function() {
  
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  # Rscript
  if (length(match) > 0L) {
    
    return(normalizePath(sub(needle, "", cmd_args[match])))
  }
  
  # `source()`d via R console
  if (!is.null(sys.frames()[[1L]][["ofile"]])) {
    
    return(normalizePath(sys.frames()[[1L]][["ofile"]]))
    
    # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
  } else if (!is.null(rprojroot::thisfile())) {
    
    return(rprojroot::thisfile())
    
  } else if (is_installed("rstudioapi")) {
    
    path <- normalizePath(rstudioapi::getActiveDocumentContext()[["path"]])
    
    if ( path != "" ) {
      return(path)
    }
  }
  
  rlang::abort("Couldn't determine script path!'")
}
```

# Miscellaneous

## Set an attribute

```{r}
#' Set an attribute
#'
#' This is simply a [pipeable](https://magrittr.tidyverse.org/articles/magrittr.html) version of [`attr(x, which) <- value`][base::attr()]. Unfortunately,
#' [rlang::set_attrs()], a more powerful attribute setter, has been marked deprecated.
#'
#' @param object The object for which an attribute is to be changed.
#' @param attribute The attribute to be changed. A character scalar.
#' @param value The new value for the attribute.
#'
#' @return The `object` with the updated attribute, invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' list(some = "element") %>%
#'   set_attribute(attribute = "custom_attribute",
#'                 value = "foo") %>%
#'   print()
set_attribute <- function(object,
                          attribute,
                          value) {
  attr(x = object,
       which = attribute) <- value
  
  invisible(object)
}
```

# Extending other R packages

These functions are likely to be proposed upstream, and if accepted, will be removed from this package.

## cli

### Evaluate an expression with cli process indication

```{r}
#' Evaluate an expression with cli process indication
#'
#' This is a convenience wrapper around [cli::cli_process_start()], [cli::cli_process_done()] and [cli::cli_process_failed()].
#'
#' @param expr An expression to be evaluated.
#' @param env Environment to evaluate `expr`, as well as possible [glue][glue::glue()] expressions within `msg`, in.
#' @inheritParams cli::cli_process_start
#'
#' @return The result of the evaluated `expr`.
#' @export
#'
#' @examples
#' \donttest{
#' cli_process_expr(Sys.sleep(3L), "Zzzz")}
#'
#' \dontrun{
#' # "russian roulette"
#' msg <- "Spinning the cylinder \U1F91E â€¦ "
#' cli_process_expr(msg = msg,
#'                  msg_done = paste0(msg, "and pulling the trigger â€“ lucky again. \U1F60C"),
#'                  msg_failed = paste0(msg, "and pulling the trigger â€“ head blast!"),
#'                  {
#'                    if (interactive()) Sys.sleep(1)
#'                    if (runif(1L) < 0.4) stop("\U1F92F\U2620")
#'                  })}
cli_process_expr <- function(expr,
                             msg,
                             msg_done = paste(msg, "... done"),
                             msg_failed = paste(msg, "... failed"),
                             msg_class = "alert-info",
                             done_class = "alert-success",
                             failed_class = "alert-danger",
                             env = parent.frame()) {
  
  # NOTE: We cannot rely on `on_exit = "done"` since in case of an error the on-exit code of this function will never be called because we actually throw
  #       the error using `rlang::cnd_signal(.x)`.
  status_bar_container_id <- cli::cli_process_start(msg = msg,
                                                    msg_done = msg_done,
                                                    msg_failed = msg_failed,
                                                    msg_class = msg_class,
                                                    done_class = done_class,
                                                    failed_class = failed_class,
                                                    .envir = env)
  
  rlang::with_handlers(.expr = eval(expr = rlang::enexpr(expr),
                                    envir = env),
                       error = ~ {
                         cli::cli_process_failed(status_bar_container_id);
                         rlang::cnd_signal(.x)
                       })
  
  cli::cli_process_done(status_bar_container_id)
}
```

## ellipsis

### Check that all dot parameter names are a valid subset of a function's parameter names.

**Remarks:**

- Code to suggest proper dots params largely borrowed from `rlang::arg_match()`.

- Function has been proposed upstream in [PR #35](https://github.com/r-lib/ellipsis/pull/35).

```{r}
#' Check that all dot parameter names are a valid subset of a function's parameter names.
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' This function ensures that [dots (...)][base::dots()] are either empty (if `.empty_ok = TRUE`), or all named dot parameter names are a valid subset of a
#' function's parameter names. In case of an invalid or `.forbidden` argument, an informative message is shown and the defined `.action` is taken.
#'
#' @details
#'
#' `check_dots_named()` is intended to combat the second one of the two major downsides that using `...` usually brings. In chapter 6.6 of the book
#' _Advanced R_ it is [phrased](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot) as follows:
#'
#' _Using `...` comes with two downsides:_
#' 
#' - _When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to
#'   understand what you can do with functions like `lapply()` and `plot()`._
#' 
#' - **_A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed._**
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .additional Parameter names within `...` that should be treated as valid in addition to `.function`'s actual parameter names. A character vector.
#' @param .forbidden Parameter names within `...` that should be treated as invalid. This has precedence over `.additional`. A character vector.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of [rlang::abort()], [rlang::warn()], [rlang::inform()] or [rlang::signal()].
#' @export
#'
#' @examples
#' # We can use `check_dots_named()` to address this second downside:
#' sum_safe <- function(...,
#'                      na.rm = FALSE) {
#'   pal::check_dots_named(...,
#'                         .function = sum)
#'   sum(...,
#'       na.rm = na.rm)
#' }
#' 
#' # note how the misspelled `na_rm` (instead of `na.rm`) silently gets ignored
#' # in the original function
#' sum(1, 2, NA, na_rm = TRUE)
#'
#' \dontrun{
#' # whereas our safe version properly errors
#' sum_safe(1, 2, NA, na_rm = TRUE)}
#'
#' # we can even build an `sapply()` function that fails "intelligently" 
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#'
#' \dontrun{
#' # `sapply_safe()` will throw an informative error message
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")}
#'
#' \dontrun{
#' # but be aware that `check_dots_named()` might be a bit rash
#' sum_safe(a = 1, b = 2)}
#'
#' # while the original function actually has nothing to complain
#' sum(a = 1, b = 2)
#'
#' \dontrun{
#' # also, it doesn't play nicely with functions that don't expose all of
#' # their arg names (`to` and `by` in the case of `seq()`)
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             to = 100,
#'             by = 5)}
#'
#' # but providing `to` and `by` *unnamed* is fine of course:
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             100,
#'             5)
check_dots_named <- function(...,
                             .function,
                             .additional = NULL,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (...length()) {
    
    # determine original function name the `...` will be passed on to
    fun_arg_name <- deparse1(substitute(.function))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fun_arg_name %in% parent_param_names) {
      fun_name <- as.character(parent_call[which(parent_param_names == fun_arg_name) + 1][[1]])
    } else {
      fun_name <- fun_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(checkmate::assert_function(.function))
    
    # check named `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = check_dot_named,
                values = dots_param_names,
                allowed_values = setdiff(union(dots_param_names,
                                               checkmate::assert_character(.additional,
                                                                           any.missing = FALSE,
                                                                           null.ok = TRUE)),
                                         checkmate::assert_character(.forbidden,
                                                                     any.missing = FALSE,
                                                                     null.ok = TRUE)),
                fun_name = fun_name,
                action = .action)
    
  } else if (!checkmate::assert_flag(.empty_ok)) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = '`...` must be provided (!= NULL)!')
  }
}

check_dot_named <- function(dot,
                            values,
                            allowed_values,
                            fun_name,
                            action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- glue::glue(dplyr::if_else(is_forbidden,
                                     "Forbidden",
                                     "Invalid"), " argument provided in `...`: `{dot}`\n",
                      .trim = FALSE)
    
    if (length(allowed_values) > 0) {
      
      msg %<>% glue::glue(dplyr::if_else(is_restricted,
                                         "Arguments allowed to pass on to ",
                                         "Valid arguments for "), "`{fun_name}()` include: ", prose_ls(allowed_values, wrap = "`"), "\n",
                          .trim = FALSE)
    } else {
      
      msg %<>% glue::glue("Only unnamed arguments are ", dplyr::if_else(is_restricted, "allowed", "valid"), " for `{fun_name}()`.")
    }
    
    i_partial <- pmatch(dot, allowed_values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values)/nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}
```

## readr

### Create column specification using regular expression matching

**Remarks:**

- Function has been proposed upstream in [PR #1112](https://github.com/tidyverse/readr/pull/1112).

```{r}
#' Create column specification using regular expression matching
#'
#' @description
#'
#' This function allows to define a regular expression per desired [column specification object][readr::cols] matching the respective column names.
#'
#' @param ... Named arguments where the names are (Perl-compatible) regular expressions and the values are column objects created by col_*(), or their
#'   abbreviated character names (as described in the col_types argument of [readr::read_delim()]).
#' @param .default Any named columns not matched by any of the regular expressions in `...` will be read with this column type.
#' @param .col_names The column names which should be matched by `...`.
#'
#' @return A [column specification][readr::cols].
#' @export
#'
#' @examples
#' # some hypothetical CSV data column names
#' cnames <- c("VAR1_Text",
#'             "VAR2_Text",
#'             "VAR3_Text_Other",
#'             "VAR1_Code_R1",
#'             "VAR2_Code_R2",
#'             "HAS_R1_Lag",
#'             "HAS_R2_Lag",
#'             "GARBAGEX67",
#'             "GARBAGEY09")
#' 
#' # create column spec
#' pal::cols_regex(.col_names   = cnames,
#'                 "_Text[_$]" = "c",
#'                 "_Code[_$]" = "i",
#'                 "^GARBAGE"  = readr::col_skip(),
#'                 .default     = "l")
#'
#' # parse example data
#' raw_data <- system.file("extdata/ch_communes_snapshot.csv",
#'                         package = "readr")
#'
#' readr::read_csv(
#'   file = raw_data,
#'   col_types = pal::cols_regex(
#'     "(Name|_Title|_Text|^ABBREV)" = "c",
#'     "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
#'     .default = "i",
#'     .col_names = pal::dsv_colnames(raw_data)
#'   )
#' )
#'
#' # parse example data (alternative way)
#' readr::read_csv(file = raw_data,
#'                 col_types = list(.default = "c")) %>%
#'   readr::type_convert(col_types = pal::cols_regex(
#'     "(Name|_Title|_Text|^ABBREV)" = "c",
#'     "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
#'     .default = "i",
#'     .col_names = colnames(.)
#'   ))
cols_regex <- function(...,
                       .default = readr::col_character(),
                       .col_names) {
  
  if (length(names(list(...))) < ...length()) {
    rlang::abort("All column specifications in `...` must be named by a regular expression.")
  }
  
  patterns <- list(...)
  spec <- list()
  
  for (i in seq_along(patterns)) {
    matched_vars <- grep(x = .col_names,
                         pattern = names(patterns[i]),
                         value = TRUE,
                         perl = TRUE)
    
    spec <- c(spec, structure(rep(list(patterns[[i]]), length(matched_vars)),
                              names = matched_vars))
  }
  
  spec <- c(spec, alist(.default = .default))
  do.call(readr::cols, spec)
}
```

## RSelenium

### ...

```{r}
# assert_package("RSelenium")
```
