# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/pal.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#literate-programming` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c(".",
                                 "Package"))

#' Build `README.Rmd`
#'
#' This function is an preliminary replacement for [devtools::build_readme()] that _works_ with the [`pal::gitlab_document`][pal::gitlab_document()] R Markdown
#' output format.
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#'
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md") {
  
  # knit Rmd to md
  knitr::knit(input = input,
              output = output,
              quiet = TRUE)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    quiet = TRUE)
}

#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [github_document][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It builds upon [md_document][rmarkdown::md_document()] and all of its parameters
#' can be specified except `variant`, `md_extensions` and `pandoc_args`.
#'
#' This output format basically ensures Pandoc is called with a custom set of options optimized for maximum compatibility with
#' [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' @param parse_emoji_markup Setting this to `TRUE` activates [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param smart_punctuation Setting this to `TRUE` activates [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (â€”), `--` to an en-dash (â€“), and `...` to ellipses (â€¦). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param ... Additional arguments passed to [rmarkdown::md_document()].
#'
#' @return R Markdown output format to pass to [rmarkdown::render()].
#' @export
#'
#' @examples
#' \dontrun{
#' rmarkdown::render("input.Rmd", gitlab_document())
#'
#' rmarkdown::render("input.Rmd", gitlab_document(parse_emoji_markup = TRUE,
#'                                                preserve_yaml = TRUE,
#'                                                extension = ".markdown"))
#' }
gitlab_document <- function(smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            ...) {
  pal::check_dots_named(...,
                        .function = rmarkdown::md_document,
                        .forbidden = c("variant", "md_extensions", "pandoc_args"))
  
  rmarkdown::md_document(variant = "markdown",
                         md_extensions = c("-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)],
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)]),
                         pandoc_args = c("--atx-headers",
                                         "--columns=9999"),
                         ...)
}

#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together ðŸ¤²."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed!\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    
    invisible(pkg)
  }
}

#' Test if packages are installed
#'
#' This function returns `TRUE` for each `pkg` that is installed on the current system and `FALSE` otherwise.
#'
#' In contrast to [base::require()], it checks if a package is installed without attaching its namespace if so.
#' 
#' In contrast to [rlang::is_installed()], it is fully vectorized, i.e. returns a (named) logical vector of the same length as `pkg`.
#' 
#' It is
#' [considerably faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the
#' commonly used `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_installed(pkg = "tidyverse")
is_installed <- function(pkg) {
  
  pkg %>%
    magrittr::set_names(., .) %>%
    purrr::map_lgl(~ nzchar(system.file(package = .x)))
}

#' Test if a directory is an R package
#'
#' This is a simple convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that this function will only
#' return `TRUE` for the root of a package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an R package, `FALSE` otherwise.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  rprojroot::is_r_package$testfun[[1]](path = checkmate::assert_directory(path,
                                                                          access = "r"))
}

#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case If `FALSE`, `pkg` is case-sensitive.
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#' @family rpkgs
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE) {
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = paste0(dplyr::if_else(ignore_case, "^(?i)", "^"),
                                                       paste0(pkg,
                                                              collapse = "|"),
                                                       "$")))
}

#' Check that all [dot][base::dots()] parameter names are a valid subset of a function's parameter names.
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .forbidden Parameter names within `...` that should be treated as invalid.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of [rlang::abort()], [rlang::warn()], [rlang::inform()] or [rlang::signal()].
#' @export
#'
#' @examples
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' \dontrun{
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#' # `sapply_safe()` will throw an informative error message:
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#' }
check_dots_named <- function(...,
                             .function,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (length(list(...))) {
    
    names(c(...)) %>%
      setdiff("") %>%
      purrr::walk(.f = assert_dot,
                  values = setdiff(methods::formalArgs(.function),
                                   checkmate::assert_character(.forbidden,
                                                               any.missing = FALSE,
                                                               null.ok = TRUE)),
                  action = .action)
    
  } else if (!.empty_ok) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = '`...` must be provided (!= NULL)!')
  }
}

assert_dot <- function(dot,
                       values,
                       action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, values)
  
  if (rlang::is_na(i)) {
    
    msg <- glue::glue("Invalid argument provided in `...`: `{dot}`\nValid arguments include: ", pal::prose_ls(values, wrap = "`"))
    i_partial <- pmatch(dot, values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, values)/nchar(values)
    
    if (any(i_close <= 0.5)) {
      candidate <- values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- pal::prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}

# assert_package("RSelenium")

#' List items concatenated in prose-style (..., ... and ...)
#'
#' This function takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @export
#' @family spoken
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  if (length(x) < 2) {
    paste0(checkmate::assert_string(wrap), x, wrap)
    
  } else {
    paste0(x[-length(x)],
           collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, x[length(x)], wrap)
  }
}

#' Determine file path of executing script
#'
#' @return The file path to the executing script.
#' @export
script_path <- function() {
  
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  if (length(match) > 0L) {
    # Rscript
    return(normalizePath(sub(needle, "", cmd_args[match])))
    
  } else {
    if (!is.null(sys.frames()[[1L]][["ofile"]])) {
      # `source()`d via R console
      return(normalizePath(sys.frames()[[1L]][["ofile"]]))
      
    } else if (is_installed("rstudioapi")) {
      # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
      return(normalizePath(rstudioapi::getActiveDocumentContext()[["path"]]))

    } else rlang::abort("Couldn't determine script path!'")
  }
}

#' Print `x` as newline-separated character vector using [`cat()`][base::cat()].
#' 
#' This is simply a convenience wrapper around [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param x A vector to print.
#'
#' @inherit base::cat return
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
cat_lines <- function(x) {
  
  cat(as.character(unlist(x)),
      sep = "\n")
}

#' Set an attribute
#'
#' This is simply a [pipeable](https://magrittr.tidyverse.org/articles/magrittr.html) version of [`attr(x, which) <- value`][base::attr()]. Unfortunately,
#' [rlang::set_attrs()], a more powerful attribute setter, has been marked deprecated.
#'
#' @param object The object for which an attribute is to be changed.
#' @param attribute The attribute to be changed. A character scalar.
#' @param value The new value for the attribute.
#'
#' @return The `object` with the updated attribute, invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' list(some = "element") %>%
#'   set_attribute(attribute = "custom_attribute",
#'                 value = "foo") %>%
#'   print()
set_attribute <- function(object,
                          attribute,
                          value) {
  attr(x = object,
       which = attribute) <- value
  
  invisible(object)
}
