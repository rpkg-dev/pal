# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/pal.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#literate-programming` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c(".",
                                 "Package"))

#' Convert dataframe/tibble to Markdown pipe table
#'
#' This is a simple wrapper around [pander::pandoc.table.return()] with sensible defaults to create a
#' [Markdown pipe table](https://pandoc.org/MANUAL.html#extension-pipe_tables).
#' 
#' # Create tables dynamically in roxygen2 documentation
#' 
#' This function can be useful to create tables inside [roxygen2][roxygen2::roxygen2] documentation programmatically from data using
#' [dynamic R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1).
#' 
#' The inline code
#' 
#' `` `r mtcars %>% head() %>% pipe_table()` ``
#'
#' should produce the following table in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' `r mtcars %>% head() %>% pipe_table()`
#'
#' @param x The dataframe/tibble/matrix to be converted to a pipe table.
#' @param strong_colnames Highlight column names by formatting them `<strong>`. Enabled by default.
#' @param strong_rownames Highlight row names by formatting them `<strong>`. Enabled by default.
#' @inheritParams pander::pandoc.table.return
#' @param ... Additional arguments passed to [pander::pandoc.table.return()].
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' library(magrittr)
#' mtcars %>% head() %>% pipe_table() %>% cat()
pipe_table <- function(x,
                       strong_colnames = TRUE,
                       strong_rownames = TRUE,
                       justify = "left",
                       ...) {
  
  check_dots_named(...,
                   .function = pander::pandoc.table.return,
                   .forbidden = c("t",
                                  "style",
                                  "justify", 
                                  "emphasize.rownames",
                                  "split.tables"))
  
  x %>%
    purrr::when(strong_colnames ~ magrittr::set_colnames(x = .,
                                                         value = pander::pandoc.strong.return(names(.))),
                ~ .) %>%
    pander::pandoc.table.return(style = "rmarkdown",
                                justify = justify,
                                emphasize.rownames = strong_rownames,
                                split.tables = Inf,
                                ...)
}

#' Build `README.Rmd`
#'
#' This function is a simpler, but considerabily faster alternative to [devtools::build_readme()] since it doesn't install your package in a temporary library
#' before building the `README.Rmd`. This has the pleasant side effect that, other than the latter function, it also works for `.Rmd` files which aren't part
#' of an R package.
#' 
#' Note that for public package repositories it's recommended to use `devtools::build_readme()` since it ensures the `README.Rmd` can be built reproducibly,
#' which means all the objects and files it references must be accessible from the repository.
#' 
#' `r pkgsnippets::md_snippet("rstudio_addin_hint")`
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#' @inheritParams knitr::knit
#' @family rmd_knitr
#'
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md",
                         envir = parent.frame()) {
  
  if (is_pkg_dir()) {
    
    assign(x = "pkg_metadata",
           value = desc::desc_get(desc::desc_fields()),
           envir = envir)
  }
  
  # knit Rmd to md
  knitr::knit(input = checkmate::assert_file(input,
                                             access = "r"),
              output = checkmate::assert_path_for_output(output,
                                                         overwrite = TRUE),
              quiet = TRUE,
              envir = envir)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    output_file = output,
                    quiet = TRUE,
                    envir = envir)
}

#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [`github_document`][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It basically ensures Pandoc is called with a custom set of options optimized for 
#' maximum compatibility with [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' @param smart_punctuation Enable [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (—), `--` to an en-dash (–), and `...` to ellipses (…). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param parse_emoji_markup Enable [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param toc Include a table of contents (TOC) [automatically generated by Pandoc](https://pandoc.org/MANUAL.html#option--toc). Note that the TOC will be
#'   placed _before_ the README's body, meaning also _before_ the first Markdown header.
#' @param autolink_bare_uris Enable the [`autolink_bare_uris` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-autolink_bare_uris) which makes all absolute URIs into links, even when not surrounded by pointy braces `<...>`.
#' @param tex_math_single_backslash Enable the [`tex_math_single_backslash` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-tex_math_single_backslash) which causes anything between `\(` and `\)` to be interpreted as inline TeX math, and anything between `\[` and `\]` to be interpreted as display TeX math. Note: a drawback of this extension is that it precludes escaping `(` and `[`.
#' @inheritParams rmarkdown::output_format
#' @inheritParams rmarkdown::md_document
#'
#' @return R Markdown output format to pass to [rmarkdown::render()].
#' @family rmd_knitr
#' @export
#'
#' @examples
#' \donttest{
#' tmp_file <- fs::file_temp()
#' download.file(url = "https://gitlab.com/salim_b/r/pkgs/pal/-/raw/master/Rmd/pal.Rmd",
#'               destfile = tmp_file)
#'
#' rmarkdown::render(input = tmp_file,
#'                   output_format = pal::gitlab_document())}
gitlab_document <- function(#add_toc = FALSE,
                            smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            df_print = "kable",
                            toc = FALSE,
                            toc_depth = 6L,
                            fig_width = 7L,
                            fig_height = 5L,
                            dev = "png",
                            preserve_yaml = FALSE,
                            autolink_bare_uris = FALSE,
                            tex_math_single_backslash = FALSE) {
  
  rmarkdown::output_format(
    knitr = rmarkdown::knitr_options_html(fig_width = fig_width,
                                          fig_height = fig_height,
                                          fig_retina = NULL,
                                          keep_md = FALSE,
                                          dev = dev),
    pandoc = rmarkdown::pandoc_options(to =
                                         c("markdown",
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)],
                                           "-smart",
                                           "-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-pandoc_title_block",
                                           "-yaml_metadata_block"[!checkmate::assert_flag(preserve_yaml)]) %>%
                                         paste0(collapse = ""),
                                       from =
                                         c("markdown",
                                           "+autolink_bare_uris"[checkmate::assert_flag(autolink_bare_uris)],
                                           "+tex_math_single_backslash"[checkmate::assert_flag(tex_math_single_backslash)],
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)]) %>%
                                         paste0(collapse = ""),
                                       args = c("--atx-headers",
                                                "--columns=9999",
                                                "--standalone",
                                                "--table-of-contents"[checkmate::assert_flag(toc)],
                                                paste0("--toc-depth=", checkmate::assert_int(toc_depth,
                                                                                             lower = 1L,
                                                                                             upper = 6L))[checkmate::assert_flag(toc)])),
    df_print = df_print,
    pre_knit = NULL,
    post_knit = NULL,
    pre_processor = NULL,
    intermediates_generator = NULL,
    post_processor = NULL,
    # on_exit = purrr::when(checkmate::assert_flag(add_toc) ~ tocr::add_toc,
    #                       ~ NULL),
    base_format = NULL
  )
}

#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together 🤲."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed!\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    
    invisible(pkg)
  }
}

#' Get the value from a DESCRIPTION file field, cleaned up and with fallback
#'
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' desc_value(key = "Description",
#'            file = fs::path_package("pal"))
desc_value <- function(key,
                       file = ".") {
  
  desc::desc_get_field(key = key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = file) %>%
    stringr::str_squish()
}

#' Test if packages are installed
#'
#' This function returns `TRUE` for each `pkg` that is installed on the current system and `FALSE` otherwise.
#'
#' In contrast to [base::require()], it checks if a package is installed without attaching its namespace if so.
#' 
#' In contrast to [rlang::is_installed()], it is fully vectorized, i.e. returns a (named) logical vector of the same length as `pkg`.
#' 
#' It is
#' [considerably faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the
#' commonly used `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_installed(pkg = "tidyverse")
is_installed <- function(pkg) {
  
  pkg %>%
    magrittr::set_names(., .) %>%
    purrr::map_lgl(~ nzchar(system.file(package = .x)))
}

#' Test if a directory is an R package
#'
#' This is a simple convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that this function will only
#' return `TRUE` for the root of a package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an R package, `FALSE` otherwise.
#' @export
#' @family rpkgs
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  rprojroot::is_r_package$testfun[[1]](path = checkmate::assert_directory(path,
                                                                          access = "r"))
}

#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case If `FALSE`, `pkg` is case-sensitive.
#'
#' @return A [tibble][tibble::tbl_df].
#' @export
#' @family rpkgs
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE) {
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = paste0(dplyr::if_else(ignore_case, "^(?i)", "^"),
                                                       paste0(pkg,
                                                              collapse = "|"),
                                                       "$")))
}

#' List items concatenated in prose-style (..., ... and ...)
#'
#' This function takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @export
#' @family spoken
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  if (length(x) < 2) {
    paste0(checkmate::assert_string(wrap), x, wrap)
    
  } else {
    paste0(x[-length(x)],
           collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, x[length(x)], wrap)
  }
}

#' Convert to a character scalar (aka string)
#'
#' This function is like `paste0(..., collapse = TRUE)`, but _recursively_ converts all its elements to type character.
#'
#' @param ... The elements to be assembled to a single string.
#' @param sep The separator to delimit `...`. Defaults to none (`""`).
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' input <-
#'   sample.int(n = 5,
#'              size = 3) %>%
#'   paste0(", ") %>%
#'   purrr::map(rep,
#'              times = 20) %>%
#'   list(c("This is a glut of ", "meaningless numbers: "), .)
#'
#' # while this just converts `input` in a lazy way
#' paste0(input,
#'        collapse = "")
#'
#' # this one works harder
#' as_string(input)
as_string <- function(...,
                      sep = "") {
  
  list(...) %>%
    purrr::map_chr(~ {
      if (purrr::vec_depth(.x) == 1) {
        paste0(as.character(.x), collapse = sep)
      } else {
        paste0(purrr::map_chr(.x,
                              as_string,
                              sep = sep),
               collapse = sep)
      }
    }) %>%
    paste0(collapse = sep)
}

#' Fuse regular expressions
#'
#' Combine a vector or list of regular expressions to a single one (by logical OR).
#'
#' @param ... The regular expressions. All elements will be converted to type character before fusing.
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' \donttest{
#' # perform some (nonsense) Jane Austen text extraction
#' regex <- c("My dear Jane",
#'            "make haste, ",
#'            "(?i)\\bevil")
#'
#' stringr::str_subset(string = janeaustenr::prideprejudice,
#'                     pattern = fuse_regex(regex))}
fuse_regex <- function(...) {
  
  paste0("(", as_string(..., sep = "|"), ")")
}

#' Get column names of a delimiter-separated string
#'
#' This function returns the column names of a string in a [delimiter-separated-value](https://en.wikipedia.org/wiki/Delimiter-separated_values) format like
#' [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) or [TSV](https://en.wikipedia.org/wiki/Tab-separated_values).
#'
#' @param x The delimiter-separated string. A character scalar.
#' @param delim Single character used to separate fields within `x`.
#' @param quote Single character used to quote strings within `x`. Set to `NULL` for none.
#'
#' @return A character vector of column names.
#' @export
#'
#' @examples
#' httr::GET("https://raw.githubusercontent.com/tidyverse/readr/master/inst/extdata/mtcars.csv") %>%
#'   httr::content(as = "text") %>%
#'   pal::dsv_colnames()
dsv_colnames <- function(x,
                         delim = ",",
                         quote = "\"") {
  x %>%
    regexpr(pattern = "[\r\n]") %>%
    magrittr::subtract(1L) %>%
    substr(x = x,
           start = 1L) %>%
    stringr::str_split(pattern = checkmate::assert_string(delim,
                                                          min.chars = 1L,
                                                          pattern = "^.$")) %>%
    dplyr::first() %>%
    stringr::str_remove_all(pattern = glue::glue("^", checkmate::assert_string(quote,
                                                                                null.ok = TRUE,
                                                                                pattern = "^.$"),
                                                 "|{quote}$"))
}

#' Print `x` as newline-separated character vector using [`cat()`][base::cat()].
#' 
#' This is simply a convenience wrapper around [`cat()`][base::cat()], mainly intended for interactive use.
#'
#' @param x A vector to print.
#'
#' @inherit base::cat return
#' @seealso [xfun::raw_string()], [xfun::file_string()]
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
cat_lines <- function(x) {
  
  cat(as.character(unlist(x)),
      sep = "\n")
}

#' Determine file path of executing script
#'
#' @return The file path to the executing script.
#' @export
path_script <- function() {
  
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  # Rscript
  if (length(match) > 0L) {
    
    return(normalizePath(sub(needle, "", cmd_args[match])))
    
  }
  
  # `source()`d via R console
  if (!is.null(sys.frames()[[1L]][["ofile"]])) {
    
    return(normalizePath(sys.frames()[[1L]][["ofile"]]))
    
    # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
  } else if (!is.null(rprojroot::thisfile())) {
    
    rprojroot::thisfile()
    
  } else if (is_installed("rstudioapi")) {
    
    path <- normalizePath(rstudioapi::getActiveDocumentContext()[["path"]])
    
    if ( path != "" ) {
      return(path)
    }
  }
  
  rlang::abort("Couldn't determine script path!'")
}

#' Set an attribute
#'
#' This is simply a [pipeable](https://magrittr.tidyverse.org/articles/magrittr.html) version of [`attr(x, which) <- value`][base::attr()]. Unfortunately,
#' [rlang::set_attrs()], a more powerful attribute setter, has been marked deprecated.
#'
#' @param object The object for which an attribute is to be changed.
#' @param attribute The attribute to be changed. A character scalar.
#' @param value The new value for the attribute.
#'
#' @return The `object` with the updated attribute, invisibly.
#' @export
#'
#' @examples
#' library(magrittr)
#'
#' list(some = "element") %>%
#'   set_attribute(attribute = "custom_attribute",
#'                 value = "foo") %>%
#'   print()
set_attribute <- function(object,
                          attribute,
                          value) {
  attr(x = object,
       which = attribute) <- value
  
  invisible(object)
}

#' Check that all dot parameter names are a valid subset of a function's parameter names.
#'
#' This function ensures that [dots (...)][base::dots()] are either empty (if `.empty_ok = TRUE`), or all named dot parameter names are a valid subset of a
#' function's parameter names. In case of an invalid or `.forbidden` argument, an informative message is shown and the defined `.action` is taken.
#'
#' `check_dots_named()` is intended to combat the second one of the two major downsides that using `...` usually brings. In chapter 6.6 of the book
#' _Advanced R_ it is [phrased](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot) as follows:
#'
#' _Using `...` comes with two downsides:_
#' 
#' - _When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to
#'   understand what you can do with functions like `lapply()` and `plot()`._
#' 
#' - **_A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed._**
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .additional Parameter names within `...` that should be treated as valid in addition to `.function`'s actual parameter names. A character vector.
#' @param .forbidden Parameter names within `...` that should be treated as invalid. This has precedence over `.additional`. A character vector.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of [rlang::abort()], [rlang::warn()], [rlang::inform()] or [rlang::signal()].
#' @export
#'
#' @examples
#' # We can use `check_dots_named()` to address this second downside:
#' sum_safe <- function(...,
#'                      na.rm = FALSE) {
#'   pal::check_dots_named(...,
#'                         .function = sum)
#'   sum(...,
#'       na.rm = na.rm)
#' }
#' 
#' # note how the misspelled `na_rm` (instead of `na.rm`) silently gets ignored
#' # in the original function
#' sum(1, 2, NA, na_rm = TRUE)
#'
#' \dontrun{
#' # whereas our safe version properly errors
#' sum_safe(1, 2, NA, na_rm = TRUE)}
#'
#' # we can even build an `sapply()` function that fails "intelligently" 
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#'
#' \dontrun{
#' # `sapply_safe()` will throw an informative error message
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")}
#'
#' \dontrun{
#' # but be aware that `check_dots_named()` might be a bit rash
#' sum_safe(a = 1, b = 2)}
#'
#' # while the original function actually has nothing to complain
#' sum(a = 1, b = 2)
#'
#' \dontrun{
#' # also, it doesn't play nicely with functions that don't expose all of
#' # their arg names (`to` and `by` in the case of `seq()`)
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             to = 100,
#'             by = 5)}
#'
#' # but providing `to` and `by` *unnamed* is fine of course:
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             100,
#'             5)
check_dots_named <- function(...,
                             .function,
                             .additional = NULL,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (...length()) {
    
    # determine original function name the `...` will be passed on to
    fun_arg_name <- deparse1(substitute(.function))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fun_arg_name %in% parent_param_names) {
      fun_name <- as.character(parent_call[which(parent_param_names == fun_arg_name) + 1][[1]])
    } else {
      fun_name <- fun_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(checkmate::assert_function(.function))
    
    # check named `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = check_dot_named,
                values = dots_param_names,
                allowed_values = setdiff(union(dots_param_names,
                                               checkmate::assert_character(.additional,
                                                                           any.missing = FALSE,
                                                                           null.ok = TRUE)),
                                         checkmate::assert_character(.forbidden,
                                                                     any.missing = FALSE,
                                                                     null.ok = TRUE)),
                fun_name = fun_name,
                action = .action)
    
  } else if (!checkmate::assert_flag(.empty_ok)) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = '`...` must be provided (!= NULL)!')
  }
}

check_dot_named <- function(dot,
                            values,
                            allowed_values,
                            fun_name,
                            action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- glue::glue(dplyr::if_else(is_forbidden,
                                     "Forbidden",
                                     "Invalid"), " argument provided in `...`: `{dot}`\n",
                      .trim = FALSE)
    
    if (length(allowed_values) > 0) {
      
      msg %<>% glue::glue(dplyr::if_else(is_restricted,
                                         "Arguments allowed to pass on to ",
                                         "Valid arguments for "), "`{fun_name}()` include: ", prose_ls(allowed_values, wrap = "`"), "\n",
                          .trim = FALSE)
    } else {
      
      msg %<>% glue::glue("Only unnamed arguments are ", dplyr::if_else(is_restricted, "allowed", "valid"), " for `{fun_name}()`.")
    }
    
    i_partial <- pmatch(dot, allowed_values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values)/nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}

#' Create column specification using regular expression matching
#'
#' This function allows to define a regular expression per desired
#' [column specification object][readr::cols] matching the respective column
#' names.
#'
#' @param ... Named arguments where the names are (Perl-compatible) regular
#'   expressions and the values are column objects created by col_*(), or
#'   their abbreviated character names (as described in the col_types argument
#'   of [readr::read_delim()]).
#' @param .default Any named columns not matched by any of the regular
#'   expressions in `...` will be read with this column type.
#' @param .col_names The column names which should be matched by `...`.
#'
#' @return A [column specification][readr::cols].
#' @export
#'
#' @examples
#' # some hypothetical CSV data column names
#' cnames <- c("VAR1_Text",
#'             "VAR2_Text",
#'             "VAR3_Text_Other",
#'             "VAR1_Code_R1",
#'             "VAR2_Code_R2",
#'             "HAS_R1_Lag",
#'             "HAS_R2_Lag",
#'             "GARBAGEX67",
#'             "GARBAGEY09")
#' 
#' # create column spec
#' pal::cols_regex(.col_names   = cnames,
#'                 "_Text[_$]" = "c",
#'                 "_Code[_$]" = "i",
#'                 "^GARBAGE"  = readr::col_skip(),
#'                 .default     = "l")
#'
#' # parse example data
#' raw_data <- system.file("extdata/ch_communes_snapshot.csv",
#'                         package = "readr")
#'
#' readr::read_csv(
#'   file = raw_data,
#'   col_types = pal::cols_regex(
#'     "(Name|_Title|_Text|^ABBREV)" = "c",
#'     "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
#'     .default = "i",
#'     .col_names = pal::dsv_colnames(raw_data)
#'   )
#' )
#'
#' # parse example data (alternative way)
#' readr::read_csv(file = raw_data,
#'                 col_types = list(.default = "c")) %>%
#'   readr::type_convert(col_types = pal::cols_regex(
#'     "(Name|_Title|_Text|^ABBREV)" = "c",
#'     "^(MutationDate|ValidFrom|ValidTo)$" = readr::col_date(format = "%d.%m.%Y"),
#'     .default = "i",
#'     .col_names = colnames(.)
#'   ))
cols_regex <- function(...,
                       .default = readr::col_character(),
                       .col_names) {
  
  if (length(names(list(...))) < ...length()) {
    rlang::abort("All column specifications in `...` must be named by a regular expression.")
  }
  
  patterns <- list(...)
  spec <- list()
  
  for (i in seq_along(patterns)) {
    matched_vars <- grep(x = .col_names,
                         pattern = names(patterns[i]),
                         value = TRUE,
                         perl = TRUE)
    
    spec <- c(spec, structure(rep(list(patterns[[i]]), length(matched_vars)),
                              names = matched_vars))
  }
  
  spec <- c(spec, alist(.default = .default))
  do.call(readr::cols, spec)
}

# assert_package("RSelenium")
