# DO NOT EDIT THIS FILE BY HAND! Instead edit the R Markdown source file `Rmd/pal.Rmd` and run `pkgpurl::purl_rmd()`.
# See `README.md#r-markdown-format` for more information on the literature programming approach used applying the R Markdown format.

utils::globalVariables(names = c(".",
                                 "end",
                                 "everything",
                                 "i_pattern",
                                 "minus",
                                 "Package",
                                 "plus",
                                 "start",
                                 "where"))

unicode_ellipsis <- "\u2026"

as_line_feed_chr <- function(eol = c("LF", "CRLF", "CR", "LFCR")) {
  
  switch(EXPR = rlang::arg_match(eol),
         LF = "\n",
         CRLF = "\r\n",
         CR = "\r",
         LFCR = "\n\r")
}

# dark background colors that are easy on the eyes
bg_red_dark <- cli::make_ansi_style("#330000",
                                    bg = TRUE,
                                    colors = 2L^24L)

bg_green_dark <- cli::make_ansi_style("#003300",
                                      bg = TRUE,
                                      colors = 2L^24L)

#' Determine the differences between two data frames/tibbles in tabular diff format
#'
#' Compares two [data frames][base::data.frame()]/[tibbles][tibble::tibble()] (or two objects coercible to tibbles like
#' [matrices][base::matrix()]) and offers to inspect any differences in [tabular diff format](https://paulfitz.github.io/daff-doc/spec.html) as neatly rendered
#' HTML.
#'
#' This function is basically a convenience wrapper combining [is_equal_df()], [daff::diff_data()] and [daff::render_diff()]. If run non-interactively or
#' `ask = FALSE`, the differences will be shown right away, otherwise the user will be asked on the console.
#'
#' Note that in tabular diff format only changes in the _column content_ of `x` and `y` are visible, meaning that the following properties and changes
#' therein won't be displayed:
#'
#' - column types (e.g. integer vs. double)
#' - row names and other attributes
#'
#' @param x The data frame / tibble to check for changes.
#' @param y The data frame / tibble that `x` should be checked against, i.e. the reference.
#' @param ignore_order Whether or not to ignore the order of columns and rows.
#' @param ids A character vector of column names that make up a [primary key](https://en.wikipedia.org/wiki/Primary_key), if known. If `NULL`, heuristics are
#'   used to find a decent key (or a set of decent keys).
#' @param ask Whether to ask interactively if the resulting difference object should be opened in case `x` and `y` differ. If `FALSE`, it will be opened right
#'   away. Only relevant if run [interactively][base::interactive()].
#' @param bypass_rstudio_viewer If `TRUE`, `x` and `y` actually differ, and `ask` is set to `TRUE`, the resulting difference object will be
#'   opened in the system's default web browser instead of RStudio's built-in viewer. Only relevant if run within RStudio.
#' @param verbose Whether or not to also output the differences detected by [is_equal_df()] to the console.
#' @param max_diffs The maximum number of differences shown on the console. Only relevant if `verbose = TRUE`.
#' @param caption The caption of the rendered difference object. It is passed to [glue::glue()] allowing its string interpolation syntax to be used. A character
#'   scalar.
#' @param diff_text The text to display on the console in case `x` and `y` differ. It is passed to [glue::glue()] allowing its string interpolation syntax to be
#'   used. A character scalar.
#' @param ask_text The text that is displayed when `ask = TRUE`. Ignored if `ask = FALSE`. A character scalar.
#' @param ... Further arguments passed on to [daff::diff_data()], excluding `data`, `data_ref`, `ids`, `ordered`, and `columns_to_ignore`.
#' @inheritParams is_equal_df
#'
#' @return A difference object which can be rendered later using [daff::render_diff()], invisibly.
#' @family tibble
#' @export
#'
#' @examples
#' \dontrun{
#' mtcars %>%
#'   dplyr::mutate(dplyr::across(c(cyl, gear),
#'                               ~ dplyr::if_else(. > 4, . * 2, .))) %>%
#'   show_diff(mtcars)}
show_diff <- function(x,
                      y,
                      ignore_order = FALSE,
                      ignore_col_types = FALSE,
                      ids = NULL,
                      ask = TRUE,
                      bypass_rstudio_viewer = FALSE,
                      verbose = TRUE,
                      max_diffs = 10L,
                      diff_text = "{x_lbl} is different from {y_lbl}",
                      ask_text = "Do you wish to display the changes in tabular diff format?",
                      caption = "{x_lbl} vs. {y_lbl}",
                      ...) {
  
  checkmate::assert_character(ids,
                              any.missing = FALSE,
                              null.ok = TRUE)
  checkmate::assert_string(diff_text)
  checkmate::assert_string(ask_text)
  checkmate::assert_string(caption)
  checkmate::assert_flag(ignore_order)
  checkmate::assert_flag(ask)
  checkmate::assert_flag(bypass_rstudio_viewer)
  assert_pkg("daff")
  
  check_dots_named(...,
                   .function = daff::diff_data,
                   .forbidden = c("data",
                                  "data_ref",
                                  "ids",
                                  "ordered",
                                  "columns_to_ignore"))
  
  # generate `x`/`y` labels
  x_lbl <- deparse(substitute(x))
  y_lbl <- deparse(substitute(y))
  
  if (length(x_lbl) > 1L || x_lbl == "." || make.names(x_lbl) != x_lbl) {
    x_lbl <- "`x`"
  } else x_lbl <- glue::glue("`x` (`{x_lbl}`)")
  
  if (length(y_lbl) > 1L || y_lbl == "." || make.names(y_lbl) != y_lbl) {
    y_lbl <- "`y`"
  } else y_lbl <- glue::glue("`y` (`{y_lbl}`)")
  
  # generate HTML caption
  caption %<>% glue::glue()
  n_backtick <- caption %>% stringr::str_count(pattern = "`")
  
  if (n_backtick) {
    
    caption %<>%
      purrr::reduce(.x = 1:n_backtick,
                    .init = .,
                    .f = function(string, i) {
                      
                      stringr::str_replace(string = string,
                                           pattern = "`",
                                           replacement = dplyr::if_else(i %% 2L == 0L,
                                                                        "</code>",
                                                                        "<code>"))
                    })
  }
  
  daff_obj <- daff::diff_data(data = x,
                              data_ref = y,
                              ids = ids,
                              ordered = !ignore_order)
  
  diff <- is_equal_df(x = x,
                      y = y,
                      ignore_col_order = ignore_order,
                      ignore_row_order = ignore_order,
                      ignore_col_types = ignore_col_types,
                      quiet = TRUE,
                      return_waldo_compare = TRUE)
  
  if (length(diff)) {
    
    assert_pkg("cli")
    
    if (verbose) {
      cli::cli_alert_info(text = paste0(diff_text, ":"))
      cat("\n")
      print(diff)
      
    } else {
      cli::cli_alert_info(text = paste0(diff_text, "."))
    }
    
    open_diff <- TRUE
    
    if (ask) {
      assert_pkg("yesno")
      cat("\n")
      open_diff <- yesno::yesno2(ask_text)
    }
    
    if (open_diff) {
      
      if (interactive()) {
        
        if (bypass_rstudio_viewer) {
          assert_pkg("withr")
          withr::with_options(new = list(viewer = NULL),
                              code = daff::render_diff(diff = daff_obj,
                                                       view = TRUE,
                                                       title = caption))
        } else {
          daff::render_diff(diff = daff_obj,
                            view = TRUE,
                            title = caption)
        }
      } else {
        
        assert_pkg("xopen")
        tmp_file <- fs::file_temp(pattern = "pal_show_diff",
                                  ext = "html")
        
        daff::render_diff(diff = daff_obj,
                          file = tmp_file,
                          view = FALSE,
                          title = caption)
        
        xopen::xopen(target = glue::glue("file://{tmp_file}"),
                     quiet = TRUE)
        cli::cli_alert_info("A new tab displaying the changes has been opened in your default web browser.")
      }
    }
  }
  
  invisible(daff_obj)
}

#' Determine if two data frames/tibbles are equal
#'
#' Compares two [data frames][base::data.frame()]/[tibbles][tibble::tibble()] (or two objects coercible to tibbles like [matrices][base::matrix()]), optionally
#' ignoring row and column ordering, and returns `TRUE` if both are equal, or `FALSE` otherwise. If the latter is the case and `quiet = FALSE`, information
#' about detected differences is printed to the console.
#'
#' Under the hood, this function relies on [waldo::compare()].
#'
#' @param x,y Two data frames/tibbles to compare. `y` is treated as the reference object, so messages describe how `x` is different to `y`.
#' @param ignore_col_order Whether or not to ignore the order of columns.
#' @param ignore_row_order Whether or not to ignore the order of rows.
#' @param ignore_col_types Whether or not to distinguish similar column types. Currently, if set to `TRUE`, this will convert factor to character and integer to
#'   double before comparison.
#' @param quiet Whether or not to output detected differences between `x` and `y` to the console.
#' @param max_diffs The maximum number of differences shown. Only relevant if `quiet = FALSE` or `return_waldo_compare = TRUE`. Set `max_diffs = Inf` to see all
#'   differences.
#' @param return_waldo_compare Whether to return a character vector of class [`waldo_compare`][waldo::compare] describing the differences between `x` and `y`
#'   instead of `TRUE` or `FALSE`.
#' @inheritParams waldo::compare
#'
#' @return If `return_waldo_compare = FALSE`, a logical scalar indicating the result of the comparison. Otherwise a character vector of class
#'   [`waldo_compare`][waldo::compare] describing the differences between `x` and `y`.
#' @family tibble
#' @export
#'
#' @examples
#' scramble <- function(x) x[sample(nrow(x)), sample(ncol(x))]
#'
#' # by default, ordering of rows and columns matters ...
#' is_equal_df(x = mtcars,
#'             y = scramble(mtcars))
#'
#' # ... but those can be ignored if desired
#' is_equal_df(x = mtcars,
#'             y = scramble(mtcars),
#'             ignore_col_order = TRUE)
#' is_equal_df(x = mtcars,
#'             y = scramble(mtcars),
#'             ignore_row_order = TRUE)
#'
#' # by default, `is_equal_df()` is sensitive to column type differences ...
#' df1 <- data.frame(x = "a",
#'                   stringsAsFactors = FALSE)
#' df2 <- data.frame(x = factor("a"))
#' is_equal_df(df1, df2)
#'
#' # ... but you can request it to not make a difference between similar types
#' is_equal_df(df1, df2,
#'             ignore_col_types = TRUE)
is_equal_df <- function(x,
                        y,
                        ignore_col_order = FALSE,
                        ignore_row_order = FALSE,
                        ignore_col_types = FALSE,
                        tolerance = NULL,
                        quiet = TRUE,
                        max_diffs = 10L,
                        return_waldo_compare = FALSE) {
  
  assert_pkg("waldo")
  checkmate::assert_flag(return_waldo_compare)
  
  # convert `x` and `y` to tibble if any modification is required
  if (checkmate::assert_flag(ignore_col_order) | checkmate::assert_flag(ignore_row_order) | checkmate::assert_flag(ignore_col_types)) {
    
    x %<>% tibble::as_tibble()
    y %<>% tibble::as_tibble()
  }
  
  # sort columns if necessary
  if (ignore_col_order) {
    
    x %<>% dplyr::select(sort(colnames(.)))
    y %<>% dplyr::select(sort(colnames(.)))
  }
  
  # sort rows if necessary
  if (ignore_row_order) {
    
    x %<>% dplyr::arrange(dplyr::across(.cols = everything()))
    y %<>% dplyr::arrange(dplyr::across(.cols = everything()))
  }
  
  # harmonize column types if necessary
  if (ignore_col_types) {
    
    x %<>% dplyr::mutate(dplyr::across(.cols = where(is.factor),
                                       .fns = as.character),
                         dplyr::across(.cols = where(is.integer),
                                       .fns = as.double))
    y %<>% dplyr::mutate(dplyr::across(.cols = where(is.factor),
                                       .fns = as.character),
                         dplyr::across(.cols = where(is.integer),
                                       .fns = as.double))
  }
  
  result <- waldo::compare(x = x,
                           y = y,
                           tolerance = tolerance,
                           x_arg = "x",
                           y_arg = "y",
                           max_diffs = max_diffs)
  
  if (length(result)) {
    
    if (!checkmate::assert_flag(quiet)) {
      
      cli::cli_alert_info(text = "`x` differs from `y`:")
      cat("\n")
      print(result)
    }
    
    if (!return_waldo_compare) result <- FALSE
    
  } else if (!return_waldo_compare) {
    result <- TRUE
  }
  
  result
}

#' Temporary helpers for `dplyr::filter()`
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' These are transitional convenience functions that help to combine multiple [`across()`][dplyr::across()] statements in dplyr's [`filter()`](dplyr::filter()).
#' See the examples.
#'
#' @details
#'
#' `any_cols()` is functionally identical to the `rowAny()` helper function suggested in dplyr's [`"colwise"`
#' vignette](https://dplyr.tidyverse.org/articles/colwise.html#how-do-you-convert-existing-code) but [performs slightly
#' better](https://github.com/tidyverse/dplyr/issues/4770#issuecomment-704285294) (and has a more intuitive name when used with `dplyr::filter()`).
#'
#' @param x A data frame or tibble containing numeric, complex, integer or **logical** values.
#'
#' @return A logical vector that's equal to the result of [all()] (in case of `all_cols()`) or [any()] (in case of `any_cols()`) for each row of `x`.
#' @family tibble
#' @export
#'
#' @examples
#' # keep all rows where either `vs` and `am` is greater zero *or* `gear` and `carb` is greater two
#' mtcars %>% dplyr::filter(pal::all_cols(dplyr::across(one_of("vs", "am"), ~ .x > 0))
#'                          | pal::all_cols(dplyr::across(one_of("gear", "carb"), ~ .x > 2)))
#'
#' # keep all rows where *any* numeric variable is exactly 1
#' mtcars %>% dplyr::filter(pal::any_cols(dplyr::across(where(is.numeric), ~ .x == 1L)))
all_cols <- function(x) {
    purrr::reduce(x, `&`, .init = TRUE)
}

#' @rdname all_cols
#' @export
any_cols <- function(x) {
    purrr::reduce(x, `|`, .init = FALSE)
}

#' Open as temporary spreadsheet
#'
#' Writes an \R object -- usually tabular data like a dataframe or [tibble][tibble::tibble()] -- to a temporary spreadsheet and subsequently opens that
#' spreadsheet in the system's default application using [xopen::xopen()]. The latter is usually equivalent to double-clicking on the file in a file browser.
#'
#' @param x A dataframe or [tibble][tibble::tibble()], or something coercible to.
#' @param format The spreadsheet format to use. One of
#'   - `"csv"` for a [comma-separated values](https://en.wikipedia.org/wiki/Comma-separated_values) file written using [readr::write_csv()]. The default.
#'   - `"xlsx"` for an [Office Open XML](https://en.wikipedia.org/wiki/Office_Open_XML) file commonly used by Microsoft Excel 2007+, written using
#'     [writexl::write_xlsx()].
#' @param quiet Whether or not to echo the command to open the temporary spreadsheet on the console before running it.
#'
#' @return `x` invisibly.
#' @family tibble
#' @export
#'
#' @examples
#' \dontrun{
#' open_as_tmp_spreadsheet(mtcars,
#'                         format = "xslx")}
open_as_tmp_spreadsheet <- function(x,
                                    format = c("csv", "xlsx"),
                                    quiet = TRUE) {
  assert_pkg("xopen")
  format <- rlang::arg_match(format)
  tmp_file <- fs::file_temp(pattern = "tmp_spreadsheet",
                            ext = format)
  
  if (format == "csv") {
    
    assert_pkg("readr")
    readr::write_csv(x = x,
                     file = tmp_file)
    
  } else if (format == "xlsx") {
    
    assert_pkg("writexl")
    writexl::write_xlsx(x = x,
                        path = tmp_file)
  }
  
  xopen::xopen(target = tmp_file,
               quiet = quiet)
  
  invisible(x)
}

#' Reduce a nested list of data frames / tibbles to a single tibble
#'
#' Recursively reduces a nested list containing data frames / tibbles at its leafs to a single tibble.
#'
#' @param x A list containing data frames / tibbles at its leafs.
#' @param strict Ensure `x` contains data frames / tibbles only and throw an error otherwise. If `FALSE`, leafs containing other objects are ignored (skipped).
#'
#' @return `r pkgsnip::return_label("data")`
#' @export
reduce_df_list <- function(x,
                           strict = TRUE) {
  
  if (tibble::is_tibble(x) | is.data.frame(x)) {
    
    return(x)
    
  } else if (purrr::vec_depth(x) < 2L) {
    
    if (checkmate::assert_flag(strict)) {
      rlang::abort("At least one element of the list to be reduced is not a data frame / tibble!")
      
    } else return(NULL)
    
  } else purrr::map_dfr(.x = x,
                        .f = reduce_df_list,
                        strict = strict)
}

#' Convert to a flat list
#'
#' @description
#' Similar to [unlist()], i.e. it _recursively_ flattens a list. But unlike `unlist()`, it
#'
#' - always returns a list, i.e. wraps `x` in a list if necessary, and will never remove the last list level. Thus it is
#'   [type-safe](https://en.wikipedia.org/wiki/Type_safety).
#'
#' - won't treat any of the list leafs specially (like `unlist()` does with factors). Thus leaf values will never be modified.
#'
#' - removes list names. `unlist()` concatenates nested names (separated by a dot).
#'
#' @param x `r pkgsnip::param_label("r_object")`
#' @param keep_attrs Keep [attributes][base::attr()] (and thereby retain list structure of custom objects). A logical scalar.
#' @param attrs_to_drop Attribute names which should never be kept. Only relevant if `keep_attrs = TRUE`. A character vector.
#'
#' @return A [list][base::list()].
#' @export
#'
#' @examples
#' nested_list <- list(1:3, list("foo", list("bar"))) %T>% str()
#' 
#' # unlike `unlist()` which also removes the last list tier in many cases ...
#' unlist("foobar")
#' unlist(nested_list) %>% str()
#' # ... this function always returns an (unnested) list
#' as_flat_list("foobar") %>% str()
#' as_flat_list(nested_list) %>% str()
#' 
#' nested_list <- list(list(factor("a"), factor("b")), factor("c")) %T>% str()
#' 
#' # unlike `unlist()` which combines factors ...
#' unlist(nested_list) %>% str()
#' # ... this function does not modify the list elements
#' as_flat_list(nested_list) %>% str()
#' 
#' nested_list <-
#'   list(c(list(1L), list(tibble::tibble(a = list(1.1, "2")))),
#'        list(tibble::as_tibble(mtcars[1:2, ]))) %T>%
#'   str()
#' nested_list_2 <- list(1:3, xfun::strict_list(list(list("buried deep")))) %T>% str()
#'
#' # by default, attributes and thus custom objects (except `xfun_strict_list`) are retained, i.e.
#' # not flattened ...
#' as_flat_list(nested_list) %>% str()
#' as_flat_list(nested_list_2) %>% str()
#' # ... but you can drop them and thereby flatten custom objects if needed ...
#' as_flat_list(nested_list, keep_attrs = FALSE) %>% str()
#' # ... or retain `xfun_strict_list`s, too
#' as_flat_list(nested_list_2, attrs_to_drop = NULL) %>% str()
as_flat_list <- function(x,
                         keep_attrs = TRUE,
                         attrs_to_drop = "xfun_strict_list") {
  
  regard_attrs <- checkmate::assert_flag(keep_attrs) & length(setdiff(attributes(x),
                                                                      checkmate::assert_character(attrs_to_drop,
                                                                                                  any.missing = FALSE,
                                                                                                  null.ok = TRUE)))
  depth <- purrr::vec_depth(x)
  
  # wrap `x` in a list if it's not
  if (regard_attrs | depth < 2L) {
    result <- list(x)
    
    # return `x` as-is if it is an unnested list
  } else if (depth < 3L) {
    result <- x
    
    # flatten the two last list levels (keeping attributes if requested)
  } else if (depth < 4L) {
    result <- x %>% purrr::when(keep_attrs ~ rm_list_level(.,
                                                           attrs_to_drop = attrs_to_drop),
                                ~ purrr::flatten(.))
  } else {
    
    # recursively feed the elements of `x` to this function and flatten the two last list levels (keeping attributes if requested)
    result <-
      x %>%
      purrr::map(.f = as_flat_list,
                 keep_attrs = keep_attrs,
                 attrs_to_drop = attrs_to_drop) %>%
      purrr::when(keep_attrs ~ rm_list_level(.,
                                             attrs_to_drop = attrs_to_drop),
                  ~ purrr::flatten(.))
  }
  
  result
}

rm_list_level <- function(x,
                          attrs_to_drop = "xfun_strict_list") {
  
  result <- list()
  
  for (i in seq_along(checkmate::assert_list(x))) {
    
    regard_attrs <- length(setdiff(attributes(x[[i]]), attrs_to_drop))
    
    if (!regard_attrs & purrr::vec_depth(x[[i]]) > 1L) {
      result %<>% c(x[[i]])
    } else {
      result %<>% c(list(x[[i]]))
    }
  }
  
  result
}

#' Convert a character vector to a Markdown list
#'
#' Convenience wrapper around [pander::pandoc.list.return()] to convert a character vector (or something coercible to) to a [Markdown
#' list](https://pandoc.org/MANUAL.html#lists).
#'
#' @param x The character vector to be converted to a Markdown list.
#' @param type The Markdown list type. One of
#'   - `"unordered"` for an unordered aka [bullet list](https://pandoc.org/MANUAL.html#bullet-lists). Corresponds to `<ul>` in HTML.
#'   - `"ordered"` for an ordered aka [numbered list](https://pandoc.org/MANUAL.html#ordered-lists). Corresponds to `<ol>` in HTML.
#'   - `"ordered_roman"` for a variation of an ordered/numbered list with uppercase roman numerals instead of Arabic numerals as list markers.
#' @param tight Whether or not to add additional spacing between list items.
#' @param indent_lvl The level of indentation of the resulting Markdown list. For each level, four additional spaces are added in front of every list item. An
#'   integer scalar.
#' @param wrap An optional string to wrap the list items in.
#'
#' @return A character scalar.
#' @family md
#' @export
#'
#' @examples
#' rownames(mtcars) %>% as_md_list() %>% cat()
as_md_list <- function(x,
                       type = c("unordered", "ordered", "ordered_roman"),
                       tight = TRUE,
                       indent_lvl = 0L,
                       wrap = NULL) {
  
  type <- rlang::arg_match(type)
  checkmate::assert_flag(tight)
  checkmate::assert_count(indent_lvl)
  checkmate::assert_string(wrap,
                           null.ok = TRUE)
  assert_pkg("pander")
  
  pander::pandoc.list.return(elements = paste0(wrap, as_chr(x), wrap),
                             style = switch(EXPR = type,
                                            unordered = "bullet",
                                            ordered = "ordered",
                                            ordered_roman = "roman"),
                             loose = !tight,
                             indent.level = indent_lvl,
                             add.line.breaks = FALSE,
                             add.end.of.list = FALSE)
}

#' Convert dataframe/tibble to Markdown pipe table
#'
#' Convenience wrapper around [`knitr::kable(format = "pipe")`][knitr::kable()] to create a [Markdown pipe
#' table](https://pandoc.org/MANUAL.html#extension-pipe_tables).
#' 
#' # Create tables dynamically in roxygen2 documentation
#' 
#' This function can be useful to create tables inside [roxygen2][roxygen2::roxygen2] documentation programmatically from data using
#' [dynamic \R code](https://roxygen2.r-lib.org/articles/rd-formatting.html#dynamic-r-code-1).
#' 
#' The inline code
#' 
#' `` `r mtcars %>% head() %>% pipe_table()` ``
#'
#' should produce the following table in [roxygen2 7.1.0](https://www.tidyverse.org/blog/2020/03/roxygen2-7-1-0/) and above:
#'
#' `r mtcars %>% head() %>% pipe_table()`
#'
#' @inherit knitr::kable details
#'
#' @param x The dataframe/tibble/matrix to be converted to a pipe table.
#' @param incl_rownames Whether to include row names or not. A logical scalar or `NULL`. If `NULL`, row names are included if `rownames(x)` is neither `NULL`
#'   nor identical to `seq_len(nrow(x))`.
#' @param strong_colnames Highlight column names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param strong_rownames Highlight row names by formatting them `<strong>` (wrapping them in two asterisks).
#' @param align Column alignment. Either `NULL` for auto-alignment or a character vector consisting of `'l'` (left), `'c'` (center) and/or `'r'` (right). If
#'   `align = NULL`, numeric columns are right-aligned, and other columns are left-aligned. If `length(align) == 1L`, the string will be expanded to a vector
#'   of individual letters, e.g. `'clc'` becomes `c('c', 'l', 'c')`.
#' @param format_args A list of arguments to be passed to [format()] to format table values, e.g. `list(big.mark = ',')`.
#' @inheritParams knitr::kable
#'
#' @return A character vector.
#' @family md
#' @export
#'
#' @examples
#' mtcars %>% head() %>% pipe_table() %>% cat_lines()
pipe_table <- function(x,
                       incl_rownames = NULL,
                       strong_colnames = TRUE,
                       strong_rownames = TRUE,
                       align = NULL,
                       label = NULL,
                       digits = getOption("digits"),
                       format_args = list()) {
  
  assert_pkg("knitr")
  checkmate::assert_flag(incl_rownames,
                         null.ok = TRUE)
  
  # format rownames <strong> if requested and sensible
  if ((isTRUE(incl_rownames) && !is.null(rownames(x))) ||
      (is.null(incl_rownames) && !identical(rownames(x), as.character(seq_len(nrow(x)))))) {
    
    rownames(x) %<>% paste0("**", ., "**")
  }
  
  kable_args <-
    alist(x = x,
          format = "pipe",
          digits = digits,
          row.names = ifelse(is.null(incl_rownames),
                             NA,
                             incl_rownames),
          col.names = colnames(x) %>% purrr::when(checkmate::assert_flag(strong_colnames) ~ paste0("**", ., "**"),
                                                  ~ .),
          label = label,
          format.args = format_args) %>%
    purrr::when(!is.null(align) ~ c(., alist(align = align)),
                ~ .)
  
  do.call(what = knitr::kable,
          args = kable_args)
}

#' Strip Markdown formatting from character vector
#'
#' Removes all Markdown formatting from a character vector.
#'
#' This function relies on [commonmark::markdown_text()] which [supports the CommonMark specification plus the Github
#' extensions](https://github.com/jeroen/commonmark#readme). Unfortunately, [Markdown footnotes](https://pandoc.org/MANUAL.html#footnotes) aren't supported
#' (yet). Therefore a separate option `strip_footnotes` is offered which relies on a simple regular expression to remove inline footnotes and footnote
#' references.
#'
#' @param x A character vector to strip Markdown formatting from.
#' @param strip_footnotes Whether to remove Markdown footnotes, too.
#'
#' @return A character vector of the same length as `x`.
#' @export
#'
#' @examples
#' strip_md("A **MD** formatted [string](https://en.wikipedia.org/wiki/String_(computer_science))")
#'
#' # link references are only removed *iff* the reference is included in `x`:
#' strip_md("[A reference link][refid]\n\n[refid]: https://example.com")
#' strip_md("[A reference link][refid]\n\n_No ref here..._")
strip_md <- function(x,
                     strip_footnotes = TRUE) {
  
  assert_pkg("commonmark")
  
  purrr::map_chr(.x = x,
                 .f = ~ .x %>% purrr::when(is.na(.) ~ .,
                                           ~ commonmark::markdown_text(text = .,
                                                                       extensions = TRUE) %>%
                                             stringr::str_remove(pattern = "\n$") %>%
                                             purrr::when(strip_footnotes ~ stringr::str_remove_all(string = .,
                                                                                                   pattern = "(\\[\\^.+?\\]|\\^\\[.+?\\])"),
                                                         ~ .)))
}

#' Build `README.Rmd`
#'
#' A simpler, but considerably faster alternative to [devtools::build_readme()] since it doesn't install your package in a temporary library before building the
#' `README.Rmd`. This has the pleasant side effect that, other than the latter function, it also works for `.Rmd` files which aren't part of an \R package.
#' 
#' Note that for public package repositories it's recommended to use `devtools::build_readme()` since it ensures the `README.Rmd` can be built _reproducibly_,
#' which means all the objects and files it references must be accessible from the repository.
#' 
#' `r pkgsnip::md_snip("rstudio_addin_hint")`
#'
#' @param input The path to the R Markdown README file to be built. A character scalar.
#' @param output The path of the built Markdown README. A character scalar.
#' @param env Environment in which code chunks are to be evaluated, e.g. [parent.frame()], [new.env()], or [globalenv()].
#'
#' @return The path to `input` as a character scalar, invisibly.
#' @family rmd_knitr
#' @export
build_readme <- function(input = "README.Rmd",
                         output = "README.md",
                         env = parent.frame()) {
  
  assert_pkg("knitr")
  assert_pkg("rmarkdown")
  
  if (is_pkg_dir()) {
    
    assert_pkg("desc")
    
    assign(x = "pkg_metadata",
           value = desc::desc_get(desc::desc_fields()),
           envir = env)
  }
  
  # knit Rmd to md
  knitr::knit(input = checkmate::assert_file(input,
                                             access = "r"),
              output = checkmate::assert_path_for_output(output,
                                                         overwrite = TRUE),
              quiet = TRUE,
              envir = env)
  
  # render the md to the output format specified in the YAML header (defaults to `rmarkdown::md_document`)
  rmarkdown::render(input = output,
                    output_file = output,
                    quiet = TRUE,
                    envir = env)
}

#' Determine current knitr table format
#'
#' Determines the current knitr table format based on the \R option
#' [`knitr.table.format`](https://bookdown.org/yihui/rmarkdown-cookbook/kable.html#kable-formats) which can either be set directly to a valid format string or
#' to a function returning one of these strings conditionally.
#'
#' This is basically a convenience wrapper to be able to access the current `knitr.table.format` in a hassle-free way, i.e. it provides the conditional logic to
#' account for the possibility that `knitr.table.format` is set to a function rather than a format string.
#'
#' @param default The knitr table format to fall back to when the \R option `knitr.table.format` is not set. One of
#'   `r prose_ls_fn_param(param = "default", fn = knitr_table_format, as_scalar = FALSE) %>% as_md_list()`
#'   
#' See [knitr::kable()]'s `format` argument for details.
#'
#' @return A character scalar.
#' @export
knitr_table_format <- function(default = c("pipe",
                                           "simple",
                                           "html",
                                           "latex",
                                           "rst")) {
  
  allowed_formats <- eval(formals()$default)
  
  result <- getOption("knitr.table.format",
                      default = rlang::arg_match(default))
  
  if (is.function(result)) result <- result()
  
  if (!(result %in% allowed_formats)) {
    rlang::abort(paste0("Invalid R option `knitr.table.format`. Must evaluate to one of ",
                        prose_ls(x = wrap_chr(allowed_formats),
                                 wrap = "`",
                                 last_separator = " or ")))
  }
  
  result
}

#' Convert to GitLab Flavored Markdown
#'
#' Format for converting from R Markdown to [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' This is the GitLab equivalent to the [`github_document`][rmarkdown::github_document()] R Markdown
#' [output format](https://bookdown.org/yihui/rmarkdown/output-formats.html). It basically ensures Pandoc is called with a custom set of options optimized for 
#' maximum compatibility with [GitLab Flavored Markdown](https://gitlab.com/help/user/markdown.md).
#'
#' ## Caveats regarding GitLab-Flavored-Markdown-specific features
#'
#' GitLab Flavored Markdown extends the [CommonMark](https://spec.commonmark.org/current/) Markdown specification with a bunch of
#' [special features](https://gitlab.com/help/user/markdown.md#gfm-extends-standard-markdown). To be able to properly make use of them, observe the following
#' points:
#'
#' - For [inline diffs](https://gitlab.com/help/user/markdown.md#inline-diff), only use curly braces (`{}`), not square brackets (`[]`). The latter will be
#'   escaped by Pandoc during conversion and thus not recognized by GitLab as starting/ending an inline diff.
#'
#' - You have to set `smart_punctuation = FALSE` in order to leave certain
#'   [special GitLab references](https://gitlab.com/help/user/markdown.md#special-gitlab-references) (like commit range comparisons) untouched for GitLab to
#'   interpret them correctly.
#'
#'   All the special GitLab references for snippets and labels that start with a tilde (`~`) or a dollar sign (`$`) won't work because these characters will be
#'   escaped by Pandoc during conversion.
#'
#' - The `[[_TOC_]]` tag to let GitLab [generate a table of contents](https://gitlab.com/help/user/markdown.md#table-of-contents) won't work because it will be
#'   escaped by Pandoc during conversion. You can let Pandoc generate the TOC instead by setting `toc = TRUE`.
#'
#' - [Multiline blockquotes](https://gitlab.com/help/user/markdown.md#multiline-blockquote) won't work because the fence delimiters `>>>` will be escaped by
#'   Pandoc during conversion.
#'
#' @param smart_punctuation Enable [Pandoc's `smart` extension](https://pandoc.org/MANUAL.html#extension-smart) which converts
#'   straight quotes to curly quotes, `---` to an em-dash (â€”), `--` to an en-dash (â€“), and `...` to ellipses (â€¦). Nonbreaking spaces are inserted after certain
#'   abbreviations, such as `Mr.`.
#' @param parse_emoji_markup Enable [Pandoc's `emoji` extension](https://pandoc.org/MANUAL.html#extension-emoji) which parses emoji
#'   markup (e.g. `:smile:`) as Unicode emoticons.
#' @param toc Include a table of contents (TOC) [automatically generated by Pandoc](https://pandoc.org/MANUAL.html#option--toc). Note that the TOC will be
#'   placed _before_ the README's body, meaning also _before_ the first Markdown header.
#' @param autolink_bare_uris Enable the [`autolink_bare_uris` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-autolink_bare_uris) which
#'   makes all absolute URIs into links, even when not surrounded by pointy braces `<...>`.
#' @param tex_math_single_backslash Enable the
#'   [`tex_math_single_backslash` Pandoc Markdown extension](https://pandoc.org/MANUAL.html#extension-tex_math_single_backslash) which causes anything between
#'   `\(` and `\)` to be interpreted as inline TeX math, and anything between `\[` and `\]` to be interpreted as display TeX math. Note: a drawback of this
#'   extension is that it precludes escaping `(` and `[`.
#' @inheritParams rmarkdown::output_format
#' @inheritParams rmarkdown::md_document
#'
#' @return R Markdown output format intended to be fed to [rmarkdown::render()].
#' @family rmd_knitr
#' @export
#'
#' @examples
#' \donttest{
#' tmp_file <- fs::file_temp()
#' download.file(url = "https://gitlab.com/salim_b/r/pkgs/pal/-/raw/master/Rmd/pal.Rmd",
#'               destfile = tmp_file)
#'
#' rmarkdown::render(input = tmp_file,
#'                   output_format = pal::gitlab_document())}
gitlab_document <- function(#add_toc = FALSE,
                            smart_punctuation = TRUE,
                            parse_emoji_markup = FALSE,
                            df_print = "kable",
                            toc = FALSE,
                            toc_depth = 6L,
                            fig_width = 7L,
                            fig_height = 5L,
                            dev = "png",
                            preserve_yaml = FALSE,
                            autolink_bare_uris = FALSE,
                            tex_math_single_backslash = FALSE) {
  assert_pkg("rmarkdown")
  
  rmarkdown::output_format(
    knitr = rmarkdown::knitr_options_html(fig_width = fig_width,
                                          fig_height = fig_height,
                                          fig_retina = NULL,
                                          keep_md = FALSE,
                                          dev = dev),
    pandoc = rmarkdown::pandoc_options(to =
                                         c("markdown",
                                           "+emoji"[checkmate::assert_flag(parse_emoji_markup)],
                                           "-smart",
                                           "-simple_tables",
                                           "-multiline_tables",
                                           "-grid_tables",
                                           "-fenced_code_attributes",
                                           "-inline_code_attributes",
                                           "-raw_attribute",
                                           "-pandoc_title_block",
                                           "-yaml_metadata_block"[!checkmate::assert_flag(preserve_yaml)]) %>%
                                         paste0(collapse = ""),
                                       from =
                                         c("markdown",
                                           "+autolink_bare_uris"[checkmate::assert_flag(autolink_bare_uris)],
                                           "+tex_math_single_backslash"[checkmate::assert_flag(tex_math_single_backslash)],
                                           "-smart"[!checkmate::assert_flag(smart_punctuation)]) %>%
                                         paste0(collapse = ""),
                                       args = c("--atx-headers",
                                                "--columns=9999",
                                                "--standalone",
                                                "--table-of-contents"[checkmate::assert_flag(toc)],
                                                paste0("--toc-depth=", checkmate::assert_int(toc_depth,
                                                                                             lower = 1L,
                                                                                             upper = 6L))[checkmate::assert_flag(toc)])),
    df_print = df_print,
    pre_knit = NULL,
    post_knit = NULL,
    pre_processor = NULL,
    intermediates_generator = NULL,
    post_processor = NULL,
    # on_exit = purrr::when(checkmate::assert_flag(add_toc) ~ tocr::add_toc,
    #                       ~ NULL),
    base_format = NULL
  )
}

#' Assert a package is installed
#'
#' @param pkg Package name. A character scalar.
#' @param message The error message to display in case the package is not installed. If `NULL`, defaults to a sensible standard message.
#'
#' @return The package name invisibly.
#' @export
#'
#' @examples
#' assert_pkg("pal")
#'
#' assert_pkg(pkg = "glue",
#'            message = paste0("You should really consider to install the awesome `glue` package! ",
#'                             "It's the glue that keeps strings and variables together ðŸ¤²."))
assert_pkg <- function(pkg,
                       message = NULL) {
  
  if (!is_pkg_installed(checkmate::assert_string(pkg))) {
    
    if (is.null(message)) {
      message <- glue::glue("Package '{pkg}' is required for this operation but not installed.\n",
                            "Please first install it (e.g. via `install.packages('{pkg}')`) and then try again.")
    }
    rlang::abort(message = checkmate::assert_string(message))
    
  } else {
    invisible(pkg)
  }
}

#' Get the value from a `DESCRIPTION` file field, cleaned up and with fallback
#'
#' Returns the value from a specific `DESCRIPTION` file field (aka _key_). Whitespaces at the start and end of the value as well as repeated whitespaces within
#' it are removed.
#'
#' By default, the following string is returned if `key = "NoRealKey"` is not found:
#'
#' ```
#' "<No `NoRealKey` field set in DESCRIPTION!>"
#' ```
#'
#' If you rather want to take an action like throwing an error, it's recommended to call [desc::desc_get_field()] directly.
#'
#' @param default Default value to return if `key` is not found.
#' @inheritParams desc::desc_get_field
#'
#' @return A character scalar.
#' @export
#'
#' @examples
#' desc_value(key = "Description",
#'            file = fs::path_package("pal"))
desc_value <- function(key,
                       default = glue::glue("<No \x60{key}\x60 field set in DESCRIPTION!>"),
                       file = ".") {
  
  assert_pkg("desc")
  
  desc::desc_get_field(key = key,
                       default = default,
                       file = file) %>%
    stringr::str_squish()
}

#' Test if packages are installed
#'
#' Returns `TRUE` or `FALSE` for each `pkg`, depending on whether the `pkg` is installed on the current system or not, optionally ensuring a `min_version`.
#'
#' In contrast to [base::require()], it checks if the packages are installed without attaching their namespaces if so.
#' 
#' In contrast to [rlang::is_installed()], it doesn't load the packages if they're installed and it is fully vectorized, i.e. returns a (named) logical vector
#' of the same length as `pkg`.
#' 
#' It is [considerably
#' faster](https://stackoverflow.com/questions/9341635/check-for-installed-packages-before-running-install-packages/38082613#38082613) than the commonly used
#' `pkg %in% rownames(installed.packages())` check.
#'
#' @param pkg Package names. A character vector.
#' @param min_version Minimum required version number of each `pkg`. A vector of [`package_version`][base::package_version()]s or something coercible to. Must
#'   be of length one or the same length as `pkg`.
#'
#' @return A named logical vector of the same length as `pkg`.
#' @family rpkgs
#' @export
#'
#' @examples
#' is_pkg_installed(pkg = "tidyverse")
#' is_pkg_installed(pkg = c("dplyr", "tibble", "magrittr"),
#'                  min_version = c("1.0", "2.0", "99.9.9000"))
is_pkg_installed <- function(pkg,
                             min_version = NULL) {
  
  if (is.null(min_version)) {
    
    purrr::map_lgl(magrittr::set_names(pkg, pkg),
                   ~ nzchar(system.file(package = .x)))
  } else {
    
    is_pkg_installed(pkg = pkg) %>%
      list(names(.), min_version) %>%
      purrr::pmap_lgl(~ {
        if (..1) utils::packageVersion(pkg = ..2) >= as.package_version(..3) else ..1
      })
  }
}

#' Test if a directory is an \R package
#'
#' Convenience wrapper around the [`rprojroot::is_r_package`][rprojroot::is_r_package] root criterion. Note that it will only return `TRUE` for the root of a
#' package directory, not its subdirectories.
#'
#' @param path The path of the directory to check. A character scalar. Defaults to the current working directory.
#'
#' @return `TRUE` if `path` is the root directory of an \R package, `FALSE` otherwise.
#' @family rpkgs
#' @export
#'
#' @examples
#' is_pkg_dir()
#' is_pkg_dir(fs::path_package("pal"))
is_pkg_dir <- function(path = ".") {
  
  assert_pkg("rprojroot")
  
  rprojroot::is_r_package$testfun[[1L]](path = checkmate::assert_directory(path,
                                                                           access = "r"))
}

#' List a function's default parameter values in prose-style
#'
#' Extracts the default value(s) of a function's definition and returns it in [prose style listing][prose_ls].
#'
#' This function can be very convenient to avoid duplication in roxygen2 documentation by leveraging [inline \R code
#' evaluation](https://roxygen2.r-lib.org/articles/rd-formatting.html#inline-code) as follows:
#'
#' ```r
#' #' @param some_param Some parameter. One of `r pal::prose_ls_fn_param(param = "some_param", fn = "some_fn")`.
#' some_fn <- function(some_param = c("a", "b", "c")) {
#'   some_param <- rlang::arg_match(some_param)
#'   ...
#' }
#' ```
#'
#' Or to list the possible parameter values formatted as an unnumbered list instead, use the inline code
#' `` `r pal::prose_ls_fn_param(param = "some_param", fn = "some_fn", as_scalar = FALSE) %>% pal::as_md_list()` `` in the example above.
#'
#' # Caveats
#'
#' - This function does not work for [Primitives][base::.Primitive].
#' - [deparse()] is used internally to get a character representation of non-character default values. Therefore all of `deparse()`'s fuzziness also applies to
#'   this function.
#'
#' @param param The parameter name. A character scalar.
#' @param fn A [function][base::function] or a function name (searched for in `env`). See [formals()] for details.
#' @param env The [environment][base::environment] `fn` is defined in. See [formals()] for details.
#' @param as_scalar Whether to return the result as a single string concatenated by `separator` and `last_separator`.
#' @param wrap The string (usually a single character) in which `param`s default values are to be wrapped.
#' @param separator The separator to delimit `param`s default values. Only relevant if `as_scalar = TRUE`.
#' @param last_separator The separator to delimit the second-last and last one of `param`s default values. Only relevant if `as_scalar = TRUE`.
#'
#' @return A character vector. Of length 1 if `as_scalar = TRUE`.
#' @family rpkgs
#' @export
#'
#' @examples
#' prose_ls_fn_param(param = ".name_repair",
#'                   fn = tibble::as_tibble) %>%
#' cat_lines()
#'
#' prose_ls_fn_param(param = ".name_repair",
#'                   fn = tibble::as_tibble,
#'                   as_scalar = FALSE) %>%
#' cat_lines()
prose_ls_fn_param <- function(param,
                              fn = sys.function(sys.parent()),
                              env = parent.frame(),
                              as_scalar = TRUE,
                              wrap = "`",
                              separator = ",",
                              last_separator = " or ") {
  
  checkmate::assert_string(param)
  checkmate::assert_flag(as_scalar)
  
  # turn `fn` into type function if necessary (the same as `formals(fun)` does internally)
  if (is.character(fn)) {
    fn %<>% get(mode = "function",
                envir = env)
  }
  
  if (is.primitive(fn)) rlang::abort("Listing parameters of R Primitives is not supported. Sorry.")
  
  default_vals <- formals(fun = fn,
                          envir = env)
  
  if (param %in% names(default_vals)) {
    default_vals <- default_vals[[param]]
  } else {
    fn_name <- deparse1(expr = substitute(fn),
                        backtick = FALSE)
    rlang::abort(glue::glue("The function `{fn_name}()` does not have a parameter named \"{param}\"."))
  }
  
  if (missing(default_vals)) {
    fn_name <- deparse1(expr = substitute(fn),
                        backtick = FALSE)
    rlang::abort(glue::glue("`{fn_name}()`'s parameter `{param}` does not have a default value."))
  }
  
  # evaluate default param if it results in a character vector
  if (is.language(default_vals)) {
    
    evaluated_default_vals <- rlang::with_handlers(.expr = eval(expr = default_vals,
                                                                envir = env),
                                                   error = ~ NULL)
    
    if (is.character(evaluated_default_vals)) default_vals <- evaluated_default_vals
  }
  
  if (is.character(default_vals)) {
    default_vals %<>% wrap_chr()
  } else {
    default_vals %<>% deparse1(backtick = FALSE,
                               control = c("keepNA",
                                           "keepInteger",
                                           "niceNames",
                                           "showAttributes",
                                           "warnIncomplete"))
  }
  
  if (as_scalar) {
    default_vals %<>% prose_ls(wrap = wrap,
                               separator = separator,
                               last_separator = last_separator)
  } else {
    default_vals %<>% wrap_chr(wrap = wrap)
  }
  
  default_vals
}

#' List a subset of all installed packages
#'
#' @param pkg A character vector of package names.
#' @param ignore_case Do not distinguish between upper and lower case letters in `pkg`. If `FALSE`, `pkg` is treated case-sensitive.
#' @param as_regex Interpret `pkg` as regular expression(s). If `FALSE`, `pkg` is interpreted literally.
#'
#' @return A [tibble][tibble::tbl_df].
#' @family rpkgs
#' @export
#'
#' @examples
#' ls_pkg(pkg = c("pal", "tibble", "dplyr"))
ls_pkg <- function(pkg,
                   ignore_case = TRUE,
                   as_regex = FALSE) {
  
  regex <-
    checkmate::assert_character(pkg,
                                any.missing = FALSE,
                                min.chars = 1L) %>%
    purrr::when(checkmate::assert_flag(as_regex) ~ .,
                ~ paste0("\\Q", ., "\\E")) %>%
    fuse_regex() %>%
    purrr::when(checkmate::assert_flag(ignore_case) ~ paste0("^(?i)", .),
                ~ paste0("^", .)) %>%
    paste0("$")
  
  utils::installed.packages() %>%
    tibble::as_tibble() %>%
    dplyr::filter(stringr::str_detect(string = Package,
                                      pattern = regex))
}

#' Generate an integer sequence of specific length (safe)
#'
#' Modified version of [`seq_len()`][base::seq_len()] that returns a zero-length integer in case of a zero-length input instead of throwing an error.
#'
#' @param n The desired length of the integer sequence.
#'
#' @return An integer sequence starting from `1L`.
#' @family stat
#' @export
#'
#' @examples
#' safe_seq_len(5)
#'
#' # this function simply returns a zero-length integer for zero-length inputs ...
#' safe_seq_len(NULL)
#' safe_seq_len(integer())
#' 
#' # ... while `seq_len()` throws an error
#' \dontrun{
#' seq_len(NULL)
#' seq_len(integer())}
safe_seq_len <- function(n) {
  
  if (length(n)) {
    return(seq_len(n))
    
  } else return(integer())
}

#' Maximum (safe)
#'
#' @description
#' Modified version of [`max()`][base::max()] that differs in the following ways:
#'
#' - `NA`s in the input (`...`) are ignored _by default_ (`rm_na = TRUE`).
#' - If the input is of length zero, the output will also be of length zero (of the same type as the input).
#' - It is ensured that all inputs are either numeric, of length zero or `NA`. There is _no_ case where the return value will be `Inf`.
#' - `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @param ... The numeric objects of which to determine the maximum. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param rm_na Ignore missing values in `...`. If missing values are present and `rm_na = FALSE`, the result will always be `NA`.
#'
#' @return A numeric scalar or empty value, of the same type as `...`.
#' @family stat
#' @export
#'
#' @examples
#' # other than `base::max()`, this function removes `NA`s by default
#' max(1, NA, 2)
#' safe_max(1, NA, 2)
#'
#' # other than `base::max()`, this function does not return `Inf` or `NA_character_` for
#' # zero-length inputs
#' \dontrun{
#' max(NULL)
#' max(character())
#' max(integer())
#' safe_max(NULL)
#' safe_max(character())
#' safe_max(integer())
#' 
#' # other than `base::max()`, this function fails for non-numeric, non-zero-length inputs
#' max("zero", 1L)
#' max("zero", "one")
#' safe_max("zero", 1L)
#' safe_max("zero", "one")}
safe_max <- function(...,
                     rm_na = TRUE) {
  
  rlang::list2(...) %>%
    purrr::map(checkmate::assert_numeric,
               null.ok = TRUE,
               .var.name = "...") %>%
    unlist() %>%
    purrr::when(length(.) == 0L ~ .[0L],
                all(is.na(.)) && rm_na ~ .[NA],
                ~ max(., na.rm = rm_na))
}

#' Minimum (safe)
#'
#' @description
#' Modified version of [`min()`][base::min()] that differs in the following ways:
#'
#' - `NA`s in the input (`...`) are ignored _by default_ (`rm_na = TRUE`).
#' - If the input is of length zero, the output will also be of length zero (of the same type as the input).
#' - It is ensured that all inputs are either numeric, of length zero or `NA`. There is _no_ case where the return value will be `Inf`.
#' - `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @param ... The numeric objects of which to determine the minimum. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @inheritParams safe_max
#'
#' @inherit safe_max return
#' @family stat
#' @export
#'
#' @examples
#' # other than `base::min()`, this function removes `NA`s by default
#' min(1, NA, 2)
#' safe_min(1, NA, 2)
#'
#' # other than `base::min()`, this function does not return `Inf` or `NA_character_` for
#' # zero-length inputs
#' \dontrun{
#' min(NULL)
#' min(character())
#' min(integer())
#' safe_min(NULL)
#' safe_min(character())
#' safe_min(integer())
#' 
#' # other than `base::min()`, this function fails for non-numeric, non-zero-length inputs
#' min("zero", 1L)
#' min("zero", "one")
#' safe_min("zero", 1L)
#' safe_min("zero", "one")}
safe_min <- function(...,
                     rm_na = TRUE) {
  
  rlang::list2(...) %>%
    purrr::map(checkmate::assert_numeric,
               null.ok = TRUE,
               .var.name = "...") %>%
    unlist() %>%
    purrr::when(length(.) == 0L ~ .[0L],
                all(is.na(.)) && rm_na ~ .[NA],
                ~ min(., na.rm = rm_na))
}

#' Round to any number
#'
#' Round a numeric vector to any number, rounded up by default (`round_up = TRUE`).
#'
#' This function's precision is limited to 15 significant digits in order to account for the [limits of R's floating point
#' representation](https://stackoverflow.com/a/35349949/7196903).
#'
#' A computationally more efficient alternative would be the unexported `scales:::round_any()` which drives [scales::number()] â€“ with the drawback that it lacks
#' control of rounding up exact remainders of `accuracy / 2`, i.e. it _always_ rounds _off_.
#'
#' @param x A vector of numbers to round.
#' @param to The number to round `x` to. A numeric scalar.
#' @param round_up Whether to round a remainder of exactly `to / 2` _up_ or not. Set to `FALSE` in order to round _off_.
#'
#' @return A numeric vector of the same length as `x`.
#' @family stat
#' @export
#'
#' @examples
#' c(0.025, 0.1, 0.1999, 0.099999, 0.49, 0.55, 0.5, 0.9, 1) %>% round_to(to = 0.05)
#' c(0.025, 0.1, 0.1999, 0.099999, 0.49, 0.55, 0.5, 0.9, 1) %>% round_to(to = 0.05, round_up = FALSE)
round_to <- function(x,
                     to = 0.2,
                     round_up = TRUE) {
  
  checkmate::assert_number(to,
                           lower = 0L,
                           finite = TRUE)
  checkmate::assert_flag(round_up)
  
  result <- x %/% to
  remainder <- signif(x %% to,
                      # round to a max of 15 significant digits to avoid exceeding floating-point representation limits
                      digits = 15L)
  
  if (round_up) {
    which_round <- remainder >= (to / 2L)
  } else {
    which_round <- remainder > (to / 2L)
  }
  
  result[which_round] <- result[which_round] + 1L
  
  result * to
}

#' Statistical mode
#'
#' Compute the [statistical mode](https://en.wikipedia.org/wiki/Mode_(statistics)) of a set of values. The mode is defined as the most frequent value, i.e. the
#' value that is most likely to be sampled.
#'
#' See the package [modeest](https://cran.r-project.org/package=modeest) for more powerful mode estimation functions.
#'
#' @param x An \R object.
#' @param type What the function should calculate.
#'   - `"one"`: Return _the_ mode of `x`. If multiple modes or no mode at all exists, `NA` is returned.
#'   - `"all"`: Return _all_ modes of `x`. If none exists (e.g. because all values of `x` are distinct), `NA` is returned.
#'   - `"n"`: Return the number of modes of `x`.
#' @param rm_na Ignore missing values in `x`. A logical scalar.
#'
#' @return If `type = "n"`, the number of modes in `x` (an integer). Otherwise, the mode(s) of `x` or `NA` if none exist(s) (same type as `x`).
#' @family stat
#' @export
#'
#' @examples
#' stat_mode(c(rep(3L, times = 3), 1:9))
#' stat_mode(c(1.5, 4, 9.9))
#' 
#' # if no mode exists, `NA` (of the same type as x) is returned
#' stat_mode(letters)
#' stat_mode(c(letters, "a"))
#' 
#' # if multiple modes exist, `NA` is returned by default
#' stat_mode(c(letters, "a", "b"))
#' # set `type = "all"` to return all modes instead
#' stat_mode(c(letters, "a", "b"),
#'           type = "all")
#' 
#' # `NA` is treated as any other value by default
#' stat_mode(c(letters, "a", NA_character_, NA_character_),
#'           type = "all")
#' # set `rm_na = TRUE` to ignore `NA` values
#' stat_mode(c(letters, "a", NA_character_, NA_character_),
#'           type = "all",
#'           rm_na = TRUE)
stat_mode <- function(x,
                      type = c("one", "all", "n"),
                      rm_na = FALSE) {
  x <- unlist(x)
  type <- rlang::arg_match(type)
  if (checkmate::assert_flag(rm_na)) x <- x[!is.na(x)]
  
  # get unique values
  u_x <- unique(x)
  n_u_x <- length(u_x)
  
  # get frequencies of all unique values
  frequencies <- tabulate(match(x, u_x))
  modes <- frequencies == max(frequencies)
  
  # determine number of modes
  n_modes <- sum(modes) %>% dplyr::if_else(. == n_u_x, 0L, .)
  
  type %>% purrr::when(
    # return the number of modes if requested
    . == "n" ~
      n_modes,
    # or return mode(s) if requested and existing
    (. == "one" & n_modes == 1L) | (. == "all" & n_modes > 0L) ~
      u_x[which(modes)],
    # else return `NA` (of the same type as `x`)
    ~ x[NA][1L]
  )
}

#' Convert to a character vector
#'
#' _Recursively_ applies [as.character()] to its inputs.
#'
#' @param ... The \R objects to be converted to a character vector. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' to_convert <-
#'   list(tibble::tibble(a = 1:3), "A", factor("wonderful"), xfun::strict_list("day")) %T>%
#'   print()
#'
#' as.character(to_convert)
#' as_chr(!!!to_convert)
as_chr <- function(...) {
  
  rlang::list2(...) %>%
    purrr::map(~ {
      
      if (purrr::vec_depth(.x) == 1L) {
        
        as.character(.x)
        
      } else {
        
        .x %>%
          purrr::map(as_chr) %>%
          purrr::flatten_chr()
      }
    }) %>%
    purrr::flatten_chr()
}

#' Convert to a character scalar (aka string)
#'
#' Similar to [`paste0(..., collapse = "")`][paste0()], but _recursively_ converts its inputs to type character.
#'
#' @param ... The \R objects to be assembled to a single string. `r pkgsnip::roxy_label("dyn_dots_support")`
#' @param sep The separator to delimit `...`. Defaults to none (`""`).
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' input <-
#'   sample.int(n = 5,
#'              size = 3) %>%
#'   paste0(", ") %>%
#'   purrr::map(rep,
#'              times = 20) %>%
#'   list(c("This is a glut of ", "meaningless numbers: "), .)
#'
#' # while this just converts `input` in a lazy way ...
#' paste0(input,
#'        collapse = "")
#'
#' # ... this one works harder
#' as_string(input)
as_string <- function(...,
                      sep = "") {
  
  as_chr(...) %>% purrr::when(length(.) > 0L ~ paste0(., collapse = sep),
                              ~ .)
}

#' Escape line feeds / newlines
#'
#' Escapes the [POSIX-standard newline control character `LF`](https://en.wikipedia.org/wiki/Newline) (aka `\n`) which is the standard on Unix/Linux and recent
#' versions of macOS. Set `escape_cr = TRUE` in order to also escape the carriage return character `CR` (aka `\r`) commonly used on Microsoft Windows.
#'
#' @param x A character vector.
#' @param escape_cr Whether or not to also escape the carriage return character `CR` (aka `\r`). A logical scalar.
#'
#' @return A character vector of the same length as `x`.
#' @family string
#' @export
#'
#' @examples
#' # read in and print package description as-is
#' text <-
#'   fs::path_package(package = "pal",
#'                    "DESCRIPTION") %>%
#'   readr::read_file() %T>%
#'   cat_lines()
#'
#' # escape newlines and print again
#' escape_lf(text) %>% cat_lines()
escape_lf <- function(x,
                      escape_cr = FALSE) {
  
  checkmate::assert_character(x,
                              null.ok = TRUE) %>%
  stringr::str_replace_all(pattern = "\\n",
                           replacement = "\\\\n") %>%
    purrr::when(checkmate::assert_flag(escape_cr) ~ stringr::str_replace_all(string = .,
                                                                             pattern = "\\r",
                                                                             replacement = "\\\\r"),
                ~ .)
}

#' Fuse regular expressions
#'
#' Combine a vector or list of regular expressions to a single one (by logical OR).
#'
#' @param ... The regular expressions. All elements will be converted to type character before fusing. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @return A character scalar.
#' @seealso The [rex][rex::rex] package which provides an intuitive framework to build complex regular expressions.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' # perform some (nonsense) Jane Austen text extraction
#' regex <- c("My dear Jane",
#'            "make haste, ",
#'            "(?i)\\bevil")
#'
#' stringr::str_subset(string = janeaustenr::prideprejudice,
#'                     pattern = fuse_regex(regex))}
fuse_regex <- function(...) {
  
  result <- as_string(..., sep = "|")
  
  if (length(rlang::list2(...)) > 1L || length(rlang::list2(...)[[1]]) > 1L) {
    result %<>% paste0("(", ., ")")
  }
  
  result
}

#' Get column names of a delimiter-separated string
#'
#' Returns the column names of a string in a [delimiter-separated-value](https://en.wikipedia.org/wiki/Delimiter-separated_values) format like
#' [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) or [TSV](https://en.wikipedia.org/wiki/Tab-separated_values).
#'
#' @param x The delimiter-separated string. A character scalar.
#' @param delim Single character used to separate fields within `x`.
#' @param quote Single character used to quote strings within `x`. Set to `NULL` for none.
#'
#' @return A character vector of column names.
#' @family string
#' @export
#'
#' @examples
#' \donttest{
#' httr::GET("https://raw.githubusercontent.com/tidyverse/readr/master/inst/extdata/mtcars.csv") %>%
#'   httr::content(as = "text") %>%
#'   pal::dsv_colnames()}
dsv_colnames <- function(x,
                         delim = ",",
                         quote = "\"") {
  x %>%
    regexpr(pattern = "[\r\n]") %>%
    magrittr::subtract(1L) %>%
    substr(x = x,
           start = 1L) %>%
    stringr::str_split(pattern = checkmate::assert_string(delim,
                                                          min.chars = 1L,
                                                          pattern = "^.$")) %>%
    dplyr::first() %>%
    stringr::str_remove_all(pattern = glue::glue("^", checkmate::assert_string(quote,
                                                                                null.ok = TRUE,
                                                                                pattern = "^.$"),
                                                 "|{quote}$"))
}

#' List items concatenated in prose style (..., ... and ...)
#'
#' Takes a vector or list and concatenates its elements to a single string separated in prose-style.
#'
#' @param x A vector or a list.
#' @param wrap The string (usually a single character) in which `x` is to be wrapped.
#' @param separator The separator to delimit the elements of `x`.
#' @param last_separator The separator to delimit the second-last and last element of `x`.
#'
#' @return A character scalar.
#' @family string
#' @export
#'
#' @examples
#' prose_ls(1:5)
prose_ls <- function(x,
                     wrap = "",
                     separator = ", ",
                     last_separator = " and ") {
  
  result <- as_chr(x)
  length_result <- length(result)
  
  if (length_result == 1L) {
    
    result <- paste0(checkmate::assert_string(wrap), result, wrap)
    
  } else if (length_result > 1L) {
    
    result <-
      paste0(result[-length_result],
             collapse = paste0(checkmate::assert_string(wrap), separator, wrap)) %>%
      paste0(wrap, ., wrap, checkmate::assert_string(last_separator), wrap, result[length_result], wrap)
  }
  
  result
}

#' Prettify a numeric vector
#'
#' Prettifies a numeric vector by rounding, separating thousands and optionally other procedures. Basically a convenience wrapper around [round_to()] and
#' [`format()`][base::format()].
#'
#' @param x A numeric vector to prettify.
#' @param round_to The number to round `x` to. A numeric scalar.
#' @param big_mark The character used between every 3 digits to separate thousands.
#' @param decimal_mark The character used to indicate the numeric decimal point. Only relevant if `x` does not solely consist of integers.
#' @param justify_right Whether to right-justify the results to a common width. See the `trim` parameter of [base::format()] for details.
#' @param ... Further arguments passed on to [base::format()].
#' @inheritParams round_to
#'
#' @return A character vector of the same length as `x`.
#' @family string
#' @export
#'
#' @examples
#' c(0.11, 11111.11) %>% prettify_nr()
#'
#' c(0.11, 11111.11) %>%
#'   prettify_nr(justify_right = TRUE) %>%
#'   cat_lines()
prettify_nr <- function(x,
                        round_to = 0.1,
                        round_up = TRUE,
                        big_mark = "'",
                        decimal_mark = ".",
                        justify_right = FALSE,
                        ...) {
  round_to(x = x,
           to = round_to,
           round_up = round_up) %>%
    format(big.mark = big_mark,
           decimal.mark = decimal_mark,
           trim = !justify_right,
           ... = ...)
}

#' Print `x` as newline-separated character vector using `cat()`.
#' 
#' Convenience wrapper around [as_chr()] and [`cat()`][base::cat()], mainly intended for interactive use.
#' 
#' A faster alternative that doesn't _recursively_ convert its input to type character is [cli::cat_line()].
#'
#' @param ... The \R object(s) to print. `r pkgsnip::roxy_label("dyn_dots_support")`
#'
#' @inherit base::cat return
#' @family string
#' @seealso [xfun::raw_string()], [xfun::file_string()]
#' @export
#'
#' @examples
#' fs::path_package(package = "pal",
#'                  "DESCRIPTION") %>%
#'   readr::read_lines() %>%
#'   cat_lines()
#' 
#' # recursive conversion to type character or not
#' to_convert <-
#'   list(tibble::tibble(a = 1:3), "A", factor("wonderful"), xfun::strict_list("day")) %T>%
#'   print()
#' 
#' to_convert %>% cat_lines()
#' to_convert %>% cli::cat_line()
cat_lines <- function(...) {
  
  cat(as_chr(...),
      sep = "\n")
}

#' Replace matched patterns in a string _verbosely_
#'
#' Apply a series of regular-expression-replacement pairs to a string. All performed replacements are displayed on the console by default.
#'
#' This function provides a subset of [stringr::str_replace_all()]'s functionality. If you don't need the visual console output, it's recommended to directly
#' resort to that function.
#'
#' @param pattern A named character vector with patterns as names and replacements as values (`c(pattern1 = replacement1)`). Patterns are interpreted as
#'   regular expressions as described in [stringi::stringi-search-regex()]. Replacements are interpreted as-is, except that references of the form `\1`, `\2`,
#'   etc. will be replaced with the contents of the respective matched group (created in patterns using `()`). Pattern-replacement pairs are processed in the
#'   order given, meaning that first listed pairs are applied before later listed ones.
#' @param verbose Whether to display replacements on the console.
#' @param n_context_chrs The (maximum) number of characters displayed around the actual `string` and its replacement. The number refers to a single side of
#'   `string`/replacement, so the total number of context characters is at the maximum `2 * n_context_chrs`. Only relevant if `verbose = TRUE`.
#' @inheritParams stringr::str_replace_all
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' "Make love, not war" %>% str_replace_verbose(pattern = c("love" = "hummus",
#'                                                          "war" = "walls"))
#'
#' # pattern-replacement pairs are processed one-by-one, so the following gives the same result
#' "Make love, not war" %>% str_replace_verbose(pattern = c("love" = "hummus",
#'                                                          "hummus, not war" = "hummus, not walls"))
#'
#' # varying `n_context_chrs` affects console output summarization
#' input <- c("Tulips are not durable, ",
#'            "not scarce, ",
#'            "not programmable, ",
#'            "not fungible, ",
#'            "not verifiable, ",
#'            "not divisible, ",
#'            "and hard to transfer. ",
#'            "But tell me more about your analogy...",
#'            "",
#'            "-[Naval Ravikant](https://twitter.com/naval/status/939316447318122496)")
#'
#' pattern <- c("not" = "extremely",
#'              "hard" = "ridiculously easy",
#'              "^But.*" = "So... flower power?",
#'              "(^-).*Naval.*" = "\\1\U0001F92A")
#'
#' str_replace_verbose(string = input,
#'                     pattern = pattern,
#'                     n_context_chrs = 5L) %>%
#'   cat_lines()
#'
#' str_replace_verbose(string = input,
#'                     pattern = pattern,
#'                     n_context_chrs = 0L) %>%
#'   cat_lines()
str_replace_verbose <- function(string,
                                pattern,
                                verbose = TRUE,
                                n_context_chrs = 20L) {
  
  checkmate::assert_flag(verbose)
  checkmate::assert_character(pattern, any.missing = FALSE)
  if (!checkmate::test_named(pattern)) rlang::abort("All elements of `pattern` must be named (names are patterns, values are replacements).")
  n_context_chrs <- checkmate::assert_count(n_context_chrs, coerce = TRUE)
  
  # print replacement info for humans
  if (verbose) {
    
    assert_pkg("cli")
    
    # we have to process each pattern-replacement pair one-by-one because other than `stringr::str_replace_all()`, `stringr::str_locate_all()` doesn't support
    # the pair-wise spec
    string_changed <- string
    msgs <- tibble::tibble(minus = character(),
                           plus = character(),
                           i_pattern = integer())
    
    for (i in seq_along(pattern)) {
      
      msgs <-
        str_replace_verbose_single_info(string = string_changed,
                                        pattern = pattern[i],
                                        n_context_chrs = n_context_chrs) %>%
        dplyr::mutate(i_pattern = i) %>%
        dplyr::bind_rows(msgs, .)
      
      string_changed %<>% stringr::str_replace_all(pattern = pattern[i])
    }
    
    msgs %>%
      dplyr::group_by(minus, plus) %>%
      dplyr::summarise(i_pattern = safe_min(i_pattern),
                       n = dplyr::n(),
                       .groups = "drop") %>%
      # since summarizing can change row order, we need to restore the original order
      dplyr::arrange(i_pattern) %>%
      purrr::pwalk(function(minus, plus, i_pattern, n) {
        
        # using string interpolation ensures `{` and `}` are escaped, cf. ?cli::`inline-markup`
        cat(n, "\u00D7 ", minus, "\n",
            sep = "")
        cat(rep("\u00A0", times = nchar(n) + 2L), plus, "\n",
            sep = "")
      })
  }
  
  # perform actual replacement
  stringr::str_replace_all(string = string,
                           pattern = pattern)
}

# helper to generate info for single replacement 
str_replace_verbose_single_info <- function(string,
                                            pattern,
                                            n_context_chrs) {
  
  # escape newlines (in case replacement contains newlines)
  replacement <- escape_lf(as.character(pattern))
  
  stringr::str_locate_all(string = string,
                          pattern = names(pattern)) %>%
    purrr::map2_dfr(.y = string,
                    .f = function(positions, string) {
                      
                      positions %<>% dplyr::as_tibble() %>% dplyr::filter(start <= end)
                      
                      purrr::map2_dfr(.x = positions$start,
                                      .y = positions$end,
                                      .f = function(start, end) {
                                        
                                        # reduce to `string` excerpt of +/- `n_context_chrs`
                                        ## determine if we prune
                                        prune_start <- (start - n_context_chrs) > 1L 
                                        prune_end <- (end + n_context_chrs) < nchar(string)
                                        
                                        ## extract excerpt
                                        ### begin (part before `pattern`)
                                        excerpt_begin <- string %>% stringr::str_sub(start = dplyr::if_else(prune_start,
                                                                                                            start - n_context_chrs,
                                                                                                            1L),
                                                                                     end = start - 1L)
                                        ### the `pattern` as-is, i.e. without regex syntax
                                        pattern_asis <- string %>% stringr::str_sub(start = start,
                                                                                    end = end)
                                        
                                        ### end (part after `pattern`)
                                        excerpt_end <- string %>% stringr::str_sub(start = end + 1L,
                                                                                   end = dplyr::if_else(prune_end,
                                                                                                        end + n_context_chrs,
                                                                                                        -1L))
                                        
                                        # replace excerpt start/end with ellipsis dots (pruned to whole words if appropriate)
                                        if (prune_start) excerpt_begin %<>% paste0(unicode_ellipsis, .)
                                        
                                        if (prune_end) excerpt_end %<>% paste0(unicode_ellipsis)
                                        
                                        # escape newlines (in case pattern contains newlines)
                                        excerpt_begin %<>% escape_lf()
                                        pattern_asis %<>% escape_lf()
                                        excerpt_end %<>% escape_lf()
                                        
                                        # assemble info msgs
                                        tibble::tibble(minus = as_string(cli::col_red("-"), " ", cli::bg_black(excerpt_begin),
                                                                         cli::style_strikethrough(bg_red_dark(pattern_asis)), cli::bg_black(excerpt_end)),
                                                       plus = as_string(cli::col_green("+"), " ", cli::bg_black(excerpt_begin), bg_green_dark(replacement),
                                                                        cli::bg_black(excerpt_end)))
                                      })
                    })
}

#' Replace matched patterns in text files
#'
#' Apply pattern-based string replacement to multiple files at once. Just provide a series of regular-expression-replacement pairs which are applied one-by-one
#' in the given order. All performed replacements are displayed on the console by default (`verbose = TRUE`), optionally without actually changing any file
#' content (`run_dry = TRUE`).
#'
#' Note that `process_line_by_line` requires the [line ending standard (EOL)](https://en.wikipedia.org/wiki/Newline) of the input files to be correctly set in
#' `eol`. It _always_ defaults to `"LF"` (Unix standard) since this is something which cannot be reliably detected without complex heuristics (and even then
#' not unambiguously in all edge cases). Simply deriving a default depending on the host OS (i.a. `"LF"` on Unix systems like Linux and macOS and `"CRLF"` on
#' Windows) seems like a really bad idea with regard to cross-system collaboration (files shared via Git etc.), thus it was refrained from.
#'
#' The text files are assumed to be in [UTF-8 character encoding](https://en.wikipedia.org/wiki/UTF-8), other encodings are not supported.
#'
#' @param path Paths to the text files. A character vector.
#' @param process_line_by_line Whether each line in a file should be treated as a separate string or the whole file as one single string. While the latter is 
#'   more performant, you probably want the former if you're using `"^"` or `"$"` in your `pattern`s.
#' @param eol End of line (EOL) control character sequence. Only relevant if `process_line_by_line = TRUE`. One of
#'   - `"LF"` for the line feed (LF) character (`"\n"`). The standard on Unix and Unix-like systems (Linux, macOS, *BSD, etc.) and the **default**.
#'   - `"CRLF"` for the carriage return + line feed (CR+LF) character sequence (`"\r\n"`). The standard on Microsoft Windows, DOS and some other systems.
#'   - `"CR"` for the carriage return (CR) character (`"\r"`). The standard on classic Mac OS and some other antiquated systems.
#'   - `"LFCR"` for the line feed + carriage return (LF+CR) character sequence (`"\n\r"`). The standard on RISC OS and some other exotic systems.
#' @param show_rel_path Whether to display file `path`s as relative from the current working directory. If `FALSE`, absolute paths are displayed. Only relevant
#'   if `verbose = TRUE`.
#' @param run_dry Show replacements on the console only, without actually modifying any files. Implies `verbose = TRUE`.
#' @inheritParams str_replace_verbose
#'
#' @return `path` invisibly.
#' @family string
#' @export
str_replace_file <- function(path,
                             pattern,
                             process_line_by_line = FALSE,
                             eol = c("LF", "CRLF", "CR", "LFCR"),
                             verbose = TRUE,
                             n_context_chrs = 20L,
                             show_rel_path = TRUE,
                             run_dry = FALSE) {
  
  assert_pkg("brio")
  checkmate::assert_file(path,
                         access = "r")
  checkmate::assert_flag(process_line_by_line)
  eol %<>% as_line_feed_chr()
  checkmate::assert_flag(verbose)
  checkmate::assert_flag(show_rel_path)
  checkmate::assert_flag(run_dry)
  
  if (run_dry && !verbose) {
    rlang::abort("Setting `run_dry = TRUE` and `verbose = FALSE` at the same time is pointless.")
  }
  
  purrr::walk(.x = path,
              .f = function(path) {
                
                # print file progress info
                if (verbose) {
                  
                  assert_pkg("cli")
                  
                  path_show <- dplyr::if_else(show_rel_path,
                                              fs::path_rel(path),
                                              fs::path_abs(path))
                  
                  cli::cli_alert_info(text = "Processing file {.file {path_show}}{unicode_ellipsis}")
                }
                
                # perform replacement
                input <- brio::read_file(path = path)
                
                if (process_line_by_line) {
                  input %<>% stringr::str_split(pattern = eol) %>% dplyr::first()
                }
                
                output <- str_replace_verbose(string = input,
                                              pattern = pattern,
                                              verbose = verbose,
                                              n_context_chrs = n_context_chrs)
                
                if (!run_dry && !identical(input, output)) {
                  
                  brio::write_file(text = paste0(output,
                                                 collapse = eol),
                                   path = path)
                }
              })
  
  invisible(path)
}

#' Wrap character vector in string
#'
#' @param x A character vector or something coercible to. Will be fed to [as_chr()] before wrapping.
#' @param wrap The string `x` is to be wrapped in.
#'
#' @return A character vector.
#' @family string
#' @export
#'
#' @examples
#' mtcars %>%
#'   magrittr::set_colnames(wrap_chr(x = colnames(.),
#'                                   wrap = "`")) %>%
#'   pipe_table()
wrap_chr <- function(x,
                     wrap = "\"") {
  
  paste0(wrap, as_chr(x), wrap)
}

#' Check if CLI tool is available on the system
#'
#' Checks if a CLI tool is found on the system's [`PATH`](https://en.wikipedia.org/wiki/PATH_(variable)) and optionally returns the executable's filesystem
#' path.
#'
#' @param cmd The system command to invoke the CLI tool. A character scalar.
#' @param get_cmd_path Return the filesystem path to the CLI tool. If `FALSE` (the default), a boolean is returned indicating if the CLI tool is found on the
#'   system or not.
#' @param force_which If set to `TRUE`, [Sys.which()], which relies on the system command `which`, will be used instead of `command -v` to determine the
#'   availability of `cmd` on Unix-like systems. On Windows, `Sys.which()` is used in any case. `command -v` is
#'   [generally recommended for bourne-like shells](https://unix.stackexchange.com/q/85249/201803) and therefore is the default on Linux, macOS and other
#'   [Unixes](https://en.wikipedia.org/wiki/Unix-like).
#'
#' @return A logical scalar if `get_cmd_path = FALSE`, otherwise the filesystem [path][fs::path] to the `cmd` executable.
#' @family sys
#' @export
#'
#' @examples
#' check_cli("Rscript")
#'
#' cmd <- ifelse(xfun::is_windows(), "pandoc.exe", "pandoc")
#' check_cli(cmd, get_cmd_path = TRUE)
check_cli <- function(cmd,
                      get_cmd_path = FALSE,
                      force_which = FALSE) {
  
  checkmate::assert_string(cmd)
  checkmate::assert_flag(get_cmd_path)
  checkmate::assert_flag(force_which)
  
  if (force_which | !xfun::is_unix()) {
    
    Sys.which(names = cmd) %>%
      as.character() %>%
      purrr::when(. == "" ~ character(0L),
                  ~ .) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  length(.) == 0L ~ FALSE,
                  ~ TRUE)
    
  } else {
    
    # define "defused" warning/error handler
    defuse <- function(e) if (get_cmd_path) character(0L) else FALSE
    
    rlang::with_handlers(system2(command = "command",
                                 args = c("-v",
                                          cmd),
                                 stdout = get_cmd_path,
                                 stderr = get_cmd_path),
                         warning = defuse,
                         error = defuse) %>%
      purrr::when(get_cmd_path ~ fs::path(.),
                  isFALSE(.) ~ .,
                  ~ TRUE)
  }
}

#' Determine file path of executing script
#'
#' Tries to determine the path to the R/Rmd script that this function is called from.
#'
#' @return The file path to the executing script.
#' @family sys
#' @export
path_script <- function() {
  
  assert_pkg("rprojroot")
  assert_pkg("rstudioapi")
  cmd_args <- commandArgs(trailingOnly = FALSE)
  needle <- "--file="
  match <- grep(x = cmd_args,
                pattern = needle)
  
  # Rscript
  if (length(match) > 0L) {
    
    return(normalizePath(sub(needle, "", cmd_args[match])))
  }
  
  # `source()`d via R console
  if (!is.null(sys.frames()[[1L]][["ofile"]])) {
    
    return(normalizePath(sys.frames()[[1L]][["ofile"]]))
    
    # RStudio Run Selection, cf. http://stackoverflow.com/a/35842176/2292993
  } else if (!is.null(rprojroot::thisfile())) {
    
    return(rprojroot::thisfile())
    
    # RStudio document
  } else {
    
    path <- rstudioapi::getActiveDocumentContext()[["path"]]
    
    if (path != "") {
      return(normalizePath(path))
    }
  }
  
  rlang::abort("Couldn't determine script path!'")
}

run_cli <- function(cmd,
                    ...) {
  
  
}

#' Capture printed console output as string
#'
#' Returns what [`print(x)`][base::print()] would output on the console â€“ if `collapse` is set to anything other than `NULL`, as an atomic character vector
#' (i.e. a string), otherwise a character vector of output lines.
#'
#' This is a simple convenience wrapper around [utils::capture.output()]. Note that [ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)
#' (e.g. as output by the `print()` methods of tidyverse packages) are not captured (i.e. lost).
#'
#' @param x The \R object of which the output of `print()` is to be captured.
#' @param collapse An optional string for concatenating the results. If `NULL`, a character vector of print lines is returned.
#'
#' @return A character vector if `collapse = NULL`, otherwise a character scalar.
#' @export
#'
#' @examples
#' mtcars %>% pal::capture_print()
#' mtcars %>% pal::capture_print(collapse = "\n") %>% cat()
capture_print <- function(x,
                          collapse = NULL) {
  
  utils::capture.output(print(x),
                        file = NULL,
                        type = "output",
                        split = FALSE) %>%
    paste0(collapse = collapse)
}

#' Order a vector by another vector
#'
#' @param x The vector to be ordered.
#' @param by The reference vector which `x` will be ordered by.
#'
#' @return A permutation of `x`.
#' @export
#'
#' @examples
#' # generate 100 random letters
#' random_letters <-
#'   letters %>%
#'   magrittr::extract(sample.int(n = 26L,
#'                                size = 100L,
#'                                replace = TRUE)) %T>%
#'   print()
#'
#' # sort the random letters alphabetically
#' random_letters %>% order_by(by = letters)
order_by <- function(x,
                     by) {
  
  x[order(match(x = x, table = by))]
}

#' Test if an HTTP request is successful
#'
#' @description
#' Convenience wrapper around [`!httr::http_error()`][httr::http_error()] that returns
#'
#' - `TRUE` if the specified `url` could be resolved _and_ a [`HEAD`](https://en.wikipedia.org/wiki/Hypertext_Transfer_Protocol#Request_methods) request could
#'   be [successfully completed](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes), or
#'
#' - `FALSE` in any other case.
#'
#' @details
#' This function is similar to [RCurl::url.exists()], i.e. it only retrieves the header, no body, but is based on [httr][httr::httr-package] which in turn is
#' based on [curl](https://jeroen.cran.dev/curl/).
#'
#' @param url The HTTP protocol address. The scheme is optional, so both `"google.com"` and `"https://google.com"` will work. A character scalar.
#' @param retries The maximum number of retries of the `HEAD` request in case of an HTTP error. An integer scalar >= `0`. The retries are performed using
#'   exponential backoff and jitter, see [httr::RETRY()] for details.
#' @param quiet Suppress the message displaying how long until the next retry in case an HTTP error occurred. A logical scalar. Only relevant if `retries > 0`.
#'
#' @return A logical scalar.
#' @seealso [RCurl::url.exists()]
#' @export
#'
#' @examples
#' is_http_success("goo.gl")
#' is_http_success("https://google.com/")
#' is_http_success("https://google.not/")
#' is_http_success("https://google.not/",
#'                 retries = 2,
#'                 quiet = FALSE)
is_http_success <- function(url,
                            retries = 0L,
                            quiet = TRUE) {
  
  assert_pkg("httr")
  
  rlang::with_handlers(!httr::http_error(httr::RETRY(verb = "HEAD",
                                                     url = url,
                                                     times = checkmate::assert_count(retries) + 1L,
                                                     quiet = checkmate::assert_flag(quiet))),
                       error = ~ FALSE,
                       interrupt = ~ rlang::abort("Terminated by the user"))
}

#' Evaluate an expression with cli process indication
#'
#' Convenience wrapper around [cli::cli_process_start()], [cli::cli_process_done()] and [cli::cli_process_failed()].
#'
#' @param expr An expression to be evaluated.
#' @param env Environment to evaluate `expr`, as well as possible [glue][glue::glue()] expressions within `msg`, in.
#' @inheritParams cli::cli_process_start
#'
#' @return The result of the evaluated `expr`.
#' @export
#'
#' @examples
#' \donttest{
#' cli_process_expr(Sys.sleep(3L), "Zzzz")}
#'
#' \dontrun{
#' # "russian roulette"
#' msg <- "Spinning the cylinder \U0001F91E â€¦ "
#' cli_process_expr(msg = msg,
#'                  msg_done = paste0(msg, "and pulling the trigger â€“ lucky again. \U0001F60C"),
#'                  msg_failed = paste0(msg, "and pulling the trigger â€“ head blast!"),
#'                  {
#'                    if (interactive()) Sys.sleep(1)
#'                    if (runif(1L) < 0.4) stop("\U0001F92F\u2620")
#'                  })}
cli_process_expr <- function(expr,
                             msg,
                             msg_done = paste(msg, "... done"),
                             msg_failed = paste(msg, "... failed"),
                             msg_class = "alert-info",
                             done_class = "alert-success",
                             failed_class = "alert-danger",
                             env = parent.frame()) {
  assert_pkg("cli")
  
  # NOTE: We cannot rely on `on_exit = "done"` since in case of an error the on-exit code of this function will never be called because we actually throw
  #       the error using `rlang::cnd_signal(.x)`.
  status_bar_container_id <- cli::cli_process_start(msg = msg,
                                                    msg_done = msg_done,
                                                    msg_failed = msg_failed,
                                                    msg_class = msg_class,
                                                    done_class = done_class,
                                                    failed_class = failed_class,
                                                    .envir = env)
  
  rlang::with_handlers(.expr = eval(expr = rlang::enexpr(expr),
                                    envir = env),
                       error = ~ {
                         cli::cli_process_failed(status_bar_container_id)
                         rlang::cnd_signal(.x)
                       })
  
  cli::cli_process_done(status_bar_container_id)
}

#' Check that all dot parameter names are a valid subset of a function's parameter names.
#'
#' @description
#'
#' `r lifecycle::badge("experimental")`
#'
#' Ensures that [dots (...)][base::dots()] are either empty (if `.empty_ok = TRUE`), or all named dot parameter names are a valid subset of a function's
#' parameter names. In case of an invalid or `.forbidden` argument, an informative message is shown and the defined `.action` is taken.
#'
#' @details
#'
#' `check_dots_named()` is intended to combat the second one of the two major downsides that using `...` usually brings. In chapter 6.6 of the book
#' _Advanced R_ it is [phrased](https://adv-r.hadley.nz/functions.html#fun-dot-dot-dot) as follows:
#'
#' _Using `...` comes with two downsides:_
#' 
#' - _When you use it to pass arguments to another function, you have to carefully explain to the user where those arguments go. This makes it hard to
#'   understand what you can do with functions like `lapply()` and `plot()`._
#' 
#' - **_A misspelled argument will not raise an error. This makes it easy for typos to go unnoticed._**
#'
#' @param ... The dots argument to check.
#' @param .function The function the `...` will be passed on to.
#' @param .additional Parameter names within `...` that should be treated as valid in addition to `.function`'s actual parameter names. A character vector.
#' @param .forbidden Parameter names within `...` that should be treated as invalid. This has precedence over `.additional`. A character vector.
#' @param .empty_ok Set to `TRUE` if empty `...` should be allowed, or to `FALSE` otherwise.
#' @param .action The action to take when the check fails. One of
#'   - [`rlang::abort`][rlang::abort()]
#'   - [`rlang::warn`][rlang::warn()]
#'   - [`rlang::inform`][rlang::inform()]
#'   - [`rlang::signal`][rlang::signal()]
#' @export
#'
#' @examples
#' # We can use `check_dots_named()` to address this second downside:
#' sum_safe <- function(...,
#'                      na.rm = FALSE) {
#'   pal::check_dots_named(...,
#'                         .function = sum)
#'   sum(...,
#'       na.rm = na.rm)
#' }
#' 
#' # note how the misspelled `na_rm` (instead of `na.rm`) silently gets ignored
#' # in the original function
#' sum(1, 2, NA, na_rm = TRUE)
#'
#' \dontrun{
#' # whereas our safe version properly errors
#' sum_safe(1, 2, NA, na_rm = TRUE)}
#'
#' # we can even build an `sapply()` function that fails "intelligently" 
#' sapply_safe <- function(X,
#'                         FUN,
#'                         ...,
#'                         simplify = TRUE,
#'                         USE.NAMES = TRUE) {
#'   pal::check_dots_named(...,
#'                         .function = FUN)
#'   sapply(X = X,
#'          FUN = FUN,
#'          ...,
#'          simplify = TRUE,
#'          USE.NAMES = TRUE)
#' }
#'
#' # while the original `sapply()` silently ignores misspelled arguments,
#' sapply(1:5, paste, "hour workdays", sep = "-", colaspe = " ")
#'
#' \dontrun{
#' # `sapply_safe()` will throw an informative error message
#' sapply_safe(1:5, paste, "hour workdays", sep = "-", colaspe = " ")}
#'
#' \dontrun{
#' # but be aware that `check_dots_named()` might be a bit rash
#' sum_safe(a = 1, b = 2)}
#'
#' # while the original function actually has nothing to complain
#' sum(a = 1, b = 2)
#'
#' \dontrun{
#' # also, it doesn't play nicely with functions that don't expose all of
#' # their arg names (`to` and `by` in the case of `seq()`)
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             to = 100,
#'             by = 5)}
#'
#' # but providing `to` and `by` *unnamed* is fine of course:
#' sapply_safe(X = c(0,50),
#'             FUN = seq,
#'             100,
#'             5)
check_dots_named <- function(...,
                             .function,
                             .additional = NULL,
                             .forbidden = NULL,
                             .empty_ok = TRUE,
                             .action = rlang::abort) {
  
  if (...length()) {
    
    # determine original function name the `...` will be passed on to
    fun_arg_name <- deparse1(substitute(.function))
    parent_call <- as.list(sys.call(-1L))
    parent_param_names <- methods::formalArgs(sys.function(-1L))
    
    if (fun_arg_name %in% parent_param_names) {
      fun_name <- as.character(parent_call[which(parent_param_names == fun_arg_name) + 1L][[1L]])
    } else {
      fun_name <- fun_arg_name
    }
    
    # determine param names of the function the `...` will be passed on to
    dots_param_names <- methods::formalArgs(checkmate::assert_function(.function))
    
    # check named `...` args
    purrr::walk(.x = setdiff(names(c(...)),
                             ""),
                .f = check_dot_named,
                values = dots_param_names,
                allowed_values = setdiff(union(dots_param_names,
                                               checkmate::assert_character(.additional,
                                                                           any.missing = FALSE,
                                                                           null.ok = TRUE)),
                                         checkmate::assert_character(.forbidden,
                                                                     any.missing = FALSE,
                                                                     null.ok = TRUE)),
                fun_name = fun_name,
                action = .action)
    
  } else if (!checkmate::assert_flag(.empty_ok)) {
    
    checkmate::assert_function(.action) %>%
      deparse() %>%
      substitute() %>%
      checkmate::assert_choice(choices = paste0("rlang::", c("abort",
                                                             "warn",
                                                             "inform",
                                                             "signal")))
    
    .action(message = "`...` must be provided (!= NULL)!")
  }
}

check_dot_named <- function(dot,
                            values,
                            allowed_values,
                            fun_name,
                            action) {
  
  # The following code is largely borrowed from `rlang::arg_match()`
  i <- match(dot, allowed_values)
  
  if (rlang::is_na(i)) {
    
    is_forbidden <- dot %in% values
    is_restricted <- !setequal(values,
                               allowed_values)
    
    msg <- glue::glue(dplyr::if_else(is_forbidden,
                                     "Forbidden",
                                     "Invalid"), " argument provided in `...`: `{dot}`\n",
                      .trim = FALSE)
    
    if (length(allowed_values) > 0L) {
      
      msg %<>% glue::glue(dplyr::if_else(is_restricted,
                                         "Arguments allowed to pass on to ",
                                         "Valid arguments for "), "`{fun_name}()` include: ", prose_ls(allowed_values, wrap = "`"), "\n",
                          .trim = FALSE)
    } else {
      
      msg %<>% glue::glue("Only unnamed arguments are ", dplyr::if_else(is_restricted, "allowed", "valid"), " for `{fun_name}()`.")
    }
    
    i_partial <- pmatch(dot, allowed_values)
    
    if (!rlang::is_na(i_partial)) {
      candidate <- allowed_values[[i_partial]]
    }
    
    i_close <- utils::adist(dot, allowed_values) / nchar(allowed_values)
    
    if (any(i_close <= 0.5)) {
      candidate <- allowed_values[[which.min(i_close)]]
    }
    
    if (exists("candidate")) {
      candidate <- prose_ls(candidate, wrap = "`")
      msg <- paste0(msg, "\n", "Did you mean ", candidate, 
                    "?")
    }
    
    action(msg)
  }
}

#' Create column specification using regular expression matching
#'
#' This function allows to define a regular expression per desired [column specification object][readr::cols] matching the respective column names.
#'
#' @param ... Named arguments where the names are (Perl-compatible) regular expressions and the values are column objects created by `col_*()`, or their
#'   abbreviated character names (as described in the `col_types` argument of [readr::read_delim()]).
#' @param .default Any named columns not matched by any of the regular expressions in `...` will be read with this column type.
#' @param .col_names The column names which should be matched by `...`.
#'
#' @return A [column specification][readr::cols].
#' @export
#'
#' @examples
#' # for some hypothetical CSV data column names like these ...
#' cnames <- c("VAR1_Text",
#'             "VAR2_Text",
#'             "VAR3_Text_Other",
#'             "VAR1_Code_R1",
#'             "VAR2_Code_R2",
#'             "HAS_R1_Lag",
#'             "HAS_R2_Lag",
#'             "GARBAGEX67",
#'             "GARBAGEY09")
#' 
#' # ... a column spec could be created concisely as follows:
#' pal::cols_regex(.col_names   = cnames,
#'                 "_Text(_|$)" = "c",
#'                 "_Code(_|$)" = "i",
#'                 "^GARBAGE"  = readr::col_skip(),
#'                 .default     = "l")
#'
#' # we can parse some real data:
#' raw_data <-
#'   httr::GET(paste0("http://www.web.statistik.zh.ch/ogd/data/",
#'                    "KANTON_ZUERICH_nrw_2019_listen_ergebnisse_gemeinde.csv")) %>%
#'   httr::content(as = "text",
#'                 encoding = "UTF-8")
#'
#' readr::read_csv(
#'   file = raw_data,
#'   col_types = pal::cols_regex(
#'     "^(Gemeindenamen|Partei)$" = "c",
#'     "(?i)anteil" = "d",
#'     .default = "i",
#'     .col_names = pal::dsv_colnames(raw_data)
#'   )
#' )
#'
#' # an alternative way to process the same data using `readr::type_convert()`:
#' readr::read_csv(file = raw_data,
#'                 col_types = list(.default = "c")) %>%
#'   readr::type_convert(col_types = pal::cols_regex(
#'     "^(Gemeindenamen|Partei)$" = "c",
#'     "(?i)anteil" = "d",
#'     .default = "i",
#'     .col_names = colnames(.)
#'   ))
cols_regex <- function(...,
                       .default = readr::col_character(),
                       .col_names) {
  
  assert_pkg("readr")
  
  if (length(names(list(...))) < ...length()) {
    rlang::abort("All column specifications in `...` must be named by a regular expression.")
  }
  
  patterns <- list(...)
  spec <- list()
  
  for (i in seq_along(patterns)) {
    matched_vars <- grep(x = .col_names,
                         pattern = names(patterns[i]),
                         value = TRUE,
                         perl = TRUE)
    
    spec <- c(spec, structure(rep(list(patterns[[i]]), length(matched_vars)),
                              names = matched_vars))
  }
  
  spec <- c(spec, alist(.default = .default))
  do.call(readr::cols, spec)
}

#' Get an object's roxygen2 tag value
#'
#' Parses `text` for [roxygen2 blocks][roxygen2::roxy_block()] and extracts the value(s) belonging to the `tag_name`s documenting `obj_name`.
#'
#' @param text The \R source code to extract the object's roxygen2 tag value from. A character vector.
#' @param obj_name The object name to which the roxygen2 tag belongs to, usually a function name. A character scalar.
#' @param tag_name The name of the [roxygen2 tag](https://roxygen2.r-lib.org/articles/rd.html) (without the `@`) to extract the value from. A character scalar.
#' @param param_name The parameter name to extract the value from. Only relevant if `tag_name = "param"`. A character scalar.
#'
#' @return A character scalar if `tag_name = "param"` and `param_name != NULL`, otherwise a list.
#' @export
#'
#' @examples
#' text <- readr::read_lines(paste0("https://raw.githubusercontent.com/r-lib/rlang/",
#'                                  "db52a58d505b65f58ba922d4752b5b0061f2a98c/R/fn.R"))
#'
#' roxy_tag_value(text = text,
#'                obj_name = "as_function",
#'                param_name = "x")
roxy_tag_value <- function(text,
                           obj_name,
                           tag_name = "param",
                           param_name = NULL) {
  
  assert_pkg("roxygen2")
  roxy_blocks <- roxygen2::parse_text(text = text)
  
  i_obj <- 
    roxy_blocks %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "object", "topic") %>%
    purrr::compact() %>%
    purrr::flatten_chr() %>%
    magrittr::equals(obj_name) %>%
    which()
  
  i_tag <-
    roxy_blocks[[i_obj]]$tags %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "tag") %>%
    purrr::compact() %>%
    purrr::flatten_chr() %>%
    magrittr::equals(tag_name) %>%
    which()
  
  tag_values <-
    i_tag %>%
    purrr::map(~ roxy_blocks[[i_obj]]$tags[[.x]]) %>%
    purrr::map_depth(.depth = 1L,
                     .f = purrr::pluck,
                     "val") %>%
    purrr::compact()
  
  if (tag_name == "param" & !is.null(param_name)) {
    
    i_param <-
      tag_values %>%
      purrr::map_depth(.depth = 1L,
                       .f = purrr::pluck,
                       "name") %>%
      purrr::compact() %>%
      purrr::flatten_chr() %>%
      magrittr::equals(checkmate::assert_string(param_name)) %>%
      which()
    
    result <- tag_values[[i_param]]$description
    
  } else {
    result <- tag_values
  }
  
  result
}
